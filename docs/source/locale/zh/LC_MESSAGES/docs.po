# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version:  EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-05 00:32+0800\n"
"PO-Revision-Date: 2024-04-29 02:49+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language: zh\n"
"Language-Team: Chinese (Simplified) "
"<https://hosted.weblate.org/projects/evox/evox/zh_Hans/>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/api/algorithms/containers/cc.rst:3
#: ../../source/guide/user/4-container.md:6
msgid "Cooperative Coevolution"
msgstr "协同演化"

#: evox.algorithms.containers.coevolution.VectorizedCoevolution:1 of
msgid "A container for vectorized co-evolutionary algorithms."
msgstr "向量化的协同演化算法容器"

#: ../../source/api/algorithms/containers/cc.rst
#: ../../source/api/algorithms/containers/clustered.rst
#: ../../source/api/algorithms/containers/tree.rst
#: ../../source/api/algorithms/mo/bce_ibea.rst
#: ../../source/api/algorithms/mo/bige.rst
#: ../../source/api/algorithms/mo/eagmoead.rst
#: ../../source/api/algorithms/mo/gde3.rst
#: ../../source/api/algorithms/mo/hype.rst
#: ../../source/api/algorithms/mo/ibea.rst
#: ../../source/api/algorithms/mo/im_moea.rst
#: ../../source/api/algorithms/mo/knea.rst
#: ../../source/api/algorithms/mo/lmocso.rst
#: ../../source/api/algorithms/mo/moead.rst
#: ../../source/api/algorithms/mo/moeaddra.rst
#: ../../source/api/algorithms/mo/moeadm2m.rst
#: ../../source/api/algorithms/mo/nsga2.rst
#: ../../source/api/algorithms/mo/nsga3.rst
#: ../../source/api/algorithms/mo/rvea.rst
#: ../../source/api/algorithms/mo/rveaa.rst
#: ../../source/api/algorithms/mo/spea2.rst
#: ../../source/api/algorithms/mo/sra.rst
#: ../../source/api/algorithms/mo/tdea.rst
#: ../../source/api/algorithms/so/ars.rst
#: ../../source/api/algorithms/so/asebo.rst
#: ../../source/api/algorithms/so/clpso.rst
#: ../../source/api/algorithms/so/cma_es.rst
#: ../../source/api/algorithms/so/code.rst
#: ../../source/api/algorithms/so/cr_fm_nes.rst
#: ../../source/api/algorithms/so/cso.rst ../../source/api/algorithms/so/de.rst
#: ../../source/api/algorithms/so/des.rst
#: ../../source/api/algorithms/so/dms_pso_el.rst
#: ../../source/api/algorithms/so/esmc.rst
#: ../../source/api/algorithms/so/fips.rst
#: ../../source/api/algorithms/so/guide_es.rst
#: ../../source/api/algorithms/so/jade.rst
#: ../../source/api/algorithms/so/les.rst
#: ../../source/api/algorithms/so/ma_es.rst
#: ../../source/api/algorithms/so/nes.rst
#: ../../source/api/algorithms/so/noise_reuse_es.rst
#: ../../source/api/algorithms/so/ode.rst
#: ../../source/api/algorithms/so/open_es.rst
#: ../../source/api/algorithms/so/persistent_es.rst
#: ../../source/api/algorithms/so/pgpe.rst
#: ../../source/api/algorithms/so/pso.rst
#: ../../source/api/algorithms/so/rmes.rst
#: ../../source/api/algorithms/so/sade.rst
#: ../../source/api/algorithms/so/shade.rst
#: ../../source/api/algorithms/so/sl_pso_gs.rst
#: ../../source/api/algorithms/so/sl_pso_us.rst
#: ../../source/api/algorithms/so/snes.rst
#: ../../source/api/algorithms/so/swmmpso.rst
#: ../../source/api/core/algorithm.rst ../../source/api/core/module.rst
#: ../../source/api/core/problem.rst ../../source/api/core/state.rst
#: ../../source/api/metrics/hv.rst ../../source/api/monitors/eval.rst
#: ../../source/api/monitors/evoxvis.rst ../../source/api/monitors/pop.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst
#: ../../source/api/problems/neuroevolution/supervised_learning/tfds.rst
#: ../../source/api/problems/numerical/test_functions/ackley.rst
#: ../../source/api/problems/numerical/test_functions/griewank.rst
#: ../../source/api/problems/numerical/test_functions/rastrigin.rst
#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst
#: ../../source/api/problems/numerical/test_functions/schwefel.rst
#: ../../source/api/problems/numerical/test_functions/sphere.rst
#: ../../source/api/problems/numerical/test_suits/cec2022.rst
#: ../../source/api/problems/numerical/test_suits/lsmop.rst
#: ../../source/api/problems/numerical/test_suits/maf.rst
#: ../../source/api/workflows/standard.rst evox.core.state.State.find_path_to
#: evox.core.state.State.index evox.core.state.State.prepend_closure
#: evox.core.state.State.query_state evox.core.state.State.register_callback
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__ of
msgid "Parameters"
msgstr "参数"

#: evox.algorithms.containers.coevolution.Coevolution:3
#: evox.algorithms.containers.coevolution.VectorizedCoevolution:3 of
msgid ""
"A batch of base algorithms. Usually created from `Stateful.stack(...)`, "
"where ... is a list of algorithms."
msgstr "一批基础算法。通常是由`Stateful.stack(...)`创建出来的，其中...是一个算法的列表。"

#: evox.algorithms.containers.coevolution.Coevolution:6
#: evox.algorithms.containers.coevolution.VectorizedCoevolution:6 of
msgid "The dimension of the problem in full."
msgstr "这个问题的完整的维度。"

#: evox.algorithms.containers.coevolution.Coevolution:8
#: evox.algorithms.containers.coevolution.VectorizedCoevolution:8 of
msgid "The number of subpopulations."
msgstr "子种群的个数。"

#: evox.algorithms.containers.coevolution.Coevolution:10
#: evox.algorithms.containers.coevolution.VectorizedCoevolution:10 of
msgid ""
"Whether to shuffle the problem dimension before co-evolution. When set to"
" False, each subpopulation will corespond to a contiguous block of the "
"decision variables, for example, dimension 0~9 for subpopulation 0, 10~19"
" for subpopulation 1, etc. When set to True, the decision variables will "
"be shuffled."
msgstr "是否打乱问题的维度。如果设置为False，那么每个子种群会对应原始的问题中连续的一段决策变量，比如说，0-9维会分配给0号子种群，10-19维会分配给1号子种群。当设置为True的时候，决策变量将会被打乱。"

#: ../../source/api/algorithms/containers/cc.rst
#: ../../source/api/algorithms/containers/clustered.rst
#: ../../source/api/algorithms/containers/tree.rst
#: ../../source/api/algorithms/mo/bce_ibea.rst
#: ../../source/api/algorithms/mo/bige.rst
#: ../../source/api/algorithms/mo/eagmoead.rst
#: ../../source/api/algorithms/mo/gde3.rst
#: ../../source/api/algorithms/mo/hype.rst
#: ../../source/api/algorithms/mo/ibea.rst
#: ../../source/api/algorithms/mo/im_moea.rst
#: ../../source/api/algorithms/mo/knea.rst
#: ../../source/api/algorithms/mo/lmocso.rst
#: ../../source/api/algorithms/mo/moead.rst
#: ../../source/api/algorithms/mo/moeaddra.rst
#: ../../source/api/algorithms/mo/moeadm2m.rst
#: ../../source/api/algorithms/mo/nsga2.rst
#: ../../source/api/algorithms/mo/nsga3.rst
#: ../../source/api/algorithms/mo/rvea.rst
#: ../../source/api/algorithms/mo/rveaa.rst
#: ../../source/api/algorithms/mo/spea2.rst
#: ../../source/api/algorithms/mo/sra.rst
#: ../../source/api/algorithms/mo/tdea.rst
#: ../../source/api/algorithms/so/ars.rst
#: ../../source/api/algorithms/so/asebo.rst
#: ../../source/api/algorithms/so/clpso.rst
#: ../../source/api/algorithms/so/cma_es.rst
#: ../../source/api/algorithms/so/code.rst
#: ../../source/api/algorithms/so/cr_fm_nes.rst
#: ../../source/api/algorithms/so/cso.rst ../../source/api/algorithms/so/de.rst
#: ../../source/api/algorithms/so/des.rst
#: ../../source/api/algorithms/so/dms_pso_el.rst
#: ../../source/api/algorithms/so/esmc.rst
#: ../../source/api/algorithms/so/fips.rst
#: ../../source/api/algorithms/so/guide_es.rst
#: ../../source/api/algorithms/so/jade.rst
#: ../../source/api/algorithms/so/les.rst
#: ../../source/api/algorithms/so/ma_es.rst
#: ../../source/api/algorithms/so/nes.rst
#: ../../source/api/algorithms/so/noise_reuse_es.rst
#: ../../source/api/algorithms/so/ode.rst
#: ../../source/api/algorithms/so/open_es.rst
#: ../../source/api/algorithms/so/persistent_es.rst
#: ../../source/api/algorithms/so/pgpe.rst
#: ../../source/api/algorithms/so/pso.rst
#: ../../source/api/algorithms/so/rmes.rst
#: ../../source/api/algorithms/so/sade.rst
#: ../../source/api/algorithms/so/shade.rst
#: ../../source/api/algorithms/so/sl_pso_gs.rst
#: ../../source/api/algorithms/so/sl_pso_us.rst
#: ../../source/api/algorithms/so/snes.rst
#: ../../source/api/algorithms/so/swmmpso.rst
#: ../../source/api/core/algorithm.rst ../../source/api/core/module.rst
#: ../../source/api/core/problem.rst ../../source/api/core/state.rst
#: ../../source/api/monitors/eval.rst ../../source/api/monitors/pop.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst
#: ../../source/api/problems/neuroevolution/supervised_learning/tfds.rst
#: ../../source/api/problems/numerical/test_functions/ackley.rst
#: ../../source/api/problems/numerical/test_functions/griewank.rst
#: ../../source/api/problems/numerical/test_functions/rastrigin.rst
#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst
#: ../../source/api/problems/numerical/test_functions/schwefel.rst
#: ../../source/api/problems/numerical/test_functions/sphere.rst
#: ../../source/api/problems/numerical/test_suits/cec2022.rst
#: ../../source/api/problems/numerical/test_suits/lsmop.rst
#: ../../source/api/problems/numerical/test_suits/maf.rst
#: ../../source/api/workflows/standard.rst
#: evox.core.state.State.clear_callbacks
#: evox.core.state.State.execute_callbacks evox.core.state.State.find_path_to
#: evox.core.state.State.index evox.core.state.State.prepend_closure
#: evox.core.state.State.query_state evox.core.state.State.register_callback
#: evox.monitors.eval_monitor.EvalMonitor.get_best_fitness
#: evox.monitors.eval_monitor.EvalMonitor.get_best_solution
#: evox.monitors.eval_monitor.EvalMonitor.get_fitness_history
#: evox.monitors.eval_monitor.EvalMonitor.get_latest_fitness
#: evox.monitors.eval_monitor.EvalMonitor.get_latest_solution
#: evox.monitors.eval_monitor.EvalMonitor.get_pf
#: evox.monitors.eval_monitor.EvalMonitor.get_pf_fitness
#: evox.monitors.eval_monitor.EvalMonitor.get_pf_solutions
#: evox.monitors.eval_monitor.EvalMonitor.get_solution_history
#: evox.monitors.eval_monitor.EvalMonitor.get_topk_fitness
#: evox.monitors.eval_monitor.EvalMonitor.get_topk_solutions of
msgid "Return type"
msgstr "返回值类型"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:1
#: evox.core.module.Stateful.init:1 of
msgid "Initialize this module and all submodules"
msgstr "初始化这个模块和所有的子模块"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:3
#: evox.core.module.Stateful.init:3 evox.core.module.Stateful.parallel_init:3
#: of
msgid "This method should not be overwritten."
msgstr "此方法不应被复写。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:6
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:5
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:6
#: evox.algorithms.mo.im_moea.IMMOEA.setup:6
#: evox.algorithms.mo.nsga3.NSGA3.setup:6
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:6
#: evox.algorithms.so.pso_variants.cso.CSO.setup:6
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:6
#: evox.algorithms.so.pso_variants.pso.PSO.setup:6
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:6
#: evox.core.module.Stateful.init:5 evox.core.module.Stateful.parallel_init:5
#: evox.core.module.Stateful.setup:6
#: evox.monitors.eval_monitor.EvalMonitor.setup:6
#: evox.monitors.pop_monitor.PopMonitor.setup:6
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:6
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:6
#: evox.workflows.std_workflow.StdWorkflow.setup:6 of
msgid "A PRNGKey."
msgstr "一个伪随机数生成器密钥。"

#: ../../source/api/algorithms/containers/cc.rst
#: ../../source/api/algorithms/containers/clustered.rst
#: ../../source/api/algorithms/containers/tree.rst
#: ../../source/api/algorithms/mo/bce_ibea.rst
#: ../../source/api/algorithms/mo/bige.rst
#: ../../source/api/algorithms/mo/eagmoead.rst
#: ../../source/api/algorithms/mo/gde3.rst
#: ../../source/api/algorithms/mo/hype.rst
#: ../../source/api/algorithms/mo/ibea.rst
#: ../../source/api/algorithms/mo/im_moea.rst
#: ../../source/api/algorithms/mo/knea.rst
#: ../../source/api/algorithms/mo/lmocso.rst
#: ../../source/api/algorithms/mo/moead.rst
#: ../../source/api/algorithms/mo/moeaddra.rst
#: ../../source/api/algorithms/mo/moeadm2m.rst
#: ../../source/api/algorithms/mo/nsga2.rst
#: ../../source/api/algorithms/mo/nsga3.rst
#: ../../source/api/algorithms/mo/rvea.rst
#: ../../source/api/algorithms/mo/rveaa.rst
#: ../../source/api/algorithms/mo/spea2.rst
#: ../../source/api/algorithms/mo/sra.rst
#: ../../source/api/algorithms/mo/tdea.rst
#: ../../source/api/algorithms/so/ars.rst
#: ../../source/api/algorithms/so/asebo.rst
#: ../../source/api/algorithms/so/clpso.rst
#: ../../source/api/algorithms/so/cma_es.rst
#: ../../source/api/algorithms/so/code.rst
#: ../../source/api/algorithms/so/cr_fm_nes.rst
#: ../../source/api/algorithms/so/cso.rst ../../source/api/algorithms/so/de.rst
#: ../../source/api/algorithms/so/des.rst
#: ../../source/api/algorithms/so/dms_pso_el.rst
#: ../../source/api/algorithms/so/esmc.rst
#: ../../source/api/algorithms/so/fips.rst
#: ../../source/api/algorithms/so/guide_es.rst
#: ../../source/api/algorithms/so/jade.rst
#: ../../source/api/algorithms/so/les.rst
#: ../../source/api/algorithms/so/ma_es.rst
#: ../../source/api/algorithms/so/nes.rst
#: ../../source/api/algorithms/so/noise_reuse_es.rst
#: ../../source/api/algorithms/so/ode.rst
#: ../../source/api/algorithms/so/open_es.rst
#: ../../source/api/algorithms/so/persistent_es.rst
#: ../../source/api/algorithms/so/pgpe.rst
#: ../../source/api/algorithms/so/pso.rst
#: ../../source/api/algorithms/so/rmes.rst
#: ../../source/api/algorithms/so/sade.rst
#: ../../source/api/algorithms/so/shade.rst
#: ../../source/api/algorithms/so/sl_pso_gs.rst
#: ../../source/api/algorithms/so/sl_pso_us.rst
#: ../../source/api/algorithms/so/snes.rst
#: ../../source/api/algorithms/so/swmmpso.rst
#: ../../source/api/core/algorithm.rst ../../source/api/core/module.rst
#: ../../source/api/core/problem.rst ../../source/api/monitors/eval.rst
#: ../../source/api/monitors/pop.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst
#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst
#: ../../source/api/problems/neuroevolution/supervised_learning/tfds.rst
#: ../../source/api/problems/numerical/test_functions/ackley.rst
#: ../../source/api/problems/numerical/test_functions/griewank.rst
#: ../../source/api/problems/numerical/test_functions/rastrigin.rst
#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst
#: ../../source/api/problems/numerical/test_functions/schwefel.rst
#: ../../source/api/problems/numerical/test_functions/sphere.rst
#: ../../source/api/problems/numerical/test_suits/cec2022.rst
#: ../../source/api/problems/numerical/test_suits/lsmop.rst
#: ../../source/api/problems/numerical/test_suits/maf.rst
#: ../../source/api/workflows/standard.rst
msgid "Returns"
msgstr "返回值"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:7
#: evox.core.module.Stateful.init:7 of
msgid "The state of this module and all submodules combined."
msgstr "该模块及其所有子模块的组合之和。"

#: evox.core.module.Stateful.parallel_init:1 of
#, fuzzy
msgid "Initialize multiple copies of this module in parallel"
msgstr "初始化这个问题的可变状态。"

#: evox.core.module.Stateful.parallel_init:6 of
#, fuzzy
msgid "The number of copies to be initialized"
msgstr "目标数量"

#: evox.core.module.Stateful.parallel_init:7 of
msgid "Whether to skip the state initialization"
msgstr ""

#: evox.core.module.Stateful.parallel_init:9 of
#, fuzzy
msgid "The state of this module and all submodules combined, and the last node_id"
msgstr "该模块及其所有子模块的组合之和。"

#: evox.core.pytree_dataclass._dataclass_replace:1 of
msgid ""
"Add a replace method to dataclasses. It's different from "
"dataclasses.replace in that it doesn't call the __init__, instead it "
"copies the object and sets the new values."
msgstr ""

#: evox.algorithms.containers.coevolution.Coevolution:1 of
msgid "A container for co-evolutionary algorithms."
msgstr "一个协同演化的算法容器。"

#: ../../source/api/algorithms/containers/clustered.rst:3
msgid "Clustered Algorithm"
msgstr "聚类算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:1 of
msgid ""
"A container that split the encoding into subproblems, and run an "
"Algorithm on each."
msgstr "一个容器，它将编码分割成若干子问题，并在每个子问题上运行一个算法。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:3 of
msgid ""
"Can take in any base algorithm, split the problem into n different sub-"
"problems and solve each problem using the base algorithm. Dim must be a "
"multiple of num_cluster, and num_cluster must be a multiple of num_gpus."
msgstr ""
"能够接收任何基础算法，将问题分割成 n "
"个不同的子问题，并使用基础算法解决每个子问题。其中，维度（Dim）必须是簇数量（num_cluster）的倍数，而簇数量（num_cluster）必须是"
" GPU 数量（num_gpus）的倍数。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:1
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:1
#: evox.algorithms.mo.im_moea.IMMOEA.ask:1 evox.algorithms.mo.nsga3.NSGA3.ask:1
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:1
#: evox.algorithms.so.pso_variants.cso.CSO.ask:1
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:1
#: evox.algorithms.so.pso_variants.pso.PSO.ask:1
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:1
#: evox.core.algorithm.Algorithm.ask:1 of
msgid "Ask the algorithm"
msgstr "询问这个算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:3
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:3
#: evox.algorithms.mo.im_moea.IMMOEA.ask:3 evox.algorithms.mo.nsga3.NSGA3.ask:3
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:3
#: evox.algorithms.so.pso_variants.cso.CSO.ask:3
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:3
#: evox.algorithms.so.pso_variants.pso.PSO.ask:3
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:3
#: evox.core.algorithm.Algorithm.ask:3 of
msgid "Ask the algorithm for points to explore"
msgstr "向算法询问要探索的点"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:5
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:5
#: evox.algorithms.mo.im_moea.IMMOEA.ask:5 evox.algorithms.mo.nsga3.NSGA3.ask:5
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:5
#: evox.algorithms.so.pso_variants.cso.CSO.ask:5
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:5
#: evox.algorithms.so.pso_variants.pso.PSO.ask:5
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:5
#: evox.core.algorithm.Algorithm.ask:5 of
msgid "The state of this algorithm."
msgstr "这个算法的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:7
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:7
#: evox.algorithms.mo.im_moea.IMMOEA.ask:7 evox.algorithms.mo.nsga3.NSGA3.ask:7
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:7
#: evox.algorithms.so.pso_variants.cso.CSO.ask:7
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:7
#: evox.algorithms.so.pso_variants.pso.PSO.ask:7
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:7
#: evox.core.algorithm.Algorithm.ask:7 of
msgid ""
"* *population* -- The candidate solution. * *state* -- The new state of "
"the algorithm."
msgstr ""

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:7
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:7
#: evox.algorithms.mo.im_moea.IMMOEA.ask:7 evox.algorithms.mo.nsga3.NSGA3.ask:7
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:7
#: evox.algorithms.so.pso_variants.cso.CSO.ask:7
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:7
#: evox.algorithms.so.pso_variants.pso.PSO.ask:7
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:7
#: evox.core.algorithm.Algorithm.ask:7 of
#, fuzzy
msgid "*population* -- The candidate solution."
msgstr "候选解。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:8
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:8
#: evox.algorithms.mo.im_moea.IMMOEA.ask:8 evox.algorithms.mo.nsga3.NSGA3.ask:8
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:8
#: evox.algorithms.so.pso_variants.cso.CSO.ask:8
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:8
#: evox.algorithms.so.pso_variants.pso.PSO.ask:8
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:8
#: evox.core.algorithm.Algorithm.ask:8 of
#, fuzzy
msgid "*state* -- The new state of the algorithm."
msgstr "算法的新的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:1
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:1
#: evox.algorithms.mo.im_moea.IMMOEA.setup:1
#: evox.algorithms.mo.nsga3.NSGA3.setup:1
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:1
#: evox.algorithms.so.pso_variants.cso.CSO.setup:1
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:1
#: evox.algorithms.so.pso_variants.pso.PSO.setup:1
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:1
#: evox.core.module.Stateful.setup:1
#: evox.monitors.eval_monitor.EvalMonitor.setup:1
#: evox.monitors.pop_monitor.PopMonitor.setup:1
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:1
#: evox.workflows.std_workflow.StdWorkflow.setup:1 of
msgid "Setup mutable state here"
msgstr "在这里设置可变状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:3
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:3
#: evox.algorithms.mo.im_moea.IMMOEA.setup:3
#: evox.algorithms.mo.nsga3.NSGA3.setup:3
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:3
#: evox.algorithms.so.pso_variants.cso.CSO.setup:3
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:3
#: evox.algorithms.so.pso_variants.pso.PSO.setup:3
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:3
#: evox.core.module.Stateful.setup:3
#: evox.monitors.eval_monitor.EvalMonitor.setup:3
#: evox.monitors.pop_monitor.PopMonitor.setup:3
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:3
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:3
#: evox.workflows.std_workflow.StdWorkflow.setup:3 of
msgid ""
"The state it self is immutable, but it act as a mutable state by "
"returning new state each time."
msgstr "状态本身是不可变的，但是你可以通过生成一个新的状态来实现修改的操作。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:8
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:8
#: evox.algorithms.mo.im_moea.IMMOEA.setup:8
#: evox.algorithms.mo.nsga3.NSGA3.setup:8
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:8
#: evox.algorithms.so.pso_variants.cso.CSO.setup:8
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:8
#: evox.algorithms.so.pso_variants.pso.PSO.setup:8
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:8
#: evox.core.module.Stateful.setup:8
#: evox.monitors.eval_monitor.EvalMonitor.setup:8
#: evox.monitors.pop_monitor.PopMonitor.setup:8
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:8
#: evox.workflows.std_workflow.StdWorkflow.setup:8 of
msgid "The state of this module."
msgstr "这个模块的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:1
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:1
#: evox.algorithms.mo.im_moea.IMMOEA.tell:1
#: evox.algorithms.mo.nsga3.NSGA3.tell:1
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:1
#: evox.algorithms.so.pso_variants.cso.CSO.tell:1
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:1
#: evox.algorithms.so.pso_variants.pso.PSO.tell:1
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:1
#: evox.core.algorithm.Algorithm.tell:1 of
msgid "Tell the algorithm more information"
msgstr "告诉算法更多的信息"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:3
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:3
#: evox.algorithms.mo.im_moea.IMMOEA.tell:3
#: evox.algorithms.mo.nsga3.NSGA3.tell:3
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:3
#: evox.algorithms.so.pso_variants.cso.CSO.tell:3
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:3
#: evox.algorithms.so.pso_variants.pso.PSO.tell:3
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:3
#: evox.core.algorithm.Algorithm.tell:3 of
msgid ""
"Tell the algorithm about the points it chose and their corresponding "
"fitness"
msgstr "告诉算法它选择的点以及它们对应的适应度"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:5
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:5
#: evox.algorithms.mo.im_moea.IMMOEA.tell:5
#: evox.algorithms.mo.nsga3.NSGA3.tell:5
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:5
#: evox.algorithms.so.pso_variants.cso.CSO.tell:5
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:5
#: evox.algorithms.so.pso_variants.pso.PSO.tell:5
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:5
#: evox.core.algorithm.Algorithm.tell:5 of
msgid "The state of this algorithm"
msgstr "算法的状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:6
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:6
#: evox.algorithms.mo.im_moea.IMMOEA.tell:6
#: evox.algorithms.mo.nsga3.NSGA3.tell:6
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:6
#: evox.algorithms.so.pso_variants.cso.CSO.tell:6
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:6
#: evox.algorithms.so.pso_variants.pso.PSO.tell:6
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:6
#: evox.core.algorithm.Algorithm.tell:6 of
msgid "The fitness"
msgstr "适应度值"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:8
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:8
#: evox.algorithms.mo.im_moea.IMMOEA.tell:8
#: evox.algorithms.mo.nsga3.NSGA3.tell:8
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:8
#: evox.algorithms.so.pso_variants.cso.CSO.tell:8
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:8
#: evox.algorithms.so.pso_variants.pso.PSO.tell:8
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:8
#: evox.core.algorithm.Algorithm.tell:8 of
msgid "The new state of the algorithm"
msgstr "算法的新状态"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:1 of
msgid "Cluster container with random mask"
msgstr "带有随机掩码的簇容器"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:3 of
msgid ""
"pop_size is needed, because JAX needs static shape, if pop_size is None, "
"it will try to read pop_size from base_algorithm"
msgstr "需要指定种群大小（pop_size），因为 JAX 需要静态形状，如果种群大小（pop_size）未设定，系统将尝试从基础算法中读取种群大小"

#: ../../source/api/algorithms/containers/index.rst:3
msgid "Containers"
msgstr "容器"

#: ../../source/api/algorithms/containers/tree.rst:3
msgid "Tree Algorithm"
msgstr "树算法"

#: ../../source/api/algorithms/index.rst:3
msgid "Algorithms"
msgstr "算法"

#: evox.algorithms:1 of
msgid ""
"The module that contains all pre-defined algorithms, including both "
"single-objective algorithms and multi-objective algorithms."
msgstr "包含所有预定义算法的模块，包括单目标算法和多目标算法。"

#: ../../source/api/algorithms/mo/bce_ibea.rst:3
msgid "BCEIBEA"
msgstr "BCEIBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:1 of
msgid "Bi-criterion evolution based IBEA"
msgstr "Bi-criterion evolution based IBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7347391"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7347391"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:5 of
msgid ""
"Note: The number of outer iterations needs to be set to Maximum "
"Generation*2+1."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:11 evox.algorithms.mo.ibea.IBEA:7
#: evox.algorithms.mo.lmocso.LMOCSO:9 evox.algorithms.mo.rvea.RVEA:10
#: evox.algorithms.mo.rveaa.RVEAa:10 of
msgid "Args:"
msgstr "参数："

#: evox.algorithms.mo.bce_ibea.BCEIBEA:11 of
msgid ""
"kappa (float, optional): The scaling factor for selecting parents in the "
"environmental selection."
msgstr "kappa（浮点型，可选）：环境选择中用于选择父代的缩放因子。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:9 of
msgid ""
"It controls the probability of selecting parents based on their fitness "
"values. Defaults to 0.05."
msgstr "它控制了基于个体适应度值选择父代的概率。默认值为0.05。"

#: ../../source/api/algorithms/mo/bige.rst:3
msgid "BiGE"
msgstr "BiGE"

#: evox.algorithms.mo.bige.BiGE:1 of
msgid "BiGE algorithm"
msgstr "BiGE算法"

#: evox.algorithms.mo.bige.BiGE:3 of
msgid "link: https://doi.org/10.1016/j.artint.2015.06.007"
msgstr "链接：https://doi.org/10.1016/j.artint.2015.06.007"

#: ../../source/api/algorithms/mo/eagmoead.rst:3
msgid "EAG-MOEA/D"
msgstr "EAG-MOEA/D"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:1 of
msgid "EAG-MOEA/D algorithm"
msgstr "EAG-MOEA/D算法"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6882229"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6882229"

#: ../../source/api/algorithms/mo/gde3.rst:3
msgid "GDE3"
msgstr "GDE3"

#: evox.algorithms.mo.gde3.GDE3:1 of
msgid "GDE3 algorithm"
msgstr "GDE3算法"

#: evox.algorithms.mo.gde3.GDE3:3 of
msgid "link: https://ieeexplore.ieee.org/document/1554717"
msgstr "链接：https://ieeexplore.ieee.org/document/1554717"

#: evox.algorithms.mo.gde3.GDE3.__init__:2 of
msgid "Parameters for Differential Evolution"
msgstr "差分演化的参数"

#: evox.algorithms.mo.gde3.GDE3.__init__:3 of
msgid "F"
msgstr "F"

#: evox.algorithms.mo.gde3.GDE3.__init__:4 of
msgid "The scaling factor"
msgstr "缩放因子"

#: evox.algorithms.mo.gde3.GDE3.__init__:5 of
msgid "CR"
msgstr "CR"

#: evox.algorithms.mo.gde3.GDE3.__init__:6 of
msgid "The probability of crossover"
msgstr "交叉概率"

#: ../../source/api/algorithms/mo/hype.rst:3
msgid "HypE"
msgstr "HypE"

#: evox.algorithms.mo.hype.HypE:1 of
msgid "HypE algorithm"
msgstr "HypE算法"

#: evox.algorithms.mo.hype.HypE:3 of
msgid ""
"link: https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"
msgstr ""
"链接：https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"

#: ../../source/api/algorithms/mo/ibea.rst:3
msgid "IBEA"
msgstr "IBEA"

#: evox.algorithms.mo.ibea.IBEA:1 of
msgid "IBEA algorithm"
msgstr "IBEA算法"

#: evox.algorithms.mo.ibea.IBEA:3 of
msgid "link: https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"
msgstr "链接：https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"

#: evox.algorithms.mo.ibea.IBEA:6 of
msgid "kappa: fitness scaling factor. Default: 0.05"
msgstr "kappa：适应度缩放因子。默认值：0.05"

#: ../../source/api/algorithms/mo/im_moea.rst:3
msgid "IMMOEA"
msgstr "IMMOEA"

#: evox.algorithms.mo.im_moea.IMMOEA.gp_offspring_:1 of
msgid "get sub_population by Gaussian Process and mutation."
msgstr ""

#: evox.algorithms.mo.im_moea.IMMOEA.nsgaii_selection:1 of
msgid "select certain number of sub_population by NSGA-II's selection algorithm."
msgstr ""

#: ../../source/api/algorithms/mo/index.rst:3
msgid "Multi-objective"
msgstr "多目标"

#: ../../source/api/algorithms/mo/knea.rst:3
msgid "KnEA"
msgstr "KnEA"

#: evox.algorithms.mo.knea.KnEA:1 of
msgid "KnEA algorithm"
msgstr "KnEA算法"

#: evox.algorithms.mo.knea.KnEA:3 of
msgid "link: https://ieeexplore.ieee.org/document/6975108"
msgstr "链接：https://ieeexplore.ieee.org/document/6975108"

#: ../../source/api/algorithms/mo/lmocso.rst:3
msgid "LMOCSO"
msgstr "LMOCSO"

#: evox.algorithms.mo.lmocso.LMOCSO:1 of
msgid "LMOCSO algorithm"
msgstr "LMOCSO算法"

#: evox.algorithms.mo.lmocso.LMOCSO:3 of
msgid "link: https://ieeexplore.ieee.org/document/8681243"
msgstr "链接：https://ieeexplore.ieee.org/document/8681243"

#: evox.algorithms.mo.lmocso.LMOCSO:6 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. max_gen : The maximum number of generations. Defaults to 100. If "
"the number of iterations is not 100, change the value based on the actual"
" value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/moead.rst:3
msgid "MOEA/D"
msgstr "MOEA/D"

#: evox.algorithms.mo.moead.MOEAD:1 of
#, fuzzy
msgid "Parallel MOEA/D algorithm"
msgstr "MOEA/D算法"

#: evox.algorithms.mo.moead.MOEAD:3 of
msgid "link: https://ieeexplore.ieee.org/document/4358754"
msgstr "链接：https://ieeexplore.ieee.org/document/4358754"

#: ../../source/api/algorithms/mo/moeaddra.rst:3
msgid "MOEA/D-DRA"
msgstr "MOEA/D-DRA"

#: evox.algorithms.mo.moeaddra.MOEADDRA:1 of
msgid "MOEA/D-DRA algorithm"
msgstr "MOEA/D-DRA算法"

#: evox.algorithms.mo.moeaddra.MOEADDRA:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/4982949"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/4982949"

#: ../../source/api/algorithms/mo/moeadm2m.rst:3
msgid "MOEA/D-M2M"
msgstr "MOEA/D-M2M"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:1 of
msgid "MOEA/D based on MOP to MOP algorithm"
msgstr "MOEA/D M2M 算法"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6595549"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6595549"

#: ../../source/api/algorithms/mo/nsga2.rst:3
msgid "NSGA-II"
msgstr "NSGA-II"

#: evox.algorithms.mo.nsga2.NSGA2:1 of
msgid "NSGA-II algorithm"
msgstr "NSGA-II算法"

#: evox.algorithms.mo.nsga2.NSGA2:3 of
msgid "link: https://ieeexplore.ieee.org/document/996017"
msgstr "链接：https://ieeexplore.ieee.org/document/996017"

#: ../../source/api/algorithms/mo/nsga3.rst:3
msgid "NSGA-III"
msgstr "NSGA-III"

#: evox.algorithms.mo.nsga3.NSGA3:1 of
msgid "NSGA-III algorithm"
msgstr "NSGA-III算法"

#: evox.algorithms.mo.nsga3.NSGA3:3 of
msgid "link: https://ieeexplore.ieee.org/document/6600851"
msgstr "链接：https://ieeexplore.ieee.org/document/6600851"

#: ../../source/api/algorithms/mo/rvea.rst:3
msgid "RVEA"
msgstr "RVEA"

#: evox.algorithms.mo.rvea.RVEA:1 of
msgid "RVEA algorithms"
msgstr "RVEA算法"

#: evox.algorithms.mo.rvea.RVEA:3 evox.algorithms.mo.rveaa.RVEAa:3 of
msgid "link: https://ieeexplore.ieee.org/document/7386636"
msgstr "链接：https://ieeexplore.ieee.org/document/7386636"

#: evox.algorithms.mo.rvea.RVEA:6 evox.algorithms.mo.rveaa.RVEAa:6 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. fr : The frequency of reference vector adaptation. Defaults to "
"0.1. max_gen : The maximum number of generations. Defaults to 100. If the"
" number of iterations is not 100, change the value based on the actual "
"value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。fr：参考向量适应频率。默认值为0.1。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/rveaa.rst:3
msgid "RVEAa"
msgstr "RVEAa"

#: evox.algorithms.mo.rveaa.RVEAa:1 of
msgid ""
"RVEAa algorithms (RVEA embedded with the reference vector regeneration "
"strategy)"
msgstr ""

#: ../../source/api/algorithms/mo/spea2.rst:3
msgid "SPEA2"
msgstr "SPEA2"

#: evox.algorithms.mo.spea2.SPEA2:1 of
msgid "SPEA2 algorithm"
msgstr "SPEA2算法"

#: evox.algorithms.mo.spea2.SPEA2:3 of
msgid "link: https://www.research-collection.ethz.ch/handle/20.500.11850/145755"
msgstr "链接：https://www.research-collection.ethz.ch/handle/20.500.11850/145755"

#: ../../source/api/algorithms/mo/sra.rst:3
msgid "SRA"
msgstr "SRA"

#: evox.algorithms.mo.sra.SRA:1 of
msgid "Stochastic ranking algorithm"
msgstr "随机排序算法"

#: evox.algorithms.mo.sra.SRA:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7445185"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7445185"

#: ../../source/api/algorithms/mo/tdea.rst:3
msgid "tDEA"
msgstr "tDEA"

#: evox.algorithms.mo.tdea.TDEA:1 of
msgid "Theta-dominance based evolutionary algorithm"
msgstr "基于θ优势的演化算法"

#: evox.algorithms.mo.tdea.TDEA:3 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7080938"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7080938"

#: ../../source/api/algorithms/so/amalgam.rst:3
msgid "AMaLGaM"
msgstr "AMaLGaM"

#: ../../source/api/algorithms/so/ars.rst:3
msgid "ARS"
msgstr "ARS"

#: ../../source/api/algorithms/so/asebo.rst:3
msgid "ASEBO"
msgstr "ASEBO"

#: ../../source/api/algorithms/so/clpso.rst:3
msgid "CLPSO"
msgstr "CLPSO"

#: ../../source/api/algorithms/so/cma_es.rst:3
msgid "CMA-ES"
msgstr "CMA-ES"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:1
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:1
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:1
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:1
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:1 of
msgid ""
"This implementation follows `The CMA Evolution Strategy: A Tutorial "
"<https://arxiv.org/pdf/1604.00772.pdf>`_."
msgstr ""
"这个实现遵循了《CMA 演化策略：教程》（The CMA Evolution Strategy: A "
"Tutorial），详情可见：https://arxiv.org/pdf/1604.00772.pdf。"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:4
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:4
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:4
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:4
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:4 of
msgid ""
"CMA-ES involves eigendecomposition, which introduces relatively large "
"numerical error, and may lead to non-deterministic behavior on different "
"hardware backends."
msgstr "CMA-ES涉及特征分解，这会引入相对较大的数值误差，并可能导致在不同硬件后端上的非确定性行为。"

#: ../../source/api/algorithms/so/code.rst:3
msgid "CoDE"
msgstr "CoDE"

#: evox.algorithms.so.de_variants.code.CoDE:1 of
msgid ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."

#: ../../source/api/algorithms/so/cr_fm_nes.rst:3
msgid "CR-FM-NES"
msgstr "CR-FM-NES"

#: ../../source/api/algorithms/so/cso.rst:3
msgid "CSO"
msgstr "CSO"

#: evox.algorithms.so.pso_variants.cso.CSO:1 of
msgid ""
"CSO(lb: jax.Array, ub: jax.Array, pop_size: int, phi: float = 0.0, mean: "
"Optional[jax.Array] = None, stdev: Optional[jax.Array] = None)"
msgstr ""

#: ../../source/api/algorithms/so/de.rst:3
msgid "DE"
msgstr "DE"

#: ../../source/api/algorithms/so/des.rst:3
msgid "DES"
msgstr "DES"

#: ../../source/api/algorithms/so/dms_pso_el.rst:3
msgid "DMS-PSO-EL"
msgstr "DMS-PSO-EL"

#: ../../source/api/algorithms/so/esmc.rst:3
msgid "ESMC"
msgstr "ESMC"

#: ../../source/api/algorithms/so/fips.rst:3
msgid "FIPS"
msgstr "FIPS"

#: ../../source/api/algorithms/so/guide_es.rst:3
msgid "GuidedES"
msgstr "GuidedES"

#: ../../source/api/algorithms/so/index.rst:3
msgid "Single-objective"
msgstr "单目标"

#: ../../source/api/algorithms/so/jade.rst:3
msgid "JaDE"
msgstr "JaDE"

#: evox.algorithms.so.de_variants.jade.JaDE:1 of
msgid ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."
msgstr ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."

#: ../../source/api/algorithms/so/les.rst:3
msgid "LES"
msgstr "LES"

#: ../../source/api/algorithms/so/ma_es.rst:3
msgid "MA-ES"
msgstr "MA-ES"

#: ../../source/api/algorithms/so/nes.rst:3
msgid "xNES"
msgstr "xNES"

#: evox.algorithms.so.es_variants.nes.SeparableNES.__init__:1
#: evox.algorithms.so.es_variants.nes.XNES.__init__:1 of
msgid "See [link](https://arxiv.org/pdf/1106.4487.pdf) for default parameters"
msgstr "参考链接[link](https://arxiv.org/pdf/1106.4487.pdf)中的默认参数"

#: ../../source/api/algorithms/so/noise_reuse_es.rst:3
msgid "Noise-Reuse-ES"
msgstr "Noise-Reuse-ES"

#: ../../source/api/algorithms/so/ode.rst:3
msgid "ODE"
msgstr "ODE"

#: ../../source/api/algorithms/so/open_es.rst:3
msgid "OpenES"
msgstr "OpenES"

#: evox.algorithms.so.es_variants.open_es.OpenES.__init__:1 of
msgid ""
"Implement the algorithm described in \"Evolution Strategies as a Scalable"
" Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864"
msgstr ""
"实现论文 \"Evolution Strategies as a Scalable Alternative to Reinforcement "
"Learning\" 中描述的算法，链接为https://arxiv.org/abs/1703.03864"

#: ../../source/api/algorithms/so/persistent_es.rst:3
msgid "PersistentES"
msgstr "PersistentES"

#: ../../source/api/algorithms/so/pgpe.rst:3
msgid "PGPE"
msgstr "PGPE"

#: evox.algorithms.so.es_variants.pgpe.PGPE:1 of
msgid ""
"PGPE(pop_size: int, center_init: jax.Array, optimizer: Union[str, "
"optax._src.base.GradientTransformation, evox.core.module.Stateful], "
"stdev_init: float = 0.1, center_learning_rate: float = 0.15, "
"stdev_learning_rate: float = 0.1, stdev_max_change: float = 0.2)"
msgstr ""

#: ../../source/api/algorithms/so/pso.rst:3
msgid "PSO"
msgstr "PSO"

#: evox.algorithms.so.pso_variants.pso.PSO:1 of
msgid ""
"PSO(lb: jax.Array, ub: jax.Array, pop_size: jax.Array, w: jax.Array = "
"0.6, phi_p: jax.Array = 2.5, phi_g: jax.Array = 0.8, mean: "
"Optional[jax.Array] = None, stdev: Optional[jax.Array] = None, "
"bound_method: str = 'clip')"
msgstr ""

#: ../../source/api/algorithms/so/rmes.rst:3
msgid "RMES"
msgstr "RMES"

#: ../../source/api/algorithms/so/sade.rst:3
msgid "SaDE"
msgstr "SaDE"

#: evox.algorithms.so.de_variants.sade.SaDE:1 of
msgid ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../source/api/algorithms/so/shade.rst:3
msgid "SHADE"
msgstr "SHADE"

#: evox.algorithms.so.de_variants.shade.SHADE:1 of
msgid ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."

#: ../../source/api/algorithms/so/sl_pso_gs.rst:3
msgid "SL-PSO-GS"
msgstr "SL-PSO-GS"

#: ../../source/api/algorithms/so/sl_pso_us.rst:3
msgid "SL-PSO-US"
msgstr "SL-PSO-US"

#: ../../source/api/algorithms/so/snes.rst:3
msgid "SNES"
msgstr "SNES"

#: ../../source/api/algorithms/so/swmmpso.rst:3
msgid "SWMMPSO"
msgstr "SWMMPSO"

#: ../../source/api/core/algorithm.rst:3
msgid "Algorithm Class"
msgstr "算法类"

#: evox.core.algorithm.Algorithm:1 evox.core.problem.Problem:1 of
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/api/core/index.rst:3
msgid "Core Classes"
msgstr "核心类"

#: ../../source/api/core/module.rst:3
msgid "Module Class"
msgstr "模块类"

#: evox.core.module.Stateful:1 of
msgid "Base class for all evox modules."
msgstr "所有EvoX模块的基础类。"

#: evox.core.module.Stateful:3 of
msgid "This module allow easy managing of states."
msgstr "这个模块允许轻松管理状态。"

#: evox.core.module.Stateful:5 of
msgid ""
"All the constants (e.g. hyperparameters) are initialized in the "
"``__init__``, and mutated states are initialized in the ``setup`` method."
msgstr "所有常数（例如超参数）都在“ __init__” 中初始化，而变异状态则在 “setup” 方法中初始化。"

#: evox.core.module.Stateful:8 of
msgid ""
"The ``init`` method will automatically call the ``setup`` of the current "
"module and recursively call ``setup`` methods of all submodules."
msgstr "“init” 方法将自动调用当前模块的 “setup”，并递归地调用所有子模块的 “setup” 方法。"

#: evox.core.module.Stateful:11 of
msgid ""
"Currently, there are two special metadata that can be used to control the"
" behavior of the module initialization: - ``stack``: If set to True, the "
"module will be initialized multiple times, and the states will be stacked"
" together. - ``nested``: If set to True, the a list of modules, that is "
"[module1, module2, ...], will be iterated and initialized."
msgstr ""

#: ../../source/api/core/problem.rst:3
msgid "Problem Class"
msgstr "问题类"

#: evox.core.problem.Problem.evaluate:1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:1
#: evox.problems.numerical.ackley.Ackley.evaluate:1 of
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: evox.core.problem.Problem.evaluate:3
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:3
#: evox.problems.numerical.ackley.Ackley.evaluate:3 of
msgid "The state of this problem."
msgstr "这个问题的状态。"

#: evox.core.problem.Problem.evaluate:5
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:5
#: evox.problems.numerical.ackley.Ackley.evaluate:5 of
msgid "The population."
msgstr "种群。"

#: evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8
#: evox.problems.numerical.ackley.Ackley.evaluate:8 of
msgid "* *dict* -- The new state of the problem. * *ndarray* -- The fitness."
msgstr ""

#: evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8
#: evox.problems.numerical.ackley.Ackley.evaluate:8 of
#, fuzzy
msgid "*dict* -- The new state of the problem."
msgstr "这个问题的新的状态。"

#: evox.core.problem.Problem.evaluate:9
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:9
#: evox.problems.numerical.ackley.Ackley.evaluate:9 of
#, fuzzy
msgid "*ndarray* -- The fitness."
msgstr "适应度值。"

#: ../../source/api/core/state.rst:3
msgid "State Class"
msgstr "状态类"

#: evox.core.state.State:1 of
msgid "A class represents state"
msgstr "一个表示状态的类"

#: evox.core.state.State:3 of
msgid ""
"``State`` is immutable, to update state, use the ``update`` method or the"
" ``|`` operator. ``State`` has already implemented ``tree_flatten``, "
"``tree_unflatten`` and has registered as a valid pytree node. So it can "
"be used as pytree with JAX without any issue."
msgstr ""
"“State ”是不可变的，要更新状态，请使用“update ” 方法或 “| ”运算符。“State ” 已经实现了 "
"“tree_flatten”、“tree_unflatten ”并且已注册为有效的 pytree 节点。因此，它可以与 JAX 一起作为 "
"pytree 使用。"

#: evox.core.state.State.__init__:1 of
msgid "Construct a ``State`` from dataclass instance or keyword arguments"
msgstr "从Python数据类（dataclass）或关键字（keyword arguments）构建一个状态（State）对象"

#: evox.core.state.State.__init__:14 evox.core.state.State.from_dataclass:12
#: evox.core.state.State.replace:10 of
msgid "Example::"
msgstr "例子："

#: evox.core.state.State.clear_callbacks:1 of
msgid "Clear all the callbacks in the state"
msgstr ""

#: evox.core.state.State.execute_callbacks:1 of
msgid "Execute all the callbacks in the state"
msgstr ""

#: evox.core.state.State.find_path_to:1 of
msgid ""
"Find the state with node_id matching the state_id A hint can be given "
"with the module_name"
msgstr "找到节点 ID 与状态 ID 匹配的状态。可以通过模块名称给出提示"

#: evox.core.state.State.from_dataclass:1 of
#, fuzzy
msgid "Construct a ``State`` from dataclass instance"
msgstr "从Python数据类（dataclass）或关键字（keyword arguments）构建一个状态（State）对象"

#: evox.core.state.State.index:1 of
msgid "PyTree index, apply the index to every element in the state."
msgstr "对Pytree进行索引，将对Pytree中的每个元素使用索引。"

#: evox.core.state.State.load:1 of
msgid "Load the saved state from disk"
msgstr ""

#: evox.core.state.State.load:3 of
msgid "The path to load the state"
msgstr ""

#: evox.core.state.State.load:5 of
msgid "If True, use orbax to load the state, otherwise use pickle"
msgstr ""

#: evox.core.state.State.prepend_closure:1 of
msgid "Prepare closures stored in others to the current state"
msgstr ""

#: evox.core.state.State.query_state:1 of
msgid ""
"Recursively find a sub-state by a query name. eg: `'foo.bar'` will find a"
" sub state named foo, then find `bar` under sub-states of `foo`"
msgstr ""

#: evox.core.state.State.register_callback:1 of
msgid "Add a callback to the state"
msgstr ""

#: evox.core.state.State.replace:1 of
msgid "Update the current State with another State or dict and return new State."
msgstr "使用另一个 State 或 dict 更新当前 State，并返回新的 State。"

#: evox.core.state.State.replace:3 of
msgid "This method also accept keyword arguments."
msgstr "这个方法也接受关键字参数。"

#: evox.core.state.State.save:1 of
msgid "Save the state to local filesystem"
msgstr ""

#: evox.core.state.State.save:3 of
msgid "The path to save the state"
msgstr ""

#: evox.core.state.State.save:5 of
msgid "If True, use orbax to save the state, otherwise use pickle"
msgstr ""

#: ../../source/api/metrics/gd.rst:3
msgid "Generational Distance"
msgstr "世代距离"

#: ../../source/api/metrics/hv.rst:3
msgid "Hypervolume"
msgstr "超体积"

#: evox.metrics.hypervolume.HV:1 of
msgid ""
"Hypervolume indicator Implemented using monte carlo. We offers two "
"different sample methods: `bounding_cube` and `each_cube`. With "
"`bounding_cube`, we draw samples from a hypercube that can bound all "
"objectives. With `each_cube`, we draw samples from each hypercube form by"
" each objective and the reference point. Since reference point is often "
"far from pf, `bounding_cube` method usually gives more accurate result."
msgstr ""
"超体积指标，使用蒙特卡洛方法实现。我们提供两种不同的样本方法：`bounding_cube` 和 `each_cube`。使用 "
"`bounding_cube` 方法，我们从一个可以包围所有目标的超立方体中抽取样本。使用 `each_cube` "
"方法，我们从由每个目标和参考点形成的每个超立方体中抽取样本。由于参考点通常远离帕雷托前沿（pf），`bounding_cube`方法通常能提供更准确的结果。"

#: evox.metrics.hypervolume.HV.__init__:1 of
msgid "The reference point."
msgstr "参考点。"

#: evox.metrics.hypervolume.HV.__init__:2 of
msgid "Number of samples to draw when doing monte carlo."
msgstr "在使用蒙特卡洛方法的时候样本的数量。"

#: evox.metrics.hypervolume.HV.__init__:3 of
msgid "`bounding_cube` or `each_cube`. Default to `bounding_cube`."
msgstr "`bounding_cube` 或 `each_cube`. 默认为 `bounding_cube`."

#: ../../source/api/metrics/igd.rst:3
msgid "Inverted Generational Distance"
msgstr "反世代距离"

#: ../../source/api/metrics/index.rst:3
msgid "Metrics"
msgstr "度量指标"

#: ../../source/api/monitors/eval.rst:3
msgid "Evaluation Monitor"
msgstr "评估监控器"

#: evox.monitors.eval_monitor.EvalMonitor:1 of
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the "
"offspring, their corresponding fitness and keep track of the evaluation "
"count. Moreover, it can also record the best solution or the pareto front"
" on-the-fly."
msgstr "评估监控器被用于单目标和多目标工作流。它与评估流程挂钩，可以监控子代及其相应的适应度并对评估计数进行跟踪。此外，它还能即时记录最优解或帕累托前沿。"

#: evox.monitors.eval_monitor.EvalMonitor:7 of
msgid "Whether the optimization is multi-objective. Default to False."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor:10 of
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: evox.monitors.eval_monitor.EvalMonitor:13 of
msgid ""
"Whether to record the full history of solutions. Default to False. "
"Setting it to True may increase memory usage, and adding a significant "
"overhead of transfering the entire solutions set from GPU to CPU."
msgstr "是否记录完整的解集的历史。默认值为False。将其设置为True可能会减少内存占用，并会带来很大的GPU/CPU间数据传输开销。"

#: evox.monitors.eval_monitor.EvalMonitor:18 of
msgid ""
"Only affect Single-objective optimization. The number of elite solutions "
"to record. Default to 1, which will record the best individual."
msgstr "只影响单目标优化。要记录的精英解决方案的数量。默认为 1，将记录最佳个人。"

#: evox.monitors.eval_monitor.EvalMonitor.clear_history:1
#: evox.monitors.pop_monitor.PopMonitor.clear_history:1 of
msgid ""
"Clear the history of fitness and solutions. Normally it will be called at"
" the initialization of Workflow object."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_best_fitness:1 of
msgid "Get the best fitness value so far."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_best_solution:1 of
msgid "Get the best solution so far."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_fitness_history:1 of
msgid "Get the full history of fitness values."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_latest_fitness:1 of
msgid "Get the fitness values from the latest iteration."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_latest_solution:1 of
msgid "Get the solution from the latest iteration."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_pf:1 of
msgid ""
"Get the approximate pareto front solutions and fitness values of all the "
"solutions evaluated so far. Requires enabling both `full_sol_history` and"
" `full_sol_history`. If `deduplicate` is set to True, the duplicated "
"solutions will be removed."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_pf_fitness:1 of
msgid ""
"Get the approximate pareto front fitness values of all the solutions "
"evaluated so far. Requires enabling `full_fit_history`."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_pf_solutions:1 of
msgid ""
"Get the approximate pareto front solutions of all the solutions evaluated"
" so far. Requires enabling both `full_sol_history` and "
"`full_sol_history`. If `deduplicate` is set to True, the duplicated "
"solutions will be removed."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_solution_history:1 of
msgid "Get the full history of solutions."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_topk_fitness:1 of
msgid "Get the topk fitness values so far."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor.get_topk_solutions:1 of
msgid "Get the topk solutions so far."
msgstr ""

#: ../../source/api/monitors/evoxvis.rst:3
msgid "EvoXVis Monitor"
msgstr "EvoXVis 监视器"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor:1 of
msgid ""
"This class serialize data to apache arrow format, which can be picked up "
"and used in EvoXVis. The tensors are stored as fixed size binary and the "
"dtype is recorded in the metadata."
msgstr "这个类将数据序列化为可以在EvoXVis中提取和使用的apache arrow格式。张量被存储为固定大小的二进制，并且数据类型被记录在元数据中。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:1 of
msgid ""
"The base filename of the log file, the final filename will be "
"``<base_filename>_<i>.arrow``, where i is an incrementing number."
msgstr "日志文件的基本文件名，最终文件名将是``<base_filename>_<i>.arrow``，其中i是递增的数字。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:4 of
msgid ""
"This directory to write the log file into. When set to None, the default "
"directory will be used. The default is ``<TEMP_DIR>/evox``, on Windows, "
"it's usually ``C:\\TEMP\\evox``, and on MacOS/Linux/BSDs it's "
"``/tmp/evox``."
msgstr "将日志文件写入的目录。当设置为None时，将使用默认目录。默认为``<TEMP_DIR>/evox``，在Windows上通常为``C：\\temp\\evox``，在MacOS/Linux/BSD上为``/tMP/evox``。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:9 of
msgid ""
"\"stream\" or \"file\", For more information, please refer to "
"https://arrow.apache.org/docs/python/ipc.html"
msgstr ""
"\"stream\" 或\"file\"，更多信息，请参考 "
"https://arrow.apache.org/docs/python/ipc.html"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:12 of
msgid ""
"The monitor will buffer the data in memory and write out every `batch "
"size`. Choose a larger value may improve I/O performance and improve "
"compression ratio, if compression is enabled. Default to 64."
msgstr "监控器会将数据缓存在内存中，并写出每个`batch size`。如果启用了压缩，则选择较大的值可能会提高I/O性能并提高压缩比。默认为64。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:17 of
msgid ""
"Controls the compression algorithm used when writing to the file. "
"Available options are None, \"lz4\", \"zstd\", \"lz4\" is extremely fast,"
" with poor compression ratio, \"zstd\" is fast, but also with good "
"compression ratio."
msgstr "控制写入文件时使用的压缩算法。可供选择的有None、“lz4”、“zstd”，“lz4”速度极快，压缩比差，“zstd”速度快，同时压缩比也很好。"

#: ../../source/api/monitors/index.rst:3
msgid "Monitors"
msgstr "监视器"

#: ../../source/api/monitors/pop.rst:3
msgid "Population Monitor"
msgstr "种群监控器"

#: evox.monitors.pop_monitor.PopMonitor:1 of
msgid ""
"Population monitor, used to monitor the population inside the genetic "
"algorithm."
msgstr "种群监视器，用于监视演化算法内部的种群。"

#: evox.monitors.pop_monitor.PopMonitor:4 of
msgid "The name of the population in the state. Default to \"population\"."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: evox.monitors.pop_monitor.PopMonitor:7 of
msgid "The name of the fitness in the state. Default to \"fitness\"."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: evox.monitors.pop_monitor.PopMonitor:10 of
msgid ""
"Whether to move the population and fitness to host memory (ram). Doing so"
" can reduce memory usage on device (vram), but also introduces overhead "
"of data transfer. Default to False."
msgstr ""

#: evox.monitors.pop_monitor.PopMonitor:14 of
msgid ""
"Whether to only record the fitness. Setting it to True will disable the "
"recording of population (decision space), only the fitness (objective "
"space) will be recorded. This can reduce memory usage if you only care "
"about the fitness. Default to False."
msgstr ""

#: ../../source/api/problems/index.rst:3
msgid "Problems"
msgstr "问题"

#: evox.problems:1 of
msgid "The module that contains all pre-defined problems"
msgstr "包含所有预定义的问题的模块"

#: ../../source/api/problems/neuroevolution/index.rst:3
msgid "Neuroevolution"
msgstr "神经演化"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst:3
msgid "Brax-based Problem"
msgstr "基于Brax的问题"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:1 of
msgid ""
"Contruct a brax-based problem. Firstly, you need to define a jit-able "
"policy function. The policy function should have the following signature:"
" If you policy is not stateful: :code:`fn(weights, obs) -> action`, and "
"if you policy is stateful: :code:`fn(state, weights, obs) -> action, "
"state`. Then you need to set the `environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`_, the maximum "
"episode length, the number of episodes to evaluate for each individual. "
"For each individual, it will run the policy with the environment for "
"num_episodes times with different seed, and use the reduce_fn to reduce "
"the rewards (default to average). Different individuals will share the "
"same set of random keys in each iteration."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:14 of
msgid ""
"A callable if stateful: :code:`fn(state, weight, obs) -> action, state` "
"otherwise :code:`fn(weights, obs) -> action`"
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:15 of
msgid "The environment name."
msgstr "环境名。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:16 of
#, fuzzy
msgid "The maximum number of timesteps of each episode."
msgstr "运行的最大episode数量。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:17 of
msgid "The number of episodes to evaluate for each individual."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:18 of
msgid ""
"Indicates whether to rotate the random key for each iteration (default is"
" True).  If True, the random key will rotate after each iteration, "
"resulting in non-deterministic and potentially noisy fitness evaluations."
" This means that identical policy weights may yield different fitness "
"values across iterations.  If False, the random key remains the same for "
"all iterations, ensuring consistent fitness evaluations."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:18 of
msgid ""
"Indicates whether to rotate the random key for each iteration (default is"
" True)."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:20 of
msgid ""
"If True, the random key will rotate after each iteration, resulting in "
"non-deterministic and potentially noisy fitness evaluations. This means "
"that identical policy weights may yield different fitness values across "
"iterations."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:24 of
msgid ""
"If False, the random key remains the same for all iterations, ensuring "
"consistent fitness evaluations."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:26 of
msgid ""
"Whether the policy is stateful (for example, RNN). Default to False. If "
"False, the policy should be a pure function with signature "
":code:`fn(weights, obs) -> action`. If True, the policy should be a "
"stateful function with signature :code:`fn(state, weight, obs) -> action,"
" state`."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:30 of
msgid ""
"The initial state of the stateful policy. Default to None. Only used when"
" stateful_policy is True."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:33 of
msgid ""
"The function to reduce the rewards of multiple episodes. Default to "
"jnp.mean."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:35 of
msgid ""
"Brax's backend, one of \"generalized\", \"positional\", \"spring\". "
"Default to \"generalized\"."
msgstr "Brax的后端，是“generalized”、“positional”、“spring”中的其中一个。默认为“generalized”。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:39 of
#, fuzzy
msgid "Notes"
msgstr "xNES"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:40 of
msgid ""
"When rotating keys, fitness evaluation is non-deterministic and may "
"introduce noise."
msgstr ""

#: ../../source/index.md:26
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:43 of
msgid "Examples"
msgstr "示例"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:1 of
msgid "Visualize the brax environment with the given policy and weights."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:3 of
msgid "The random key."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:4 of
#, fuzzy
msgid "The weights of the policy."
msgstr "这个问题的新的状态。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:5 of
msgid "The output type, either \"HTML\" or \"rgb_array\"."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:6 of
msgid "Whether to respect the done signal."
msgstr ""

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.visualize:7 of
msgid ""
"The number of episodes to visualize, used to override the num_episodes in"
" the constructor. If None, use the num_episodes in the constructor."
msgstr ""

#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst:3
msgid "Env Pool"
msgstr "环境池"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst:3
msgid "Gym"
msgstr "Gym"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:1 of
msgid "Construct a gym problem"
msgstr "构建一个gym 问题"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:3 of
msgid ""
"A function that accept two arguments the first one is the parameter and "
"the second is the input."
msgstr "一个接受两个参数的函数，第一个参数是参数本身，第二个是输入。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:5 of
msgid "Number of worker actors."
msgstr "工作者（worker）actor的数量。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:6 of
msgid "The name of the gym environment."
msgstr "Gym环境的名称。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:7 of
msgid "The options of the gym environment."
msgstr "gym 环境的选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:8 of
msgid "A function with zero argument that returns an environment when called."
msgstr "一个调用时返回一个环境的零参数函数。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:9 of
msgid ""
"Optional, a list of strings. If set, the environment is treated as a "
"multi-objective problem, and different objective values are obtained "
"through the `info` term returned by Gym. The `mo_keys` parameter provides"
" the keys for accessing the objective values in the info dictionary. The "
"objective values will be returned in the same order as specified in "
"`mo_keys`."
msgstr "可选参数，一个字符串列表。如果设置，环境被视为一个多目标问题，不同的目标值通过Gym返回的`info`项获取。`mo_keys`参数提供了在info字典中访问目标值的键。目标值将按照在`mo_keys`中指定的顺序返回。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:14 of
#, fuzzy
msgid ""
"The runtime options for controller actor. This actor is used to control "
"workers and run the policy at each step. For example, to enable GPU "
"acceleration on the policy network, set this field to::      "
"{\"num_gpus\": 1}"
msgstr "控制器actor的运行时选项。这个actor用于控制工作者worker，并在每一步运行策略。例如，要启用策略网络的GPU加速功能，请将此字段设置为::"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:14 of
msgid ""
"The runtime options for controller actor. This actor is used to control "
"workers and run the policy at each step. For example, to enable GPU "
"acceleration on the policy network, set this field to::"
msgstr "控制器actor的运行时选项。这个actor用于控制工作者worker，并在每一步运行策略。例如，要启用策略网络的GPU加速功能，请将此字段设置为::"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:20 of
msgid "The runtime options for worker actors."
msgstr "工作者（actor）的运行时选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:1 of
msgid ""
"Visualize your policy, passin a single set of weights, and it will be put"
" in the environment for interaction."
msgstr "可视化您的策略，通过传递一组权重，该策略将会被置于环境中进行互动展示。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:4 of
msgid "The state."
msgstr "状态。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:5 of
msgid "This key will be used to seed the test environment."
msgstr "此密钥将会作为测试环境的随机数种子。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:6 of
msgid "A single set of weights for your policy."
msgstr "策略的一组权重。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:7 of
#, fuzzy
msgid ""
"'rgb_array' or 'human'.  In 'rgb_array' mode, this function will return a"
" list of frames, each frame is a numpy array.  In 'human' mode, the frame"
" should be displayed directly onto your screen. However, if your using "
"remote python environment, for example vscode ssh or jupyter notebook, "
"this method may fail to find a valid display. Default to 'rgb_array'."
msgstr ""
"在\"human\"模式下，帧应直接显示在屏幕上。但是，如果您正在使用远程Python环境（例如VSCode SSH或Jupyter "
"Notebook），这种方法可能无法找到有效的显示器，因此默认设置为\"rgb_array\"模式。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:7 of
msgid "'rgb_array' or 'human'."
msgstr "'rgb_array' 或 'human'。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:9 of
msgid ""
"In 'rgb_array' mode, this function will return a list of frames, each "
"frame is a numpy array."
msgstr "在\"rgb_array\"模式下，该函数将返回一个帧列表，每个帧都是一个numpy数组。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:12 of
msgid ""
"In 'human' mode, the frame should be displayed directly onto your screen."
" However, if your using remote python environment, for example vscode ssh"
" or jupyter notebook, this method may fail to find a valid display. "
"Default to 'rgb_array'."
msgstr ""
"在\"human\"模式下，帧应直接显示在屏幕上。但是，如果您正在使用远程Python环境（例如VSCode SSH或Jupyter "
"Notebook），这种方法可能无法找到有效的显示器，因此默认设置为\"rgb_array\"模式。"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/index.rst:3
msgid "Reinforcement Learning"
msgstr "强化学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/index.rst:3
msgid "Supervised Learning"
msgstr "监督学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/tfds.rst:3
#, fuzzy
msgid "Tensorflow Dataset"
msgstr "Torchvision 数据集"

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:1 of
msgid "Wrap a tensorflow dataset as a problem."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:3 of
msgid ""
"TensorFlow Datasets (TFDS) directly depends on the package `tensorflow-"
"datasets` and `grain`. Additionally, when downloading the dataset for the"
" first time, it requires `tensorflow` to be installed and a active "
"internet connection. If you want to avoid installing `tensorflow`, you "
"can prepare the dataset beforehand in another environment with "
"`tensorflow` installed, run:"
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:13
#: of
msgid ""
"and then copy the dataset to the target machine. The default location "
"is`~/tensorflow_datasets`. `~/` means the home directory of the user."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:16
#: of
msgid ""
"Please notice that the data is loaded under JAX's jit context, so the "
"data should be valid JAX data type, namely JAX or Numpy arrays, or "
"Python's int, float, list, and dict. If the data contains other types "
"like strings, you should convert them into arrays using the `operations` "
"parameter."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:20
#: of
msgid ""
"You can also download the dataset through a proxy server by setting the "
"environment variable `TFDS_HTTP_PROXY` and `TFDS_HTTPS_PROXY`, for http "
"and https proxy respectively."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:23
#: of
msgid ""
"The details of the dataset can be found at "
"https://www.tensorflow.org/datasets/catalog/overview The details about "
"operations/transformations can be found at "
"https://github.com/google/grain/blob/main/docs/transformations.md"
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:26
#: of
#, fuzzy
msgid "The dataset name."
msgstr "状态。"

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:28
#: of
#, fuzzy
msgid "The batch size."
msgstr "状态。"

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:30
#: of
msgid ""
"The loss function. The function signature is loss(weights, data) -> "
"loss_value, and it should be jittable. The `weight` is the weight of the "
"neural network, and the `data` is the data from TFDS, which is a "
"dictionary."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:34
#: of
#, fuzzy
msgid "Which split of the dataset to use. Default to \"train\"."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:37
#: of
msgid ""
"The list of transformations to apply to the data. Default to []. After "
"the transformations, we will always apply a batch operation to create a "
"batch of data."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:41
#: of
msgid ""
"The directory to store the dataset. Default to None, which means "
"tensorflow-datasets will automatically determine the directory."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:44
#: of
msgid ""
"The random seed used to seed the dataloader. Given the same seed, the "
"dataloader should data in the same order. Default to 0."
msgstr ""

#: evox.problems.neuroevolution.supervised_learning.tfds.TensorflowDataset:48
#: of
msgid ""
"Whether to try to download the dataset from Google Cloud Storage. Usually"
" Google's storage server is faster than the original server of the "
"dataset."
msgstr ""

#: ../../source/api/problems/numerical/index.rst:3
msgid "Numerical Benchmarks"
msgstr "数值基准测试"

#: ../../source/api/problems/numerical/test_functions/ackley.rst:3
msgid "Ackley"
msgstr "Ackley"

#: evox.problems.numerical.ackley.Ackley:1 of
msgid "Ackley(a: float = 20, b: float = 0.2, c: float = 6.283185307179586)"
msgstr ""

#: ../../source/api/problems/numerical/test_functions/griewank.rst:3
msgid "Griewank"
msgstr "Griewank"

#: ../../source/api/problems/numerical/test_functions/index.md:1
msgid "Test functions"
msgstr "测试函数"

#: ../../source/api/problems/numerical/test_functions/rastrigin.rst:3
msgid "Rastrigin"
msgstr "Rastrigin"

#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst:3
msgid "Rosenbrock"
msgstr "Rosenbrock"

#: ../../source/api/problems/numerical/test_functions/schwefel.rst:3
msgid "Schwefel"
msgstr "Schwefel"

#: evox.problems.numerical.schwefel.Schwefel:1 of
msgid "The Schwefel function The minimum is x = [420.9687462275036, ...]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/api/problems/numerical/test_functions/sphere.rst:3
msgid "Sphere"
msgstr "Sphere"

#: ../../source/api/problems/numerical/test_suits/cec2022.rst:3
msgid "CEC2022 Test Suit"
msgstr "CEC2022 测试套件"

#: evox.problems.numerical.cec2022_so.CEC2022TestSuit:1 of
msgid ""
"Instantiation format: problem_instance = CEC2022.create(1) i.e., "
"problem_instance = F1_CEC2022()"
msgstr ""
"实例化格式：problem_instance = CEC2022.create(1)，即 problem_instance = "
"F1_CEC2022()"

#: evox.problems.numerical.cec2022_so.F10_CEC2022:1
#: evox.problems.numerical.cec2022_so.F11_CEC2022:1
#: evox.problems.numerical.cec2022_so.F12_CEC2022:1
#: evox.problems.numerical.cec2022_so.F1_CEC2022:1
#: evox.problems.numerical.cec2022_so.F2_CEC2022:1
#: evox.problems.numerical.cec2022_so.F3_CEC2022:1
#: evox.problems.numerical.cec2022_so.F4_CEC2022:1
#: evox.problems.numerical.cec2022_so.F5_CEC2022:1
#: evox.problems.numerical.cec2022_so.F6_CEC2022:1
#: evox.problems.numerical.cec2022_so.F7_CEC2022:1
#: evox.problems.numerical.cec2022_so.F8_CEC2022:1
#: evox.problems.numerical.cec2022_so.F9_CEC2022:1 of
msgid "Test problems of CEC2022"
msgstr "CEC2022测试问题集"

#: ../../source/api/problems/numerical/test_suits/dtlz.rst:3
msgid "DTLZ Test Suit"
msgstr "DTLZ测试套件"

#: ../../source/api/problems/numerical/test_suits/index.md:1
msgid "Test suits"
msgstr "测试套件"

#: ../../source/api/problems/numerical/test_suits/lsmop.rst:3
msgid "LSMOP Test Suit"
msgstr "LSMOP测试套件"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:1
#: evox.problems.numerical.lsmop.LSMOP2.__init__:1
#: evox.problems.numerical.lsmop.LSMOP3.__init__:1
#: evox.problems.numerical.lsmop.LSMOP4.__init__:1
#: evox.problems.numerical.lsmop.LSMOP5.__init__:1
#: evox.problems.numerical.lsmop.LSMOP6.__init__:1
#: evox.problems.numerical.lsmop.LSMOP7.__init__:1
#: evox.problems.numerical.lsmop.LSMOP8.__init__:1
#: evox.problems.numerical.lsmop.LSMOP9.__init__:1 of
msgid "init"
msgstr "init"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:3
#: evox.problems.numerical.lsmop.LSMOP2.__init__:3
#: evox.problems.numerical.lsmop.LSMOP3.__init__:3
#: evox.problems.numerical.lsmop.LSMOP4.__init__:3
#: evox.problems.numerical.lsmop.LSMOP5.__init__:3
#: evox.problems.numerical.lsmop.LSMOP6.__init__:3
#: evox.problems.numerical.lsmop.LSMOP7.__init__:3
#: evox.problems.numerical.lsmop.LSMOP8.__init__:3
#: evox.problems.numerical.lsmop.LSMOP9.__init__:3 of
msgid "the dimension of decision space"
msgstr "决策空间的维度"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:4
#: evox.problems.numerical.lsmop.LSMOP2.__init__:4
#: evox.problems.numerical.lsmop.LSMOP3.__init__:4
#: evox.problems.numerical.lsmop.LSMOP4.__init__:4
#: evox.problems.numerical.lsmop.LSMOP5.__init__:4
#: evox.problems.numerical.lsmop.LSMOP6.__init__:4
#: evox.problems.numerical.lsmop.LSMOP7.__init__:4
#: evox.problems.numerical.lsmop.LSMOP8.__init__:4
#: evox.problems.numerical.lsmop.LSMOP9.__init__:4 of
msgid "the number of object"
msgstr "目标数量"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:5
#: evox.problems.numerical.lsmop.LSMOP2.__init__:5
#: evox.problems.numerical.lsmop.LSMOP3.__init__:5
#: evox.problems.numerical.lsmop.LSMOP4.__init__:5
#: evox.problems.numerical.lsmop.LSMOP5.__init__:5
#: evox.problems.numerical.lsmop.LSMOP6.__init__:5
#: evox.problems.numerical.lsmop.LSMOP7.__init__:5
#: evox.problems.numerical.lsmop.LSMOP8.__init__:5
#: evox.problems.numerical.lsmop.LSMOP9.__init__:5 of
msgid "ref_num * m is the Population of PF"
msgstr "ref_num * m 是 Pareto 前沿（PF）的种群数量"

#: ../../source/api/problems/numerical/test_suits/maf.rst:3
msgid "MaF Test Suit"
msgstr "MaF测试套件"

#: ../../source/api/problems/numerical/test_suits/zdt.rst:3
msgid "ZDT Test Suit"
msgstr "ZDT测试套件"

#: ../../source/api/workflows/index.rst:3
msgid "Workflows"
msgstr "工作流"

#: ../../source/api/workflows/standard.rst:3
msgid "Standard Workflow"
msgstr "标准工作流"

#: evox.workflows.std_workflow.StdWorkflow:1 of
msgid ""
"Experimental unified workflow, designed to provide unparallel performance"
" for EC workflow."
msgstr "实验中的统一workflow，设计目的是大幅提升EC的性能."

#: evox.workflows.std_workflow.StdWorkflow:4 of
msgid ""
"Provide automatic multi-device (e.g. multiple gpus) computation as well "
"as distributed computation using JAX's native components."
msgstr "提供自动多设备（例如，多个GPU）计算以及使用JAX的原生组件进行分布式计算。"

#: evox.workflows.std_workflow.StdWorkflow:7 of
#, fuzzy
msgid "Monitor is called using JAX's asynchronous host callback, thus closing"
msgstr "监视器是使用JAX的异步主机回调调用的，因此需要关闭监视器以等待回调完成。"

#: evox.workflows.std_workflow.StdWorkflow:10 of
msgid "The algorithm."
msgstr "算法。"

#: evox.workflows.std_workflow.StdWorkflow:12 of
msgid "The problem."
msgstr "问题。"

#: evox.workflows.std_workflow.StdWorkflow:14 of
msgid ""
"Optional monitor(s). Configure a single monitor or a list of monitors. "
"The monitors will be called in the order of the list."
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow:17 of
msgid ""
"The optimization direction, can be either \"min\" or \"max\" or a list of"
" \"min\"/\"max\" to specific the direction for each objective."
msgstr "优化方向，可以是\"min\"（最小化）或\"max\"（最大化），也可以是一个包含\"min\"/\"max\"的列表来指定每个目标的具体优化方向。"

#: evox.workflows.std_workflow.StdWorkflow:20 of
#, fuzzy
msgid ""
"Optional candidate solution transform function, usually used to decode "
"the candidate solutions into the format that can be understood by the "
"problem. Should be a list of functions, and the functions will be applied"
" in the order of the list. Each function should have the signature "
":code:`fn(solutions) -> solutions`, where solutions outputed by the EC "
"algorithm."
msgstr "可选的候选解变换函数，通常用于将种群解码为问题能够理解的格式。这应该是一个函数的列表，其中的函数将会被依次调用。"

#: evox.workflows.std_workflow.StdWorkflow:28 of
#, fuzzy
msgid ""
"Optional fitness transform function. usually used to apply fitness "
"shaping. Should be a list of functions, and the functions will be applied"
" in the order of the list. Each function should have the signature "
":code:`fn(fitness) -> fitness`, where fitness outputed by the problem."
msgstr "可选适应度变换函数，通常用于应用适应度整形。应当是一个列表的函数，列表中的函数将会被依次调用。"

#: evox.workflows.std_workflow.StdWorkflow:35 of
msgid "Whether jit the entire step function. Default to True"
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow:38 of
msgid ""
"Tell workflow whether the problem is external that cannot be jitted. "
"Default to False."
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow:41 of
msgid ""
"Whether to automatically call `execute_callbacks` on the state at the end"
" of each step. Default to True."
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow:44 of
msgid ""
"Whether to clear the monitor history at the beginning of the workflow. "
"Default to True."
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow:47 of
msgid ""
"Number of objectives. Used when external_problem=True. When the problem "
"cannot be jitted, JAX cannot infer the shape, and this field should be "
"manually set. the monitor is needed to wait for the callback to complete."
msgstr ""

#: ../../source/example/atari_pong.ipynb:10002
msgid "Solving Pong with EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/example/atari_pong.ipynb:10005
msgid ""
"Running this notebook requires installing evox, gymnasium, ale-py as well"
" as Pong's image. Due to copy right issues, we cannot distribute the "
"image here. Please follow the instructions [here](https://github.com"
"/Farama-Foundation/AutoROM) to install the image."
msgstr ""
"运行这个文档需要先安装 evox，gymnasium，ale-"
"py以及Pong这个游戏的镜像文件。由于版权问题，我们无法在这里给出游戏镜像文件。请按照这里[AutoROM](https://github.com"
"/Farama-Foundation/AutoROM)的教程安装游戏镜像。"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10002
msgid "Custom algorithm and problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10004
msgid ""
"This this notebook, we will show how to use the `Algorithm` and `Problem`"
" classes to create a custom algorithm and problem. We will use the one-"
"max problem as an example. The one-max problem is a simple problem where "
"the goal is to maximize the number of ones in a binary string. For "
"example, the string `01011` has a fitness of 3."
msgstr ""
"在这个文档中，我们将会展示如何通过`Algorithm`和`Problem`两个类来写一个自定义的算法和问题。我们将会以one-max问题为例"
"。one-max问题是一个非常简单的问题，这个问题的目标是最大化一个由0或1组成的字符串中1的数量。比如说字符串`01011`的适应度值是3。"

#: ../../source/example/gym_classic_control.ipynb:10002
msgid "Classic control with Gym"
msgstr "基于Gym的经典控制问题"

#: ../../source/example/gym_classic_control.ipynb:10004
msgid ""
"In this notebook, we will use the Gym to train an agent that solves "
"classic control problems."
msgstr "在这个文档里，我们会借助Gym来训练一个解决经典控制问题的智能体。"

#: ../../source/example/gym_classic_control.ipynb:70002
msgid "Now run the workflow. You may see warnings like"
msgstr "现在运行workflow。你可能会看到这样的警报"

#: ../../source/example/gym_classic_control.ipynb:70007
msgid ""
"This is expected behaivor, because we have a controller thread that "
"manages a group of Gym workers, and the controller thread does not use "
"GPU."
msgstr "这是预期的行为，因为我们有一个控制器线程来管理一组Gym工作线程，而控制器线程并不使用GPU。"

#: ../../source/example/gym_classic_control.ipynb:70010
msgid ""
"If the program stucks, you may want to check whether is `num_workers` is "
"larger than the number of available cores on your computer."
msgstr "如果程序卡住了，你可能需要检查 num_workers 设置的值是否大于你电脑上可用核心的数量。"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/meta_learning.ipynb:10002
#, fuzzy
msgid "Meta Optimization"
msgstr "数值优化"

#: ../../source/example/meta_learning.ipynb:10004
msgid ""
"In this notebook, we will use the meta optimization to optimize the "
"hyperparameters of PSO. We will have an outer loop that will optimize the"
" hyperparameters of PSO, and an inner loop that accepts the "
"hyperparameters and runs the PSO algorithm to optimize the Ackley "
"function, the result (cost on the ackley function) will be used as an "
"indicator of how good the hyperparameters are, and this information will "
"be feed to the outer loop to optimize the hyperparameters."
msgstr ""

#: ../../source/example/meta_learning.ipynb:40002
msgid "Setup the inner loop"
msgstr ""

#: ../../source/example/meta_learning.ipynb:40004
#, fuzzy
msgid ""
"The inner loop will be the PSO algorithm that will optimize the Ackley "
"function."
msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#: ../../source/example/pso_ackley.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/pso_ackley.ipynb:10004
msgid ""
"In this notebook, we will use the Particle Swarm Optimization (PSO) "
"algorithm to find the minimum of the Ackley function."
msgstr "在这个文档里，我们会使用粒子群算法来寻找Ackley测试问题的最小值。"

#: ../../source/example/tfds.ipynb:10002
msgid "Tensorflow datasets in EvoX"
msgstr ""

#: ../../source/example/tfds.ipynb:10004
msgid ""
"Use tensorflow-datasets to load machine learning dataset and train a "
"model in EvoX."
msgstr ""

#: ../../source/guide/developer/1-state.md:1
msgid "Working with state in EvoX"
msgstr "在EvoX中使用State"

#: ../../source/guide/developer/1-state.md:3
msgid "EvoX is designed around stateful computation."
msgstr "EvoX是围绕着有状态计算设计的。"

#: ../../source/guide/developer/1-state.md:5
msgid ""
"There are two most fundamental classes, namely {class}`Stateful "
"<evox.Stateful>` and {class}`State <evox.State>`."
msgstr ""
"有两个最基本的类，即 {class}`Stateful <evox.Stateful>` 和 {class}`State "
"<evox.State>`。"

#: ../../source/guide/developer/1-state.md:7
msgid ""
"All class that involves stateful computation are inherited from "
"`Stateful`. In EvoX, `Algorithm`, `Problem`, `Operator` and workflows are"
" all stateful."
msgstr ""
"所有涉及状态计算的类都继承自 "
"Stateful。在EvoX中，Algorithm（算法）、Problem（问题）、Operator（操作符）和Workflow（工作流）都是有状态的。"

#: ../../source/guide/developer/1-state.md:9
msgid "The idea behind the design"
msgstr "设计背后的想法"

#: ../../source/guide/developer/1-state.md:11
msgid "hierarchical state"
msgstr "分层状态"

#: ../../source/guide/developer/1-state.md:16
#, fuzzy
msgid ""
"Here we have five different objects, and notice that they have a "
"hierarchical structure. To work with such structures, at each level, we "
"must \"lift the state\" by managing the states of child components. So, "
"the state at the `workflow` level must contain the state of both "
"`algorithm` and `problem`, and since the state at the `algorithm` level "
"must contain the state of both operators, the state `workflow` level "
"actually needs to handle states from all 5 components."
msgstr ""
"这里我们有五个不同的对象，注意它们具有层次结构。为了处理这种结构，在每个层级我们必须通过管理子组件的状态来“提升状态”。因此，workflow "
"层级的状态必须包含 algorithm（算法）和 problem（问题）的状态，由于 algorithm 层级的状态必须包含所有操作符的状态，所以"
" workflow 层级的状态实际上需要处理来自所有5个组件的状态。"

#: ../../source/guide/developer/1-state.md:22
msgid ""
"However, it is frustrating to manage the hierarchy manually, and it is "
"not good for modular design. To solve this problem, we introduce "
"`Stateful` and `State`."
msgstr "然而，手动管理这种层次结构是令人沮丧的，而且不利于模块化设计。为了解决这个问题，我们引入了 Stateful 和 State。"

#: ../../source/guide/developer/1-state.md:25
#, fuzzy
msgid "An Overview of Stateful"
msgstr "关于状态的概述"

#: ../../source/guide/developer/1-state.md:27
msgid ""
"In a `Stateful` class, all immutable data are initialized in `__init__`, "
"or with dataclass, the initial mutable state is generated in `setup`."
msgstr "在 Stateful 类中，所有不可变数据都在 __init__ 中初始化，可变的状态在 setup 中初始化。"

#: ../../source/guide/developer/1-state.md:46
msgid "Notice that all stateful functions should have the following signature:"
msgstr "注意所有的有状态函数需要有以下函数签名："

#: ../../source/guide/developer/1-state.md:50
msgid "which is a common pattern in stateful computation."
msgstr "这是状态计算中常见的模式。"

#: ../../source/guide/developer/1-state.md:52
msgid ""
"Stateful defines the standard for stateful modules in EvoX. All other "
"classes, such as `Algorithm`, `Problem`, and `Workflow`, are inherited "
"from `Stateful`. Then Stateful will provide a `init` method, which we "
"will discuss later."
msgstr ""

#: ../../source/guide/developer/1-state.md:56
msgid "An overview of State"
msgstr "关于状态的概述"

#: ../../source/guide/developer/1-state.md:58
msgid ""
"In EvoX `State` represents a tree of states, which stores the state of "
"the current object and all child objects."
msgstr "在EvoX中，“State”代表一个状态树，它存储当前对象和所有子对象的状态。"

#: ../../source/guide/developer/1-state.md:60
msgid "The structure of `State` is roughly like this:"
msgstr "`State` 的结构大概如如下所示："

#: ../../source/guide/developer/1-state.md:68
msgid ""
"Where `self_state` stores the state of the current object (the one "
"returned by `setup`), and `child_states` stores the states of all child "
"objects. Besides normal dicts as `self_state`, we also support the use of"
" `dataclass` to define the state of the object."
msgstr ""
"其中，`self_state` 存储当前对象的状态（由 setup 返回的对象），而 child_states 存储所有子对象的状态。除了字典作为"
" self_state 外，我们还支持使用数据类（dataclass）来定义对象的状态。"

#: ../../source/guide/developer/1-state.md:71
msgid "Combined together"
msgstr "结合一起"

#: ../../source/guide/developer/1-state.md:73
msgid "Initialization"
msgstr "初始化"

#: ../../source/guide/developer/1-state.md:75
msgid ""
"To initialize a hierarchy of Stateful objects, and initialize the state "
"of each object, you could write code like this. You can to call `init` "
"method of the top module. `init` will recursively call the `setup` method"
" of each module, and construct the complete state."
msgstr ""

#: ../../source/guide/developer/1-state.md:80
#, fuzzy
msgid ""
"When combined together, they will automatically go 1 level down in the "
"tree of states, and merge the subtree back to the current level."
msgstr "当它们组合在一起时，将自动下降到状态树的下一层，并将子树合并回当前层。"

#: ../../source/guide/developer/1-state.md:84
msgid "So you could write code like this."
msgstr "所以你可以这样写代码。"

#: ../../source/guide/developer/1-state.md:95
msgid ""
"Notice that, when calling the method `step`, `state` is the state of the "
"workflow, but when calling `self.algorithm.ask`, `state` behaves like the"
" state of the algorithm, and after the call, the state of the algorithm "
"is automatically merged back into the state of the workflow."
msgstr ""
"请注意，当调用 step 方法时，state 是工作流的状态，但是当调用 self.algorithm.ask 时，state "
"的行为就像是算法的状态，调用之后，算法的状态会自动合并回工作流的状态。"

#: ../../source/guide/developer/2-jit-able.md:1
msgid "Jit-able components"
msgstr "Jit-able 组件"

#: ../../source/guide/developer/2-jit-able.md:3
msgid "A common pitfall in jit"
msgstr "jit中常见的一个陷阱"

#: ../../source/guide/developer/2-jit-able.md:5
msgid ""
"In JAX, it's hard to jump out of a jit-compiled function, meaning if you "
"jit-compile one function, then all other functions used within this "
"function must also be jit-compiled."
msgstr ""
"在 JAX 中，跳出一个 JIT 编译的函数是困难的，这意味着如果你 JIT 编译了一个函数，那么在这个函数内部使用的所有其他函数也必须被 JIT"
" 编译。"

#: ../../source/guide/developer/2-jit-able.md:8
msgid "For example, the following code will result in a compilation error."
msgstr "例如，下面的代码将导致编译错误"

#: ../../source/guide/developer/2-jit-able.md:19
msgid ""
"Even though `bar` is not marked with `jax.jit`, it is still compiled as "
"`foo` calls `bar`. And since `bar` uses the dynamic index, which is not "
"compatible with `jax.jit`, an error will occur."
msgstr ""
"尽管 bar 没有被标记为 jax.jit，但由于 foo 调用了 bar，它仍然会被编译。由于 bar 使用了动态索引，这与 jax.jit "
"不兼容，因此会发生错误。"

#: ../../source/guide/developer/2-jit-able.md:22
msgid "Solution"
msgstr "解决方案"

#: ../../source/guide/developer/2-jit-able.md:24
msgid ""
"jit-compile low-level components, and give high-level components more "
"freedom."
msgstr ""

#: ../../source/guide/developer/2-jit-able.md:25
msgid ""
"Use [`host "
"callback`](https://jax.readthedocs.io/en/latest/notebooks/external_callbacks.html)"
" to call a function on CPU in a jit context."
msgstr ""

#: ../../source/guide/developer/2-jit-able.md:27
msgid ""
"In EvoX, we almost guarantee that all low-level components are jit-"
"compiled (all operators), and high-level components (`Workflow`) can have"
" both jit-compiled variants (e.g. {doc}`StdWorkflow "
"</api/workflows/standard>`)."
msgstr ""

#: ../../source/guide/developer/2-jit-able.md:29
msgid ""
"Please be aware that using callbacks to jump out of the jit context is "
"not free. Data needs to be transferred between CPU and GPU, which can be "
"an overhead."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:7
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:9
msgid ""
"In this chapter, we will introduce how to implement your own algorithm in"
" EvoX."
msgstr "在本章中，我们将介绍如何在 EvoX 中实现您自己的算法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:11
msgid "The Algorithm Class"
msgstr "算法类"

#: ../../source/guide/developer/3-custom-alg-pro.md:13
msgid ""
"The {class}`Algorithm <evox.Algorithm>` class is inherited from "
"{class}`Stateful <evox.Stateful>`. Besides the things in `Stateful`, you "
"should also implement an `ask` and a `tell` method. In total, there are "
"four methods one needs to implement."
msgstr ""
"{class}`Algorithm <evox.Algorithm>` 类继承自 {class}`Stateful "
"<evox.Stateful>`。除了 Stateful 中的内容外，您还应该实现一个 ask 方法和一个 tell "
"方法。总共有四个方法需要实现。"

#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:88
msgid "Method"
msgstr "方法"

#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:88
msgid "Signature"
msgstr "签名"

#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:88
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "\\_\\_init\\_\\_"
msgstr "\\_\\_init\\_\\_"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "{python}`(self, ...)`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize hyperparameters that are fixed though out the optimization "
"process, for example, the `population size`."
msgstr "初始化在整个优化过程中固定的超参数，例如，`population size`。"

#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:92
msgid "setup"
msgstr "设置"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "{python}`(self, RRNGKey) -> State`"
msgstr "{python}`(self, RRNGKey) -> State`"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "Initialize mutable state, for example the `momentum`."
msgstr "初始化可变状态，例如`momentum`。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "ask"
msgstr "ask"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "{python}`(self, State) -> Array, State`"
msgstr "{python}`(self, State) -> Array, State`"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "Gives a candidate population for evaluation."
msgstr "给出用于评估的候选种群。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "tell"
msgstr "tell"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "{python}`(self, State, Array) -> State`"
msgstr "{python}`(self, State, Array) -> State`"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the candidate population and update the "
"algorithm's state."
msgstr "接收候选种群的适应度并更新算法的状态。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "init_ask (Optional)"
msgstr "init_ask (可选的)"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Gives initial population for evaluation. The population can have "
"different shape than `ask`."
msgstr "提供用于评估的初始种群。种群的形状可以与`ask`不同。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "init_tell (Optional)"
msgstr "init_tell (可选的 )"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the initial population and update the algorithm's"
" state."
msgstr "接收初始种群的适应度并更新算法的状态。"

#: ../../source/guide/developer/3-custom-alg-pro.md:26
#: ../../source/guide/developer/3-custom-alg-pro.md:81
msgid "Migrate from traditional EC libraries"
msgstr "迁移自传统的EC库"

#: ../../source/guide/developer/3-custom-alg-pro.md:28
msgid ""
"In a traditional EC library, algorithms usually call the objective "
"function internally, which gives the following layout"
msgstr "在传统的EC库中，算法通常在内部调用目标函数，其布局如下"

#: ../../source/guide/developer/3-custom-alg-pro.md:36
msgid "But in EvoX, we have a flat layout"
msgstr "但在 EvoX 中，我们采用了扁平布局"

#: ../../source/guide/developer/3-custom-alg-pro.md:42
msgid "Here is a pseudocode of a genetic algorithm."
msgstr "这是一个遗传算法的伪代码。"

#: ../../source/guide/developer/3-custom-alg-pro.md:57
msgid "And here is what each part of the algorithm corresponds to in EvoX."
msgstr "这里是算法的每个部分在 EvoX 中对应的内容。"

#: ../../source/guide/developer/3-custom-alg-pro.md:77
msgid "The Problem Class"
msgstr "问题类"

#: ../../source/guide/developer/3-custom-alg-pro.md:79
#, fuzzy
msgid ""
"The Problem class is quite simple, beside `__init__` and `setup`, the "
"only required method is `evaluate``."
msgstr "`Problem` 类相当简单，除了 `__init__` 和 `setup`，唯一必需的方法是 `evaluate`。"

#: ../../source/guide/developer/3-custom-alg-pro.md:83
msgid ""
"There is one thing to notice here, `evaluate` is a stateful function, "
"meaning it should accept a state and return a new state. So, if you are "
"working with numerical benchmark functions, which don't need to be "
"stateful, you can simply ignore the state, but remember that you still "
"have to use this stateful interface."
msgstr ""
"这里有一点需要注意，`evaluate` "
"是一个有状态的函数，这意味着它应该接受一个状态并返回一个新状态。所以，如果你正在处理不需要有状态的数值基准函数，你可以简单地忽略状态，但请记住，你仍然需要使用这个有状态的接口。"

#: ../../source/guide/developer/3-custom-alg-pro.md:90
msgid "__init__"
msgstr "__init__"

#: ../../source/guide/developer/3-custom-alg-pro.md:90
msgid ":python:`(self, ...)`"
msgstr ":python:`(self, ...)`"

#: ../../source/guide/developer/3-custom-alg-pro.md:90
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/developer/3-custom-alg-pro.md:92
msgid ":python:`(self, RRNGKey) -> State`"
msgstr ":python:`(self, RRNGKey) -> State`"

#: ../../source/guide/developer/3-custom-alg-pro.md:92
msgid "Initialize mutable state of this problem."
msgstr "初始化这个问题的可变状态。"

#: ../../source/guide/developer/3-custom-alg-pro.md:94
msgid "evaluate"
msgstr "评估"

#: ../../source/guide/developer/3-custom-alg-pro.md:94
msgid ":python:`(self, State, Array) -> Array, State`"
msgstr ":python:`(self, State, Array) -> Array, State`"

#: ../../source/guide/developer/3-custom-alg-pro.md:94
msgid "Evaluate the fitness of the given candidate solution."
msgstr "评估给定候选解的适应度。"

#: ../../source/guide/developer/3-custom-alg-pro.md:98
msgid "More on the problem's state"
msgstr "关于问题的状态的更多信息"

#: ../../source/guide/developer/3-custom-alg-pro.md:100
msgid ""
"If you still wonder what the problem's state actually does, here are the "
"explanations."
msgstr "如果您仍然想知道问题的状态实际上是做什么的，以下是解释。"

#: ../../source/guide/developer/3-custom-alg-pro.md:102
msgid ""
"Unlike numerical benchmark functions, real-life problems are more complex"
" and may require stateful computations. Here are some examples:"
msgstr "与数值基准函数不同，现实生活中的问题更加复杂，可能需要有状态的计算。以下是一些例子："

#: ../../source/guide/developer/3-custom-alg-pro.md:105
msgid ""
"When dealing with ANN training, we often have the training, validation "
"and testing phases. This implies that the same solution could have "
"different fitness values during different phases. So clearly, we can't "
"model the `evaluate` as a stateless pure function anymore. To implement "
"this mechanism, simply put a value in the state to indicate the phase."
msgstr "在处理人工神经网络(ANN)训练时，我们通常有训练、验证和测试阶段。这意味着同一个解决方案在不同阶段可能有不同的适应度值。因此，显然我们不能再将`evaluate`建模为一个无状态的纯函数。要实现这种机制，只需在状态中放置一个值来指示阶段。"

#: ../../source/guide/developer/3-custom-alg-pro.md:109
msgid ""
"Virtual batch norm is an effective trick especially when dealing with RL "
"tasks. To implement this mechanism, the problem must be stateful, as the "
"problem has to remember the initial batch norm parameters during the "
"first run."
msgstr "虚拟批量归一化是一个有效的技巧，特别是在处理强化学习(RL)任务时。要实现这种机制，问题必须是有状态的，因为问题需要记住第一次运行时的初始批量归一化参数。"

#: ../../source/guide/developer/3-custom-alg-pro.md:113
msgid "Example"
msgstr "样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:115
msgid ""
"Here we give an example of implementing the OneMax problem, along with a "
"genetic algorithm that solves this problem. The problem itself is "
"straightforward, the fitness is defined as the sum of every digit in a "
"fixed-length bitstring. For example, \"100111\" gives 4 and \"000101\" "
"gives 2."
msgstr ""
"这里我们给出了一个实现 OneMax "
"问题的例子，以及解决这个问题的遗传算法。这个问题本身很直接，适应度定义为固定长度比特串中每个数字的总和。例如，\"100111\" 的适应度是 "
"4，而 \"000101\" 的适应度是 2。"

#: ../../source/guide/developer/3-custom-alg-pro.md:119
msgid ""
"Let's start with implementing the OneMax problem. In JAX a bitstring can "
"be easily represented with a tensor of type bool."
msgstr "让我们从实现 OneMax 问题开始。在 JAX 中，比特串可以很容易地用布尔类型的张量来表示。"

#: ../../source/guide/developer/3-custom-alg-pro.md:144
msgid ""
"Then we implement a genetic algorithm that uses bitflip mutation and one-"
"point crossover."
msgstr "然后我们实现了一个遗传算法，使用位翻转变异和单点交叉。"

#: ../../source/guide/developer/3-custom-alg-pro.md:204
msgid "Now, you can assemble a workflow and run it."
msgstr "现在你可以组合出一个workflow并运行。"

#: ../../source/guide/developer/4-doc.md:1
msgid "Write & Build the Documentation"
msgstr "编写并构建文档"

#: ../../source/guide/developer/4-doc.md:3
msgid "This documentation is about how to write and build EvoX's documentation."
msgstr "这个文档是关于编写和构建EvoX的文档的。"

#: ../../source/guide/developer/4-doc.md:5
msgid "Documentation structure"
msgstr "文档的结构"

#: ../../source/guide/developer/4-doc.md:7
msgid ""
"There are mainly two types of documentation in EvoX: **Guide** and "
"**API**. **Guide** is for users who want to learn how to use EvoX, mainly"
" written in jupyter notebook format. **API** is for users/developers who "
"want to know the details of EvoX's code, mainly written as docstrings in "
"the code."
msgstr ""
"在 EvoX 中主要有两种类型的文档：教程（Guide）和API。教程适用于想要学习如何使用 EvoX 的用户，主要以 Jupyter "
"Notebook 的格式编写。API适用于想要了解 EvoX 代码细节的用户/开发者，主要作为代码中的文档字符串（docstring）编写。"

#: ../../source/guide/developer/4-doc.md:11
msgid "Multi-language support"
msgstr "多语言支持"

#: ../../source/guide/developer/4-doc.md:13
msgid ""
"EvoX's documentation supports multiple languages. Currently, we support "
"English and Chinese."
msgstr "EvoX的文档支持多种语言。目前我们支持英语和中文。"

#: ../../source/guide/developer/4-doc.md:15
msgid "Build the documentation in another language"
msgstr ""

#: ../../source/guide/developer/4-doc.md:17
msgid "You will need to install `sphinx-intl`."
msgstr ""

#: ../../source/guide/developer/4-doc.md:26
msgid "Translate the documentation"
msgstr "翻译文档"

#: ../../source/guide/developer/4-doc.md:28
msgid ""
"The translation is hosted on "
"[Weblate](https://hosted.weblate.org/projects/evox/evox/). You can "
"contribute to the translation there."
msgstr "翻译的入口在[Weblate](https://hosted.weblate.org/projects/evox/evox/)。你可以在这里帮助我们翻译文档。"

#: ../../source/guide/developer/index.md:1
msgid "Developer Guide"
msgstr "开发者指引"

#: ../../source/guide/install/index.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install/install.md:1
msgid "EvoX Installation Guide"
msgstr "EvoX安装教程"

#: ../../source/guide/install/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install/install.md:5
msgid "EvoX is available at Pypi and can be installed via:"
msgstr "EvoX 可以在 PyPI 上找到，可以通过以下方式安装："

#: ../../source/guide/install/install.md:11
msgid "To install EvoX with optional dependencies:"
msgstr "要安装带有可选依赖项的 EvoX："

#: ../../source/guide/install/install.md:17
msgid ""
"available features are `gymnasium`, `neuroevolution`, `envpool`, "
"`distributed`, and `full` which concludes all features. For example, to "
"install EvoX with all features, do:"
msgstr ""
"EvoX 提供多种可选特性，包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed`和`full`（包含所有特性）。例如，要安装包含所有特性的"
" EvoX，您可以使用以下命令："

#: ../../source/guide/install/install.md:24
msgid "Install JAX with accelerator support"
msgstr "安装支持GPU加速的JAX"

#: ../../source/guide/install/install.md:26
msgid ""
"`EvoX` relies on `JAX` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`EvoX`依赖于`JAX`来提供硬件加速的能力。这些Python包的整体架构如下："

#: ../../source/guide/install/install.md:43
msgid ""
"`JAX` itself is pure Python, and `jaxlib` provides the C/C++ code. To "
"utilize JAX's hardware acceleration ability, make sure to install the "
"correct `jaxlib` version."
msgstr ""
"`JAX`本身是纯 Python 库，而`jaxlib`则提供了支持加速器的 C/C++ "
"代码。要充分利用JAX的硬件加速能力，必须确保安装了正确的`jaxlib`版本。"

#: ../../source/guide/install/install.md:46
msgid ""
"To summarize, you will need the follow 3 things to enable accelerator "
"support:"
msgstr "总结一下，您需要以下3个东西来启用加速器支持："

#: ../../source/guide/install/install.md:47
msgid "GPU driver"
msgstr "GPU驱动"

#: ../../source/guide/install/install.md:48
msgid "CUDA libraries"
msgstr "CUDA库"

#: ../../source/guide/install/install.md:49
msgid "The correct jaxlib version (the one with accelerator support)."
msgstr "正确的jaxlib版本（有加速器支持的版本）。"

#: ../../source/guide/install/install.md:52
msgid ""
"For more information, e.g. other platforms, please check out JAX's "
"[official installation guide](https://github.com/google/jax/?tab=readme-"
"ov-file#installation)."
msgstr ""
"想要了解更多信息，比如在其他平台上安装的教程，请查阅JAX的[官方安装指南](https://github.com/google/jax/?tab"
"=readme-ov-file#installation)。"

#: ../../source/guide/install/install.md:55
msgid "CPU only"
msgstr "纯CPU版"

#: ../../source/guide/install/install.md:61
msgid "CUDA (NVIDIA GPU)"
msgstr "CUDA版 （NVIDIA GPU）"

#: ../../source/guide/install/install.md:63
msgid ""
"To enable CUDA acceleration, please ensure that the following components "
"are installed in a compatible manner:"
msgstr "为了能正确启用 CUDA 加速，请确保以下组件以能够兼容的方式安装："

#: ../../source/guide/install/install.md:90
msgid "If your using any virtualization technology, like WSL, docker."
msgstr "如果你正在使用任何虚拟化技术，例如 WSL 或 Docker。"

#: ../../source/guide/install/install.md:91
msgid ""
"**kernel space components**: should be installed on your host system. For"
" example, if you are using WSL with Windows, then the driver should be "
"installed on Windows, not inside WSL. If you are using container (e.g. "
"docker), then the driver should be installed on your host OS (outside "
"docker)."
msgstr ""
"**内核空间组件**：应安装在您的宿主机系统上。例如，如果您在 Windows 上使用 WSL，则应在 Windows 上安装驱动程序，而不是在 "
"WSL 内部安装。如果您使用容器（例如 Docker），则应在您的宿主机操作系统（Docker 外部）上安装驱动程序。"

#: ../../source/guide/install/install.md:94
msgid "**user space components**: need to be installed inside WSL or docker."
msgstr "**用户空间组件**：需要安装在 WSL 或 Docker 内部。"

#: ../../source/guide/install/install.md:97
msgid "Install NVIDIA's proprietary driver"
msgstr "安装 NVIDIA 的闭源驱动程序"

#: ../../source/guide/install/install.md:99
msgid ""
"Please notice that this step requires administrative privileges and a "
"reboot. So, if you are using a shared server, please contact the server's"
" administrator for support."
msgstr "请注意，这一步会需要管理员权限。所以，如果你在使用一个共享的服务器，请联系服务器的管理员来寻求帮助。"

#: ../../source/guide/install/install.md:102
msgid "Windows WSL 2"
msgstr "Windows WSL 2"

#: ../../source/guide/install/install.md:104
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us), and "
"install it."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install/install.md:107
#: ../../source/guide/install/windows_gpu.md:14
msgid ""
"You must **NOT** install any NVIDIA GPU Linux driver within WSL 2. GPU "
"driver this a kernel space program, so it should be installed on the "
"Windows side."
msgstr ""
"请**不要**在 WSL 2 内部安装任何 NVIDIA GPU Linux 驱动程序。GPU 驱动程序属于内核空间程序，应安装在 Windows"
" 主机系统上。"

#: ../../source/guide/install/install.md:112
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda"
"/wsl-user-guide/index.html)"

#: ../../source/guide/install/install.md:115
msgid "GNU/Linux"
msgstr "GNU/Linux"

#: ../../source/guide/install/install.md:118
msgid ""
"If you are on GNU/Linux, I strongly recommend to install the driver via "
"the package manager of your Linux distribution. Please do **NOT** install"
" the driver from NVIDIA's website."
msgstr ""
"如果您使用 GNU/Linux 系统，我强烈建议您通过您的 Linux 发行版的包管理器（比如apt，pacman）来安装驱动程序，而不是从 "
"NVIDIA 的网站下载安装包。"

#: ../../source/guide/install/install.md:124
msgid ""
"Only NVIDIA's proprietary driver works with CUDA, open-source drivers "
"like Nouveau do not."
msgstr "仅有NVIDIA的闭源驱动支持CUDA，像Nouveau这样的开源驱动则不支持。"

#: ../../source/guide/install/install.md:127
msgid ""
"The detailed installation guide depends on your operating system, for "
"example"
msgstr "具体的安装方法取决于您的操作系统，例如"

#: ../../source/guide/install/install.md:129
#: ../../source/guide/install/install.md:160
msgid "ArchLinux"
msgstr "ArchLinux"

#: ../../source/guide/install/install.md:133
#: ../../source/guide/install/install.md:164
msgid "Ubuntu 22.04"
msgstr ""

#: ../../source/guide/install/install.md:137
msgid ""
"NixOS first enable unfree software, and then add the following to your "
"configuration."
msgstr "NixOS首先启用非自由软件，然后添加以下配置。"

#: ../../source/guide/install/install.md:143
msgid "After installing the driver, please reboot."
msgstr "安装完驱动后，请重启电脑。"

#: ../../source/guide/install/install.md:146
msgid "Cluster (e.g. slurm, k8s)"
msgstr "集群（如slurm, k8s）"

#: ../../source/guide/install/install.md:148
msgid ""
"If the latest driver has already been installed in the cluster, please go"
" ahead and skip this section."
msgstr "如果集群中已经安装了最新的驱动，请跳过这个部分并继续。"

#: ../../source/guide/install/install.md:150
msgid ""
"Otherwise, please contact the administrator of the cluster to upgrade the"
" GPU driver version. It is important to note that the driver must be "
"installed on the host system, rendering any effort within the container "
"(e.g. docker, singularity) meaningless. Thus only the administrator can "
"solve this problem."
msgstr "如果没有，请联系集群的管理员来升级GPU驱动版本。需要注意的是，驱动必须安装在宿主系统上，在容器内进行的任何尝试都是无效的。因此只有管理员才能解决这个问题。"

#: ../../source/guide/install/install.md:155
msgid "Install CUDA libraries"
msgstr "安装CUDA库"

#: ../../source/guide/install/install.md:157
msgid ""
"CUDA libraries are user space libraries, so you don't need to reboot "
"after installation. Again, it depends on your operating system, for "
"example"
msgstr "CUDA 库是安装在用户空间的，所以在安装后您不需要重启。 具体的安装方式取决于您的操作系统，例如"

#: ../../source/guide/install/install.md:170
msgid "Now, you can check your do"
msgstr "现在您可以检查您做的"

#: ../../source/guide/install/install.md:174
msgid ""
"to see if your GPU is recognized by the driver. If you see something like"
" this, then you are good to go."
msgstr "查看您的GPU是否被驱动识别。如果您看到类似的信息，那么您可以开始了。"

#: ../../source/guide/install/install.md:198
msgid "Then check your jaxlib version by"
msgstr "之后通过其检查您的jaxlib版本"

#: ../../source/guide/install/install.md:204
msgid ""
"Please make sure you jaxlib's CUDA version is smaller or equal to the "
"CUDA version of this host."
msgstr "请确保您的`jaxlib-cuda`的版本小于或等于机器上的CUDA版本。"

#: ../../source/guide/install/install.md:217
msgid ""
"For example, we have `0.4.18+cuda11.cudnn86` installed, and 11 < 12.2 "
"(displayed by `nvidia-smi`). So we are good to go."
msgstr ""
"例如，我们安装了0.4.18+cuda11.cudnn86版本，且nvidia-"
"smi显示的CUDA版本是11，小于12.2。因此，我们可以开始使用了。"

#: ../../source/guide/install/install.md:220
msgid ""
"Since installing `jax[cuda12]` will usually install the jaxlib compiled "
"with the latest CUDA version. Even if you have CUDA 12, your CUDA version"
" might still be lower than the version of that jaxlib requires. In this "
"case, try to install `jax[cuda11]`."
msgstr ""
"由于安装 jax[cuda12] 通常会安装到使用最新 CUDA 版本编译的 jaxlib，即使您有 CUDA 12，您的 CUDA "
"版本也可能低于 jaxlib 要求的版本（小版本号不够）。 在这种情况下，请尝试安装 jax[cuda11]。"

#: ../../source/guide/install/install.md:225
msgid "AMD GPU (ROCM)"
msgstr ""

#: ../../source/guide/install/install.md:227
msgid ""
"Despite being considered experimental, installing AMD GPUs for ROCm is "
"surprisingly straightforward thanks to their open-source drivers. "
"However, currently only a limited number of GPUs are supported, notably "
"the Radeon RX 7900XTX and Radeon PRO W7900 for consumer-grade GPUs. Note "
"that Windows is not currently supported."
msgstr ""
"虽然这目前是实验性的支持，由于AMD GPU的驱动是开源的，所以安装AMD "
"GPU的驱动其实很简单。不过，需要注意的是，目前只有一小部分GPU是支持的，其中消费者级的GPU中主要是Radeon RX "
"7900XTX和Radeon PRO W7900。请注意这目前还不支持Windows。"

#: ../../source/guide/install/install.md:229
msgid "Install GPU driver"
msgstr "安装GPU驱动"

#: ../../source/guide/install/install.md:231
msgid ""
"Since the AMD driver is open-source, installation is simplified: simply "
"install mesa through your Linux distribution's package manager. In many "
"cases, the driver may already be pre-installed."
msgstr "由于AMD的驱动是开源的，所以安装非常简单：只需要通过您的Linux发行版上的包管理器安装mesa这个包。大部分情况下，这个驱动已经被预先安装好了。"

#: ../../source/guide/install/install.md:233
msgid "To verify that the driver is installed, run the following command:"
msgstr "通过以下命令来检查驱动是否安装好了："

#: ../../source/guide/install/install.md:239
msgid "And you should see `amdgpu` in the output."
msgstr "然后你应该能在输出中看到`amdgpu`。"

#: ../../source/guide/install/install.md:241
msgid "Install ROCm"
msgstr "安装ROCm"

#: ../../source/guide/install/install.md:243
msgid ""
"The latest version of ROCm (v5.7.1 or later) may not be available in your"
" Linux distribution's package manager. Therefore, using a containerized "
"environment is the easiest way to get started."
msgstr "由于新版本的ROCm库很可能不在你的Linux发行版的仓库中。所以我们推荐使用容器，这是最简单的方式。"

#: ../../source/guide/install/install.md:249
msgid ""
"Please visit [Docker Hub](https://hub.docker.com/r/rocm/jax) for further "
"instructions."
msgstr "更多的信息，请访问[Docker Hub](https://hub.docker.com/r/rocm/jax)。"

#: ../../source/guide/install/install.md:251
msgid "Verify your installation"
msgstr "验证安装是否正确"

#: ../../source/guide/install/install.md:253
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install/install.md:261
msgid "Here are some possible output:"
msgstr "这里是几种可能的输出结果："

#: ../../source/guide/install/install.md
msgid "Correct"
msgstr "正确"

#: ../../source/guide/install/install.md
msgid "EvoX not installed"
msgstr "未安装EvoX"

#: ../../source/guide/install/install.md
msgid "Wrong jaxlib version"
msgstr "jaxlib版本错误"

#: ../../source/guide/install/install.md
msgid "Wrong driver/library"
msgstr "驱动或库版本错误"

#: ../../source/guide/install/python.md:1
msgid "Python Installation Guide"
msgstr "Python安装教程"

#: ../../source/guide/install/python.md:3
msgid ""
"EvoX is written in Python, so you will need to have Python installed on "
"your system. EvoX support Python 3.9 and above, and we recommend using "
"the latest version of Python."
msgstr ""
"EvoX是用Python写的，所以你需要先在你的系统上安装Python。EvoX支持Python "
"3.9及以上，同时我们推荐使用最新版的Python。"

#: ../../source/guide/install/python.md:6
msgid "Windows Version"
msgstr "Windows 版本"

#: ../../source/guide/install/python.md:8
msgid ""
"Go to [Download Python](https://www.python.org/downloads/) and download "
"the latest version of Python."
msgstr "访问[Download Python](https://www.python.org/downloads/) 来下载最新版的Python。"

#: ../../source/guide/install/python.md:11
msgid ""
"Make sure to check the box that says \"Add Python to PATH\" during the "
"installation process."
msgstr "请确保在安装的过程中勾选\"Add Python to PATH\"这个选项。"

#: ../../source/guide/install/python.md:14
msgid "Linux Version"
msgstr "Linux 版本"

#: ../../source/guide/install/python.md:16
msgid ""
"Different Linux distributions have different ways to install Python. It "
"depends on the package manager of your distribution. Here are some "
"examples:"
msgstr "不同的Linux发行版有不同的安装Python的方式。这取决于发行版所用的包管理器。这里有些例子："

#: ../../source/guide/install/python.md:19
msgid "Debian/Ubuntu: `apt`"
msgstr ""

#: ../../source/guide/install/python.md:20
msgid "Archlinux: `pacman`"
msgstr ""

#: ../../source/guide/install/python.md:21
msgid "Fedora: `dnf`"
msgstr ""

#: ../../source/guide/install/video_guide.md:1
msgid "Video Installation Guide"
msgstr "视频安装教程"

#: ../../source/guide/install/video_guide.md:3
msgid "🎥 [EvoX Installation Guide (Linux)](https://youtu.be/fa2s1Jl-Fy0)"
msgstr "🎥 [EvoX 安装指南 (Linux)](https://www.bilibili.com/video/BV1Zt421c7GN)"

#: ../../source/guide/install/video_guide.md:5
msgid "🎥 [EvoX Installation Guide (Windows)](https://youtu.be/7f8Uz1rqvn8)"
msgstr "🎥 [EvoX 安装指南 (Windows)]( https://www.bilibili.com/video/BV1Bb421h7bG)"

#: ../../source/guide/install/windows_gpu.md:1
msgid "Windows with GPU acceleration"
msgstr "Windows上GPU加速"

#: ../../source/guide/install/windows_gpu.md:3
msgid ""
"Currently the easiest way to install JAX with GPU acceleration on Windows"
" is to use the `WSL 2`."
msgstr "目前最简单的在Windows上安装GPU加速版的JAX的方式是使用`WSL 2`。"

#: ../../source/guide/install/windows_gpu.md:5
msgid "Install WSL 2"
msgstr "安装 WSL 2"

#: ../../source/guide/install/windows_gpu.md:7
msgid ""
"Windows has a detailed guide on how to install WSL 2 "
"[here](https://learn.microsoft.com/en-us/windows/wsl/install)"
msgstr ""
"Windows有一个详细的安装WSL 2的教程在[这里](https://learn.microsoft.com/en-"
"us/windows/wsl/install)"

#: ../../source/guide/install/windows_gpu.md:9
msgid ""
"The simple way to install a Linux distribution is to use the `Windows "
"Store` and search for the name of the distribution (e.g. ubuntu, debian) "
"and click the install button."
msgstr "简单的安装Linux发行版的方式是去Windows商店，然后搜索发行版的名称并点击安装。"

#: ../../source/guide/install/windows_gpu.md:11
msgid "Install NVIDIA driver"
msgstr "安装英伟达驱动"

#: ../../source/guide/install/windows_gpu.md:18
msgid ""
"Go to [here](https://www.nvidia.com/Download/index.aspx), to download the"
" latest NVIDIA Windows GPU Driver, and install it."
msgstr ""
"访问[这里](https://www.nvidia.com/Download/index.aspx)，下载最新的英伟达Windows "
"GPU驱动，并安装。"

#: ../../source/guide/user/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/user/1-start.ipynb:10004
msgid "In this notebook, we will guide you through the basic steps of using EvoX."
msgstr "在这个文档中，我们将介绍EvoX的基本使用方法。"

#: ../../source/guide/user/1-start.ipynb:40002
msgid "Create an algorithm and a problem"
msgstr "创建一个算法和一个问题"

#: ../../source/guide/user/1-start.ipynb:50002
msgid "To demostrate, we will create a PSO algorithm and an Ackley function."
msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#: ../../source/guide/user/1-start.ipynb:50004
msgid ""
"For more detailed list, please refer to our API documentation. [List of "
"Algorithms](https://evox.readthedocs.io/en/latest/api/algorithms/index.html)"
" and [List of "
"Problems](https://evox.readthedocs.io/en/latest/api/problems/index.html)."
msgstr ""
"有关更详细的列表，请参阅我们的 API "
"文档。[算法列表](https://evox.readthedocs.io/en/latest/api/algorithms/index.html)"
" 和 [问题列表](https://evox.readthedocs.io/en/latest/api/problems/index.html)。"

#: ../../source/guide/user/1-start.ipynb:70002
msgid ""
"Now we want to run the algorithm against the problem. To accomplish this,"
" we need to create a `workflow` which represents the overall process of "
"evolutionary computation."
msgstr "现在我们想要运行针对问题的算法。为了实现这一点，我们需要创建一个代表进化计算整体过程的`workflow`。"

#: ../../source/guide/user/1-start.ipynb:90002
msgid ""
"Since we adopt the functional programming paradigm. We must explicitly "
"initialize and use the state of a module. To initialize, call `init` with"
" a pseudorandom number generators key (PRNGKey)."
msgstr "由于我们采用了函数式编程范式。我们必须显式地初始化并使用模块的状态。要进行初始化，使用伪随机数生成器的键（PRNGKey）调用`init`。"

#: ../../source/guide/user/1-start.ipynb:110002
msgid ""
"The `state` represents the mutatable variables within the whole workflow,"
" including those inside the algorithm and the problem. For example, the "
"`population` in an algorithm is part of the `state`, because it will be "
"changing across iterations."
msgstr ""
"`state`代表整个工作流中的可变变量，包括算法和问题内部的变量。例如，算法中的`population`（种群）是 state "
"的一部分，因为它会在迭代过程中发生变化。"

#: ../../source/guide/user/1-start.ipynb:120002
msgid "Now, call `step` on the workflow to execute one iteration."
msgstr "现在，调用工作流上的 `step` 来执行一个迭代。"

#: ../../source/guide/user/1-start.ipynb:140002
msgid "To run multiple iterations, wrap it inside a for-loop."
msgstr "想要执行多次迭代，只要在这外面套一个for循环即可。"

#: ../../source/guide/user/1-start.ipynb:160002
msgid ""
"Notice that we are passing `state` as an argument of `step` and it "
"returns a new `state`. This is exactly how the stateful computation works"
" in functional programming."
msgstr "请注意，我们将 `state` 作为 `step` 的一个参数传递，并且它返回一个新的 `state`。这正是函数式编程中有状态计算的工作方式。"

#: ../../source/guide/user/1-start.ipynb:170002
msgid ""
"And you may also notice that the `step` doesn't give any feedback, like "
"the result of the optimization. This is because we are missing another "
"component in our workflow. Introducing `monitor`."
msgstr "你可能还会注意到，`step` 并没有提供任何反馈，比如优化的结果。这是因为我们的工作流中缺少另一个组件。这里介绍 `monitor`（监视器）。"

#: ../../source/guide/user/1-start.ipynb:180002
msgid "Monitor"
msgstr "监控器"

#: ../../source/guide/user/1-start.ipynb:180004
msgid ""
"Monitor is a standard way to monitor the intermediate values inside a "
"optimization process. Information like fitness or population can be "
"easily obtained by the monitor."
msgstr "监视器是监控优化过程中中间值的标准方法。像适应度或种群这样的信息可以通过监视器轻松获得。"

#: ../../source/guide/user/1-start.ipynb:190002
msgid "Now, create a \"Evalution monitor\""
msgstr "现在，创建一个“评估监视器”"

#: ../../source/guide/user/1-start.ipynb:210002
msgid "The monitor can be plugged into the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../source/guide/user/1-start.ipynb:230002
msgid "Now, re-initialize the workflow, and executed it again."
msgstr "现在，重新初始化工作流，并再次执行它。"

#: ../../source/guide/user/1-start.ipynb:250002
msgid ""
"To access the minimum fitness achieved, we use the `monitor` submodule. "
"However, since the `state` variable belongs to the `workflow` variable, "
"it cannot be accessed directly by its submodule, `monitor`. Instead, we "
"need to use the `use_state` wrapper."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:250005
msgid ""
"In EvoX, whenever you want to call a method from a submodule, the "
"`use_state` wrapper is required. This wrapper handles nested submodules "
"at any depth, so you don’t need to worry about the module structure."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:270002
msgid ""
"Execute another 5 iterations, and the minimum fitness will change "
"accordingly."
msgstr "再执行5次迭代，最小适应度将相应改变。"

#: ../../source/guide/user/1-start.ipynb:300002
msgid ""
"It shows the best solution is (-8.6565415e-05,  5.9473794e-05), which is "
"close to the global minimum at (0,0). 🥳"
msgstr "它显示最佳解为 (-8.6565415e-05,  5.9473794e-05)，这接近于全局最小值 (0,0)。🥳"

#: ../../source/guide/user/1-start.ipynb:300004
msgid ""
"Additionally, please note that the best fitness remains the same as last "
"time. This is because we are using the same `key` when initializing the "
"workflow as before. This deterministic behavior in EvoX allows others to "
"easily reproduce your results."
msgstr ""
"另外，请注意最佳适应度与上次相同。这是因为我们在初始化工作流程时使用了与之前相同的 "
"`key`。EvoX中的这种确定性行为使其他人可以轻松复现你的结果。"

#: ../../source/guide/user/1-start.ipynb:300006
msgid "finally, we can use the built-in `plot` function to plot the loss curve."
msgstr "最后，我们可以用自带的`plot`函数绘制损失曲线。"

#: ../../source/guide/user/2-problems.ipynb:10002
msgid "Working with extended applications"
msgstr "处理扩展应用"

#: ../../source/guide/user/2-problems.ipynb:10004
msgid "Working with extended applications in EvoX is easy."
msgstr "在EvoX中处理扩展应用很简单。"

#: ../../source/guide/user/2-problems.ipynb:40002
msgid "Neuroevolution Tasks"
msgstr "神经演化任务"

#: ../../source/guide/user/2-problems.ipynb:40004
msgid ""
"Here we will be focusing on neuroevolution tasks, where one need to "
"evolve a neural network that suits a certain tasks."
msgstr "在这里，我们将专注于神经进化任务，其中需要进化出适合特定任务的神经网络。"

#: ../../source/guide/user/2-problems.ipynb:50002
msgid "Brax"
msgstr "Brax"

#: ../../source/guide/user/2-problems.ipynb:50004
msgid ""
"To begin with we will be using Brax, a GPU accelerated physical engine "
"that is also written in JAX. Since Brax is also using JAX, running EvoX "
"with Brax is quite easy."
msgstr "首先，我们将使用Brax，这是一个用JAX编写的GPU加速物理引擎。由于Brax也使用JAX，因此将EvoX与Brax一起运行相当容易。"

#: ../../source/guide/user/2-problems.ipynb:50007
msgid "We will be demostrating using the \"swimmer\" environment in Brax."
msgstr "我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/guide/user/2-problems.ipynb:60002
msgid ""
"First we will need to decide how we are going to evolve a neural network."
" In this case, we will be using a fixed-size ANN, and only evolve it's "
"weights."
msgstr "首先，我们需要决定如何进化神经网络。在这种情况下，我们将使用固定大小的人工神经网络（ANN），并仅进化其权重。"

#: ../../source/guide/user/2-problems.ipynb:90002
msgid ""
"However, if we check the weights for this network, we will see that it's "
"group of parameter sets, and EC algorithms cannot directly work with data"
" in this format."
msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）算法无法直接处理这种格式的数据。"

#: ../../source/guide/user/2-problems.ipynb:90005
msgid ""
"Thankfully, EvoX provides some useful utilities to help us bridge the "
"gap, and in this case, we have `TreeAndVector` to help us convert a tree-"
"like struct into a vector and back."
msgstr "幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#: ../../source/guide/user/2-problems.ipynb:110002
msgid "Now, `adapter` can help us convert the data back-and-forth."
msgstr "现在`adapter`可以帮助我们来回转换数据格式。"

#: ../../source/guide/user/2-problems.ipynb:110004
msgid "`to_vector` can convert a tree into a vector."
msgstr "`to_vector` 可以将树转化成向量形式。"

#: ../../source/guide/user/2-problems.ipynb:110005
msgid "`to_tree` can convert a vector back to a tree."
msgstr "`to_tree` 可以把向量转化回树的形式。"

#: ../../source/guide/user/2-problems.ipynb:110007
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/user/2-problems.ipynb:110009
msgid "`batched_to_vector` can convert a batch of trees into a batch of vectors."
msgstr "`batched_to_vector`可以将一批树状结构转换为一批向量。"

#: ../../source/guide/user/2-problems.ipynb:110010
msgid "`batched_to_tree` can convert a batch of vectors into a batch of trees."
msgstr "`batched_to_tree` 可以将一批向量转换为一批树状结构。"

#: ../../source/guide/user/2-problems.ipynb:130002
msgid "Now we can create an algorithm object."
msgstr "现在我们可以创建一个算法对象。"

#: ../../source/guide/user/2-problems.ipynb:150002
msgid ""
"Now create brax-based problem. and `max_episode_length` is the maximum "
"number of steps for each episode, `num_episodes` is the number of "
"episodes to run for each evaluation. In this case, we will be using 1000 "
"steps for each episode, and the average reward of 3 episodes will be "
"returned as the fitness value."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:170002
msgid "Assemble our workflow and fire it!"
msgstr "组装我们的工作流程并启动它！"

#: ../../source/guide/user/2-problems.ipynb:170004
#, fuzzy
msgid ""
"Notice the `solution_transforms` option. It's used to convert the "
"candidate solutions into the tree-like structure that representing a "
"neural network's weight."
msgstr "请注意 `sol_transforms` 选项。它用于将种群转换成表示神经网络权重的树状结构。"

#: ../../source/guide/user/2-problems.ipynb:190002
msgid "Run the workflow and see the magic!"
msgstr "运行工作流并见证魔法！"

#: ../../source/guide/user/2-problems.ipynb:190005
msgid ""
"The following block will take around 10 mins to run. The time may vary "
"depending on your hardware."
msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#: ../../source/guide/user/2-problems.ipynb:240002
msgid ""
"The algorithm is making progress in optimizing the policy; however, the "
"results are still far from ideal. It's important to remember that this is"
" just a demonstration, and vanilla PSO wasn’t designed for this type of "
"task, so its performance limitations here are expected."
msgstr ""

#: ../../source/guide/user/3-distributed.md:1
#, fuzzy
msgid "Distributed Training"
msgstr "分布式工作流程"

#: ../../source/guide/user/3-distributed.md:3
#, fuzzy
msgid "Parallel Model"
msgstr "MOEA/D算法"

#: ../../source/guide/user/3-distributed.md:5
msgid ""
"All states are replicated across all devices including population. Then, "
"on every device, a sharded candidates are passed to `problem.evaluate()`,"
" and the fitnesses are shared across all device (by `all_gather`). This "
"ensures all devices share the same state data without explicit "
"synchronization. In other word, this parallel model only accelerate the "
"problem's evaluation part, and cannot reduce the memory consumption. We "
"use it as our default distributed strategy, as it offers EC algorithms "
"maximum flexibility."
msgstr ""

#: ../../source/guide/user/3-distributed.md:7
msgid "Multiple devices on a single node"
msgstr ""

#: ../../source/guide/user/3-distributed.md:9
#, fuzzy
msgid "Example:"
msgstr "例子："

#: ../../source/guide/user/3-distributed.md:37
msgid "Multiple devices on multiple nodes"
msgstr ""

#: ../../source/guide/user/3-distributed.md:39
msgid "Example of script `dist_train.py`"
msgstr ""

#: ../../source/guide/user/3-distributed.md:83
msgid "Run script on each node:"
msgstr ""

#: ../../source/guide/user/3-distributed-old.md:1
msgid "Distribute the workflow"
msgstr "分布式工作流程"

#: ../../source/guide/user/3-distributed-old.md:3
msgid ""
"EvoX provides two distributed workflow implementation, one is based on "
"Ray, and the other one is based on jax.distribute."
msgstr "EvoX 提供了两种分布式工作流实现，一种基于 Ray，另一种基于 jax.distribute。"

#: ../../source/guide/user/3-distributed-old.md:5
msgid "RayDistributedWorkflow"
msgstr "RayDistributedWorkflow"

#: ../../source/guide/user/3-distributed-old.md:7
msgid ""
"RayDistributedWorkflow is built upon Ray. It can be used on any ray "
"cluster. The Ray cluster should be setup before running the EvoX program."
msgstr "RayDistributedWorkflow是基于Ray构建的。它可以在任何Ray集群上使用。在运行EvoX程序之前，应该先设置Ray集群。"

#: ../../source/guide/user/3-distributed-old.md:9
msgid "Setup Ray cluster"
msgstr "设置Ray集群"

#: ../../source/guide/user/3-distributed-old.md:11
msgid ""
"Please refer to [Ray's official "
"documentation](https://docs.ray.io/en/latest/cluster/getting-"
"started.html) for guide on setting up an Ray cluster."
msgstr ""
"请参考[Ray的官方文档](https://docs.ray.io/en/latest/cluster/getting-"
"started.html)来获取关于设置Ray集群的指南。"

#: ../../source/guide/user/3-distributed-old.md:13
msgid "Here is a simple way to setup the cluster locally."
msgstr "这里有一个简单的本地集群搭建方法。"

#: ../../source/guide/user/3-distributed-old.md:15
msgid "On the head node"
msgstr "在头节点上"

#: ../../source/guide/user/3-distributed-old.md:19
msgid "On worker nodes"
msgstr "在工作节点上"

#: ../../source/guide/user/3-distributed-old.md:24
msgid ""
"If you only have 1 machine, but multiple devices, then there is nothing "
"needs to be done. Ray will setup itself in this case."
msgstr "如果你只有一台机器但是有多个设备，这种情况下，不需要进行别的设置，Ray会自行进行配置。"

#: ../../source/guide/user/3-distributed-old.md:26
#: ../../source/guide/user/3-distributed-old.md:72
msgid "Setup EvoX"
msgstr "设置 EvoX"

#: ../../source/guide/user/3-distributed-old.md:28
msgid ""
"To scale the workflow using multiple machines through Ray, use the "
"{class}`RayDistributedWorkflow <evox.workflows.RayDistributedWorkflow>` "
"instead of StdWorkflow."
msgstr ""
"要通过Ray使用多台机器扩展工作流，请使用 {class}`RayDistributedWorkflow "
"<evox.workflows.RayDistributedWorkflow>` 类替代标准工作流StdWorkflow。"

#: ../../source/guide/user/3-distributed-old.md:30
msgid "First, import `workflows` from evox"
msgstr "首先，从evox中导入'workflows'"

#: ../../source/guide/user/3-distributed-old.md:36
msgid "then create your algorithm, problem, monitor object as usual."
msgstr "接下来创建algorithm，problem，monitor对象。"

#: ../../source/guide/user/3-distributed-old.md:44
msgid "Now use `RayDistributedWorkflow`"
msgstr "现在使用 `RayDistributedWorkflow`"

#: ../../source/guide/user/3-distributed-old.md:57
msgid ""
"The `RayDistributedWorkflow` also uses the `workflow.step` function to "
"execute iterations. However, under the hood, it employs a distinct "
"approach that allows for the utilization of multiple devices across "
"different machines."
msgstr ""
"`RayDistributedWorkflow`同样运用 "
"`workflow.step`函数来执行迭代过程。然而，在底层实现上，它采用了一种独特的方法，能够跨多台机器利用多个设备。"

#: ../../source/guide/user/3-distributed-old.md:60
#, python-format
msgid ""
"It is recommanded that one set the environment variable "
"`XLA_PYTHON_CLIENT_PREALLOCATE=false`. By default JAX will pre-allocate "
"80% of the device's memory. This variable disables the GPU memory "
"preallocation, otherwise running multiple JAX processes may cause OOM. "
"For more information, please refer to [JAX's "
"documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
" on this matter."
msgstr ""
"建议设置环境变量XLA_PYTHON_CLIENT_PREALLOCATE=false。默认情况下，JAX会预先分配设备内存的80%。此变量用于禁用GPU内存预分配，否则运行多个JAX进程可能会导致内存不足（OOM）。有关此事项的更多信息，请参考JAX的文档(https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
" 。"

#: ../../source/guide/user/3-distributed-old.md:66
msgid "StdWorkflow"
msgstr "工作流"

#: ../../source/guide/user/3-distributed-old.md:68
msgid ""
"StdWorkflow is short for \"Universal Workflow\", which aims to use pure "
"JAX to build a workflow that fits any requirement. Since `StdWorkflow` is"
" written in pure JAX, it has less overhead and don't need any additional "
"dependencies."
msgstr ""
"\"StdWorkflow\"是“Standard "
"Workflow”的缩写，其目的是使用纯JAX构建一个适应任何需求的工作流。由于StdWorkflow是用纯JAX编写的，它的开销较小，不需要任何额外的依赖。"

#: ../../source/guide/user/3-distributed-old.md:74
msgid ""
"Use `StdWorkflow` to create an workflow, and use `enable_distributed` and"
" pass in the state to enable this feature."
msgstr "使用`StdWorkflow`创建一个工作流然后使用`enable_distributed`并且传入相应状态来启用此功能。"

#: ../../source/guide/user/3-distributed-old.md:90
msgid ""
"Then, at the start of your program, before any JAX function is called, do"
" this:"
msgstr "在你的程序开始之前进行的任何JAX函数调用，需要做这些操作："

#: ../../source/guide/user/3-distributed-old.md:96
msgid ""
"In this system, the `coordinator` serves as the primary or head node. The"
" total number of participating processes is indicated by `num_process`. "
"The process with `process_id=0` acts as the coordinator."
msgstr "在这个系统中，“coordinator”（协调器）充当主节点或头节点的角色。参与进程的总数由num_process指示。具有process_id=0的进程充当协调器。"

#: ../../source/guide/user/3-distributed-old.md:98
msgid ""
"From more information, please refer to "
"[jax.distributed.initialize](https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)"
" and [Using JAX in multi-host and multi-process "
"environments](https://jax.readthedocs.io/en/latest/multi_process.html)."
msgstr "有关更多信息，请参考jax.distributed.initialize(https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)和在多主机和多进程环境中使用JAX的文档(https://jax.readthedocs.io/en/latest/multi_process.html)。"

#: ../../source/guide/user/3-distributed-old.md:100
msgid "Run in a cluster"
msgstr "在一个集群中运行"

#: ../../source/guide/user/3-distributed-old.md:102
msgid ""
"Unlike Ray, JAX's doesn't have the concept of cluster or scheduler. "
"Instead, it offers tools for enabling distributed interactions among "
"multiple JAX instances. JAX follows the SPMD (single program multiple "
"data) paradigm. To initiate a distributed program in JAX, you simply need"
" to run the same script on different machines. For instance, if your "
"program is named `main.py`, you should execute the following command on "
"all participating machines with different `process_id` argument in "
"`jax.distributed.initialize`:"
msgstr "不同于Ray，JAX没有集群或调度器的概念。相反，它提供了工具来实现多个JAX实例之间的分布式交互。JAX遵循SPMD（单程序多数据）范式。要在JAX中启动一个分布式程序，你只需在不同的机器上运行相同的脚本。例如，如果你的程序名为main.py，你应该在所有参与的机器上执行以下命令，并在jax.distributed.initialize中为不同的机器设置不同的process_id参数："

#: ../../source/guide/user/3-distributed-old.md:110
msgid ""
"To have `process_id` in the argument, one can use `argparse` to parse the"
" argument from the commandline. For example:"
msgstr "为了在参数中包含process_id，可以使用argparse库从命令行解析参数。例如："

#: ../../source/guide/user/3-distributed-old.md:125
msgid ""
"Then call `python main.py 0` on the first machine, `python main 1` on the"
" second machine and so on."
msgstr "然后在第一台机器上调用'python main.py 0'，在第二台机器上调用'python main.py 1'，依此类推。"

#: ../../source/guide/user/4-container.md:1
msgid "Container Algorithms"
msgstr "容器算法"

#: ../../source/guide/user/4-container.md:3
msgid ""
"Container algorithms are a special type of algorithms that work by "
"containing other algorithms and cannot work on their own. Container "
"algorithms can be used to compose a series of normal algorithms together."
msgstr "容器算法是一种特殊类型的算法，通过包含其他算法来工作，不能单独工作。容器算法可以用来将一系列普通算法组合在一起。"

#: ../../source/guide/user/4-container.md:8
msgid ""
"We offer Cooperative Coevolution (CC) framework for all algorithms. "
"Currently, there are two types of CC container in EvoX, "
"{class}`evox.algorithms.Coevolution` and "
"{class}`evox.algorithms.VectorizedCoevolution`. The difference is that "
"`VectorizedCoevolution` updates all sub-populations at the same time in "
"each generation, but `Coevolution` follows the traditional approach that "
"updates a single sub-populations at each generation."
msgstr ""
"我们为所有的算法提供了协同演化（CC）框架。目前，再EvoX中有两种类型的CC容器，分别是{class}`evox.algorithms.Coevolution`"
" 和 "
"{class}`evox.algorithms.VectorizedCoevolution`。它们的区别在于，`VectorizedCoevolution`"
" 在每一代中同时更新所有子种群，而 `Coevolution` 则遵循传统方法，在每一代中更新单个子种群。"

#: ../../source/guide/user/4-container.md:13
msgid ""
"The difference can be illustrated as follows, where $pop1$ and $pop2$ are"
" two sub-populations, and together they form the whole population."
msgstr "区别可以如下所示，其中 $pop1$ 和 $pop2$ 是两个子种群，它们一起组成整个种群。"

#: ../../source/guide/user/4-container.md:15
msgid "Coevolution:"
msgstr "协同演化："

#: ../../source/guide/user/4-container.md:20
msgid "VectorizedCoevolution:"
msgstr ""

#: ../../source/guide/user/4-container.md:25
msgid ""
"Coevolution will update each sub-population one by one, so later sub-"
"population can utilize the most up-to-date information from the previous "
"sub-populations. Vectorized Coevolution on the other hand, updates all "
"sub-populations at the same time, thus gives a more parallelized "
"computation. In conclusion `VectorizedCoevolution` is faster, but "
"`Coevolution` could be better in terms of optimization result with a "
"limited number of evaluations."
msgstr ""
"协同进化将逐个更新每个子种群，因此后续子种群可以利用前面子种群的最新信息。另一方面，向量化协同进化同时更新所有子种群，因此提供了更并行化的计算。总的来说，`VectorizedCoevolution`"
" 更快，但在有限次数的评估中，`Coevolution` 在优化结果方面可能更好。"

#: ../../source/guide/user/4-container.md:29
msgid "Code Example"
msgstr "代码样例"

#: ../../source/guide/user/4-container.md:31
msgid "Coevolution with 2 CSO algorithms."
msgstr "2个CSO算法协同演化。"

#: ../../source/guide/user/4-container.md:66
msgid "In summary to apply the container algorithm, you need to:"
msgstr "总结来说，应用容器算法的步骤如下："

#: ../../source/guide/user/4-container.md:68
msgid "Create a list of base algorithms."
msgstr "创建一个基础算法的列表。"

#: ../../source/guide/user/4-container.md:69
msgid "Use `Stateful.stack` to stack the base algorithms."
msgstr "使用`Stateful.stack`来堆叠基础算法。"

#: ../../source/guide/user/4-container.md:70
msgid "Create a container algorithm with the stacked base algorithms."
msgstr "通过一个堆叠的基础算法创建容器算法。"

#: ../../source/guide/user/4-container.md:72
msgid ""
"Please notice that the coevolution implementation in EvoX is still under "
"development, so there might be some rough edges, and does not reflect the"
" latest research results in the coevolution field."
msgstr "请注意，EvoX 中的协同进化实现仍在开发中，因此可能存在一些不完善之处，并且可能不反映协同进化领域的最新研究结果。"

#: ../../source/guide/user/index.md:1 ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:14
msgid "API Reference"
msgstr "API文档"

#: ../../source/index.md:26 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr "杂项"

#: ../../source/index.md:26
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:35
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"

#: ../../source/index.md:37
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary"
" computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/index.md:41
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:43
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:44
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:45
msgid ""
"Leverage the power of {class}`Distributed Workflows "
"<evox.workflows.RayDistributedWorkflow>` for even more rapid "
"optimization."
msgstr "利用 {class}`分布式工作流 <evox.workflows.RayDistributedWorkflow>` 的强大功能，实现更快速的优化。"

#: ../../source/index.md:47
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:48
msgid ""
"Cater to all your needs with both {doc}`Single-objective "
"<api/algorithms/so/index>` and {doc}`Multi-objective "
"<api/algorithms/mo/index>` optimization capabilities."
msgstr ""
"满足您所有需求，包括 {doc}`单目标 <api/algorithms/so/index>` 和 {doc}`多目标 "
"<api/algorithms/mo/index>`优化功能。"

#: ../../source/index.md:49
msgid ""
"Dive into a comprehensive library of {doc}`Benchmark Problems "
"<api/problems/numerical/index>`, ensuring robust testing and evaluation."
msgstr "深入了解全面的{doc}`基准测试问题库 <api/problems/numerical/index>`，确保进行稳健的测试和评估。"

#: ../../source/index.md:50
msgid ""
"Explore the frontier of AI with extensive tools for {doc}`Neuroevolution "
"<api/problems/neuroevolution/index>` tasks."
msgstr "探索人工智能前沿领域，利用广泛的工具进行 {doc}`神经演化 <api/problems/neuroevolution/index>` 任务。"

#: ../../source/index.md:52
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:53
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:54
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and "
"clean programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:57
msgid "<br></br>"
msgstr "<br></br>"

#: ../../source/index.md:64
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 "
"0v8.58l1.949-2.11A.75.75 0 1 1 15.8 8.237l-3.25 3.52a.75.75 0 0 1-1.102 "
"0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949 2.111Z\"></path><path d=\"M2.5 "
"3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 0 0 .25-.25V3.75a.25.25 0 0 "
"0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 1.75.784 1.75 1.75v11.5A1.75"
" 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652 1.769 3.757A.752.752 0 0"
" 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105 1.599-2.382 "
"1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 2.75 "
"2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> Installation "
"Guide"
msgstr ""
"<path fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 "
"9.005 0 015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"><path d=\"M17.29 8c-.148 0-.292.01-.434.03a.75.75 0 "
"11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 6.69 0 013.956 6.107.75.75 0 "
"01-1.5 0 5.193 5.193 0 00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03"
" 0 0017.29 8z\"><path fill-rule=\"evenodd\" d=\"M2.5 3.75a.25.25 0 "
"01.25-.25h5.5a.75.75 0 100-1.5h-5.5A1.75 1.75 0 001 3.75v11.5c0 .966.784 "
"1.75 1.75 1.75h6.204c-.171 1.375-.805 2.652-1.77 3.757A.75.75 0 007.75 "
"22h8.5a.75.75 0 "
"00.565-1.243c-.964-1.105-1.598-2.382-1.769-3.757h6.204A1.75 1.75 0 0023 "
"15.25V3.75A1.75 1.75 0 0021.25 2h-5.5a.75.75 0 000 1.5h5.5a.25.25 0 "
"01.25.25v11.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V3.75zM10.463 "
"17c-.126 1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5h-3.074z\"> 安装教程"

#: ../../source/index.md:70
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M3.5 8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0"
" 0 1-1.5.045 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0"
" 0 1 5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 "
"0-8Zm8.29 4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0"
" 1 3.38 8.097 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0"
" 0 0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> User Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 9.005 0 "
"015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"></path><path d=\"M17.29 8c-.148 "
"0-.292.01-.434.03a.75.75 0 11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 "
"6.69 0 013.956 6.107.75.75 0 01-1.5 0 5.193 5.193 0 "
"00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0017.29 "
"8z\"></path></svg> 用户教程"

#: ../../source/index.md:76
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 "
"1.382L19 10.108V15a.75.75 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 "
"1.23-.673 0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 "
"1.042.1 1.654.1 2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 "
"0 1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 "
"1.41.923 2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 "
"3.923 3.923 0 0 1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 "
"1-1.925-.288 4.065 4.065 0 0 1-.52-.213 1.816 1.816 0 0 "
"1-.22-.124.757.757 0 0 1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 "
"2.904 0 0 1 1.327-.757V9.793L.458 8.19a.75.75 0 0 1 "
"0-1.38l11.25-4.75a.75.75 0 0 1 .584 0ZM12 11.436 21.322 7.5 12 3.564 "
"2.678 7.5ZM5 15c-.377 0-.745.141-1.017.413-.265.265-.483.7-.483 "
"1.368v4.022c.299.105.797.228 1.5.228s1.201-.123 "
"1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0 0 0 5 "
"15Z\"></path></svg> Developer Guide"
msgstr ""

#: ../../source/index.md:86
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0"
" 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1"
" 0 0 1 2 0ZM4 7a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1"
" 0 2Z\"></path></svg> Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> 算法"

#: ../../source/index.md:92
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0"
" 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1"
" 0 0 1 2 0ZM4 7a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1"
" 0 2Z\"></path></svg> Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> 问题"

#: ../../source/index.md:99
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0"
" 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1"
" 0 0 1 2 0ZM4 7a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1"
" 0 2Z\"></path></svg> Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> 指标"

#: ../../source/miscellaneous/high_vram_usage.md:1
msgid "High VRAM usage"
msgstr "高显存占用"

#: ../../source/miscellaneous/high_vram_usage.md:3
#, python-format
msgid ""
"By default, JAX will allocate 75% of the GPU memory regardless of the "
"program you run. This preallocate is used to avoid memory fragmentation "
"and improve performance."
msgstr "默认情况下，无论运行哪个程序，JAX 都将分配 75%的显存。这种预分配是为了避免内存碎片化并提高性能。"

#: ../../source/miscellaneous/high_vram_usage.md:6
msgid ""
"To disable this behavior, you can use the "
"`XLA_PYTHON_CLIENT_PREALLOCATE=false` environment variable."
msgstr "要禁用此行为，您可以使用 `XLA_PYTHON_CLIENT_PREALLOCATE=false` 环境变量。"

#: ../../source/miscellaneous/high_vram_usage.md:8
msgid ""
"For more information, please refer to the [JAX "
"documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)."
msgstr "更多信息，请参考[JAX文档](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)."

#: ../../source/miscellaneous/selecting_gpu.md:1
#, fuzzy
msgid "Selecting GPU / CPU"
msgstr "选择GPU"

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""
"要在特定的 GPU 上运行程序，您可以使用 `CUDA_VISIBLE_DEVICES` 环境变量。例如，要在第二个 GPU "
"上运行程序，您可以使用："

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr "要在多个GPU上跑你的程序，你可以用："

#: ../../source/miscellaneous/selecting_gpu.md:15
#, fuzzy
msgid "To disable GPU usage (use CPU), you can use:"
msgstr "如果要禁用GPU，你可以用："

#~ msgid "EvoX's API"
#~ msgstr "EvoX的API"

#~ msgid "**env_per_worker**"
#~ msgstr ""

#~ msgid "Number of gym environment per worker."
#~ msgstr ""

#~ msgid "**pop_size**"
#~ msgstr ""

#~ msgid ""
#~ "Population size, this argument together "
#~ "with num_workers will be used to "
#~ "determine the sharding strategy."
#~ msgstr ""

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/1-start.ipynb)"
#~ msgstr ""

#~ msgid "Open in Colab"
#~ msgstr "在Colab中打开"

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/2-problems.ipynb)"
#~ msgstr ""

#~ msgid "EvoX's guide!"
#~ msgstr ""

#~ msgid "API reference"
#~ msgstr ""

#~ msgid "Contents:"
#~ msgstr ""

#~ msgid "Indices and tables"
#~ msgstr ""

#~ msgid "{ref}`genindex`"
#~ msgstr ""

#~ msgid "{ref}`modindex`"
#~ msgstr ""

#~ msgid "{ref}`search`"
#~ msgstr "{ref}`search`"

#~ msgid ""
#~ "A Built-in plot function for "
#~ "visualizing the population of single-"
#~ "objective algorithm. Use plotly internally,"
#~ " so you need to install plotly "
#~ "to use this function."
#~ msgstr "内置的单目标算法种群可视化绘图函数。内部使用plotly库，因此要使用此功能，您需要先安装plotly。"

#~ msgid ""
#~ "If the problem is provided, we "
#~ "will plot the fitness landscape of "
#~ "the problem."
#~ msgstr "如果提供了问题实例，我们将绘制该问题的适应度landscape。"

#~ msgid ""
#~ "pop_transform and fitness_transform are "
#~ "applied at each node, while "
#~ "global_fitness_transform is applied at the "
#~ "main node once per step, so "
#~ "monitor should be passed as "
#~ "global_fitness_transform."
#~ msgstr "pop_transform和fitness_transform在每个节点上分别应用，而global_fitness_transform则在主节点上每一步执行一次。因此，monitor应当作为global_fitness_transform传递。"

#~ msgid "**fitness_transform:**"
#~ msgstr "**fitness_transform:**"

#~ msgid "**global_fitness_transform:**"
#~ msgstr "**global_fitness_transform:**"

#~ msgid "This transform is applied at the main node."
#~ msgstr "这个变换在主节点上应用。"

#~ msgid "**record_pop**"
#~ msgstr "**种群记录**"

#~ msgid "Whether to record the population if monitor is enabled."
#~ msgstr "如果启用了monitor，是否要记录种群数据。"

#~ msgid "**record_time**"
#~ msgstr "**时间记录**"

#~ msgid ""
#~ "Whether to record the time at the"
#~ " end of each generation. Due to "
#~ "its timing nature, record_time requires "
#~ "synchronized functional call. Default to "
#~ "False."
#~ msgstr "是否记录每代结束的时间。由于它的计时性质，record_time需要同步的函数调用。默认为False。"

#~ msgid "Universal Workflow"
#~ msgstr "通用工作流"

#~ msgid "**jit_monitor**"
#~ msgstr "**jit_monitor**"

#~ msgid "If the monitor can be jit compiled by JAX or not. Default to False."
#~ msgstr "监视器是否可以通过JAX进行jit编译。默认为False。"

#~ msgid ""
#~ "Automatically apply cooperative coevolution to"
#~ " any algorithm. The process of "
#~ "cooperative coevolution is vectorized, meaning"
#~ " all sub-populations will evolve at"
#~ " the same time in each generation."
#~ msgstr "将协同演化自动应用于任何算法。协同演化的过程被向量化，意味着在每一代中，所有的子种群将同时进化。"

#~ msgid ""
#~ "Automatically apply cooperative coevolution to"
#~ " any algorithm. The process of "
#~ "cooperative coevolution is not vectorized, "
#~ "meaning all sub-populations will evolve"
#~ " one at a time (round-robin) in"
#~ " each generation."
#~ msgstr "将协同演化自动应用于任何算法。协同演化的过程未被向量化，这意味着在每一代中，所有子种群将逐一（轮流）进行进化。"

#~ msgid "CPSO_S"
#~ msgstr "CPSO_S"

#~ msgid ""
#~ "Cooperative particle swarm optimizer. "
#~ "Implemented using EvoX's built-in "
#~ "coevolution framework. CPSOS essentially a "
#~ "wrapper around PSO and Coevolution."
#~ msgstr "协同粒子群优化器（CPSO）在EvoX库中通过其内置的协同演化框架得以实现，实质上，CPSOS本质上是对PSO（粒子群优化算法）和协同演化的封装。"

#~ msgid "https://ieeexplore.ieee.org/document/1304845"
#~ msgstr "https://ieeexplore.ieee.org/document/1304845"

#~ msgid ""
#~ "will be wrapped with `use_state` "
#~ "decorator. This decorator requires the "
#~ "method have the following signature:"
#~ msgstr "将会用 use_state 装饰器包装。这个装饰器要求方法具有以下签名："

#~ msgid ""
#~ ":::{warning} Currently, for all user-"
#~ "defined private methods, the name of "
#~ "the method should start with `_``. "
#~ ":::"
#~ msgstr ":::{警告} 目前，对于所有用户定义的私有方法，方法名称应该以 _ 开头。 :::"

#~ msgid ""
#~ "To solve is problem, it is common"
#~ " practice to jit-compile low-level"
#~ " components, thus giving high-level "
#~ "components more freedom. In EvoX, we "
#~ "have some general rules on whether "
#~ "a function should be jit-able or"
#~ " not."
#~ msgstr ""
#~ "为了解决这个问题，通常的做法是 JIT 编译低层组件，从而给高层组件更多的自由。在 EvoX "
#~ "中，我们有一些关于函数是否应该是可 JIT 编译的通用规则。"

#~ msgid "Component"
#~ msgstr "组件"

#~ msgid "jit-able"
#~ msgstr "可以被jit编译的"

#~ msgid "`Workflow`"
#~ msgstr "工作流"

#~ msgid "Optional"
#~ msgstr "可选的"

#~ msgid "`Algorithm`"
#~ msgstr "算法"

#~ msgid "Yes"
#~ msgstr "是的"

#~ msgid "`Problem`"
#~ msgstr "问题"

#~ msgid "`Operators`"
#~ msgstr "操作符"

#~ msgid "`Monitor`"
#~ msgstr "监控器"

#~ msgid "No"
#~ msgstr "不是"

#~ msgid ""
#~ "For standard workflow, one can jit "
#~ "compile when not using monitors and "
#~ "working with jit-able problems. But "
#~ "even though the workflow can be "
#~ "compiled, there isn't much performance "
#~ "gain. For problems, it depends on "
#~ "the task."
#~ msgstr ""
#~ "对于标准工作流，当不使用监视器并且处理可 JIT 编译的问题时，可以进行 JIT "
#~ "编译。但即使工作流可以被编译，性能提升也不大。对于问题，这取决于任务。"

#~ msgid ""
#~ "Many algorithms are expensive in terms"
#~ " of space or time. For example, "
#~ "CMA-ES requires $O(N^2)$ space. Thus,"
#~ " it is costly to run CMA-ES "
#~ "on high-dimension problems. Sep-CMA-"
#~ "ES scales better but sacrifices the "
#~ "performance. That's where the container "
#~ "algorithm comes in. With it, we "
#~ "can easily construct a variant of "
#~ "CMA-ES that uses $O((\\frac{N}{M})^2)$ "
#~ "space, where $M$ is the number of"
#~ " blocks. This variant is a balance"
#~ " between the normal CMA-ES and "
#~ "Sep-CMA-ES."
#~ msgstr ""
#~ "许多算法在空间或时间方面的成本都很高。例如，CMA-ES需要$O(N^2)$的空间。因此，在高维问题上运行CMA-"
#~ "ES的成本很高。Sep-CMA-"
#~ "ES的扩展性更好，但牺牲了性能。这就是容器算法的用武之地。有了它，我们可以轻松构建一个使用$O((\\frac{N}{M})^2"
#~ ")$空间的CMA-ES变体，其中$M$是块的数量。这种变体是普通CMA-ES和Sep-CMA-"
#~ "ES之间的平衡。"

#~ msgid "Working with PyTree"
#~ msgstr "处理 PyTree"

#~ msgid ""
#~ "Usually, algorithms expect the decision "
#~ "variables to be in the form of "
#~ "a 1D-vector. PyTrees are tree-like"
#~ " structures that are not directly "
#~ "compatible with normal algorithms. So, "
#~ "there are two solutions out there:"
#~ msgstr "一般来说，算法期望决策变量以一维形式呈现。但是Pytrees是树类结构不能直接与常见的算法兼容。所以这里有两种解决方法："

#~ msgid "Flatten the PyTree to 1D-vector."
#~ msgstr "将Pytree平展成一维向量。"

#~ msgid "Use a specialized algorithm that work with PyTree directly."
#~ msgstr "使用经过特殊化算法来直接处理Pytree。"

#~ msgid ""
#~ "Solution 1 is called `adapter` in "
#~ "EvoX, which is quite simple, but "
#~ "we are not talking about this "
#~ "here. Solution 2 seems more complicated,"
#~ " but the advantage is that the "
#~ "structural information is preserved, meaning"
#~ " the algorithm could see the tree "
#~ "structure and apply some type of "
#~ "heuristic here."
#~ msgstr "在EvoX中方法1被命名为adapter并且非常简单，这里不再进行赘述。方法2更为复杂，但是保留原本的信息结构是他的一个优点，这意味着算法可以知道树的结构并且在此使用某种类型的启发式算法。"

#~ msgid "Advanced Tutorial"
#~ msgstr "进阶教程"

#~ msgid ""
#~ "To record information related to the "
#~ "population as well, turn on `record_pop`"
#~ " option in the workflow."
#~ msgstr "要同时记录与种群相关的信息，请在工作流中打开 `record_pop` 选项。"

#~ msgid ""
#~ "This will cause the population be "
#~ "sent to the monitor as well, and"
#~ " the monitor can then determine the"
#~ " best solution on the fly."
#~ msgstr "这将导致种群也被发送到监视器，监视器随后可以即时确定最佳解决方案。"

#~ msgid ""
#~ "Please note that when the population "
#~ "size is very large, is option can"
#~ " harm the overall performance."
#~ msgstr "请注意，当种群规模非常大时，这个选项可能会影响整体性能。"

#~ msgid "Getting Started"
#~ msgstr "开始"

#~ msgid "**base_algorithms:**"
#~ msgstr "**基础算法：**"

#~ msgid "**dim:**"
#~ msgstr "**目标数目**"

#~ msgid "**num_subpops:**"
#~ msgstr "**子种群的数量**"

#~ msgid "**random_subpop:**"
#~ msgstr "**随机化子种群：**"

#~ msgid "**key**"
#~ msgstr "**随机数生成器密钥**"

#~ msgid "State"
#~ msgstr "状态"

#~ msgid "**state**"
#~ msgstr "**状态**"

#~ msgid "population"
#~ msgstr "种群"

#~ msgid "state"
#~ msgstr "状态"

#~ msgid "**fitness**"
#~ msgstr "**适应度**"

#~ msgid "Ask the algorithm for the initial population"
#~ msgstr "向算法获取初始化种群"

#~ msgid ""
#~ "Override this method if you need "
#~ "to initialize the population in a "
#~ "special way. For example, Genetic "
#~ "Algorithm needs to evaluate the fitness"
#~ " of the initial population of size"
#~ " N, but after that, it only "
#~ "need to evaluate the fitness of "
#~ "the offspring of size M, and N "
#~ "!= M. Since JAX requires the "
#~ "function return to have static shape,"
#~ " we need to have two different "
#~ "functions, one is the normal `ask` "
#~ "and another is `init_ask`."
#~ msgstr ""
#~ "如果您需要以特殊的方式初始化种群，请重写此方法。例如，遗传算法需要评估大小为 N "
#~ "的初始种群的适应度，但在那之后，它只需要评估大小为 M 的后代的适应度，并且 N !="
#~ " M。由于 JAX 要求函数返回具有静态形状，因此我们需要有两个不同的函数，一个是常规的 "
#~ "`ask`，另一个是 `init_ask`。"

#~ msgid ""
#~ "Tell the algorithm the fitness of "
#~ "the initial population Use in pair "
#~ "with `init_ask`."
#~ msgstr "告诉算法初始种群的适应度并应该与`init_ask`函数配对使用。"

#~ msgid "**state: State**"
#~ msgstr "**state: State**"

#~ msgid "**population: N*D matrix**"
#~ msgstr "**population: 一个 N*D 的矩阵**"

#~ msgid "**mask: n*1 bool array**"
#~ msgstr "**mask: 一个 n*1 的布尔数组**"

#~ msgid "**fitness: N*M matrix**"
#~ msgstr "**fitness: 一个 N*M 的矩阵**"

#~ msgid "dict"
#~ msgstr "字典"

#~ msgid "**X**"
#~ msgstr "**X**"

#~ msgid "ndarray"
#~ msgstr "ndarray"

#~ msgid "**ref**"
#~ msgstr "**ref**"

#~ msgid "**num_sample**"
#~ msgstr "**样本数量**"

#~ msgid "**sample_method**"
#~ msgstr "**sample_method**"

#~ msgid "**full_fit_history**"
#~ msgstr "**full_fit_history**"

#~ msgid "**full_sol_history**"
#~ msgstr "**full_sol_history**"

#~ msgid "**topk**"
#~ msgstr ""

#~ msgid "**calc_pf**"
#~ msgstr ""

#~ msgid ""
#~ "Only affect Multi-objective optimization. "
#~ "Whether to keep updating the pareto "
#~ "front during the run. (The Archive) "
#~ "Default to False. Setting it to "
#~ "True will cause the monitor to "
#~ "maintain a pareto front of all the"
#~ " solutions with unlimited size, which "
#~ "may hurt performance."
#~ msgstr "只影响多目标优化。是否在运行过程中记录整个帕累托前沿。默认值为False。将其设置为True将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#~ msgid "**base_filename**"
#~ msgstr "**base_filename**"

#~ msgid "**out_dir**"
#~ msgstr "**out_dir**"

#~ msgid "**out_type**"
#~ msgstr "**out_type**"

#~ msgid "**batch_size**"
#~ msgstr "**batch_size**"

#~ msgid "**compression**"
#~ msgstr "**compression**"

#~ msgid "**population_name**"
#~ msgstr ""

#~ msgid "**fitness_name**"
#~ msgstr ""

#~ msgid "**to_host**"
#~ msgstr ""

#~ msgid "**fitness_only**"
#~ msgstr ""

#~ msgid "Standard Multi-objective Monitor"
#~ msgstr "标准多目标监视器"

#~ msgid ""
#~ "Standard multi-objective monitor Used "
#~ "for multi-objective workflow, can "
#~ "monitor fitness and record the pareto"
#~ " front."
#~ msgstr "标准多目标监视器，用于多目标工作流，可以监控适应度并记录帕累托前沿。"

#~ msgid "**record_pf**"
#~ msgstr "**record_pf**"

#~ msgid ""
#~ "Whether to record the pareto front "
#~ "during the run. Default to False. "
#~ "Setting it to True will cause the"
#~ " monitor to maintain a pareto front"
#~ " of all the solutions with unlimited"
#~ " size, which may hurt performance."
#~ msgstr "是否在运行过程中记录帕累托前沿。默认值为假（False）。将其设置为真（True）将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#~ msgid "**record_fit_history**"
#~ msgstr "**record_fit_history**"

#~ msgid "Standard Single-objective Monitor"
#~ msgstr "标准单目标监视器"

#~ msgid ""
#~ "Standard single-objective monitor Used "
#~ "for single-objective workflow, can "
#~ "monitor fitness and the population."
#~ msgstr "标准单目标监控器 用于单目标工作流，可以监控适应度和种群。"

#~ msgid "**record_topk**"
#~ msgstr "**record_topk**"

#~ msgid ""
#~ "Control how many elite solutions are "
#~ "recorded. Default is 1, which will "
#~ "record the best individual."
#~ msgstr "控制录制多少精英解决方案。默认为1，它将记录最好的个体。"

#~ msgid "Contruct a brax-based problem"
#~ msgstr "构造一个基于Brax的问题"

#~ msgid "**policy**"
#~ msgstr "**策略**"

#~ msgid "**env_name**"
#~ msgstr "**env_name**"

#~ msgid ""
#~ "The number of brax environments to "
#~ "run in parallel. Usually this should "
#~ "match the population size at the "
#~ "algorithm side."
#~ msgstr "要并行运行的BRAX环境的数量。通常，这应该与算法端的种群大小相匹配。"

#~ msgid "**cap_episode**"
#~ msgstr "**cap_episode**"

#~ msgid "**backend**"
#~ msgstr "**后端**"

#~ msgid "**num_workers**"
#~ msgstr "**num_workers**"

#~ msgid "**env_options**"
#~ msgstr "**env_options**"

#~ msgid "**env_creator**"
#~ msgstr "**env_creator**"

#~ msgid "**mo_keys**"
#~ msgstr "**mo_keys**"

#~ msgid "**controller_options**"
#~ msgstr "**控制器选项**"

#~ msgid "**worker_options**"
#~ msgstr "**工作者选项**"

#~ msgid "**weights**"
#~ msgstr "**权重**"

#~ msgid "**ale_render_mode**"
#~ msgstr "**ale_render_mode**"

#~ msgid "**dataset**"
#~ msgstr "**状态**"

#~ msgid "**loss_func**"
#~ msgstr ""

#~ msgid "**split**"
#~ msgstr "**策略**"

#~ msgid "**operations**"
#~ msgstr "**options**"

#~ msgid "**datadir**"
#~ msgstr "**out_dir**"

#~ msgid "**seed**"
#~ msgstr "**维度**"

#~ msgid "**try_gcs**"
#~ msgstr ""

#~ msgid "**d**"
#~ msgstr "**维度**"

#~ msgid "**m**"
#~ msgstr "**目标数目**"

#~ msgid "**ref_num**"
#~ msgstr "**ref_num**"

#~ msgid "Ray-based Distributed Workflow"
#~ msgstr "基于Ray的分布式工作流"

#~ msgid "Create a distributed workflow"
#~ msgstr "创建分布式工作流"

#~ msgid ""
#~ "Distributed workflow can distribute the "
#~ "workflow to different nodes, it will "
#~ "create num_workers copies of the "
#~ "workflows with the same seed, and "
#~ "at each step each workflow only "
#~ "evaluate part of the population, then"
#~ " pass the fitness to other nodes "
#~ "to recreate the whole fitness array."
#~ msgstr "分布式工作流能够将工作流程分布到不同的节点上。它会使用相同的随机种子创建num_workers个相同工作流程副本，并且在每一步中，每个工作流程仅评估种群的一部分，然后将适应度值传递给其他节点以重建整个适应度数组。这样，通过各节点间的协作，实现大规模并行计算和优化过程的高效执行。"

#~ msgid "sol_transforms and fit_transforms are applied at each node,"
#~ msgstr "候选解变换和适应度变换，这个变换在每个工作节点上应用。"

#~ msgid "**algorithm**"
#~ msgstr "**算法**"

#~ msgid "**problem**"
#~ msgstr "**问题**"

#~ msgid "Number of workers."
#~ msgstr "工作者的数目。"

#~ msgid "**opt_direction**"
#~ msgstr "**opt_direction**"

#~ msgid "**options**"
#~ msgstr "**options**"

#~ msgid "The runtime options of the worker actor."
#~ msgstr "工作者（worker）actor的运行时选项。"

#~ msgid "**sol_transforms:**"
#~ msgstr "**pop_transform:**"

#~ msgid "Population transform, this transform is applied at each worker node."
#~ msgstr "Population transform，这种转换会被应用到每一个worker节点。"

#~ msgid "**fit_transforms:**"
#~ msgstr ""

#~ msgid "Fitness transform, this transform is applied at each worker node."
#~ msgstr "适应度变换，这个变换在每个工作节点上应用。"

#~ msgid "Non-jit Workflow"
#~ msgstr ""

#~ msgid "**monitor**"
#~ msgstr "**监控器**"

#~ msgid "Optional monitor."
#~ msgstr "可选监控器。"

#~ msgid "**sol_transforms**"
#~ msgstr ""

#~ msgid "**fit_transforms**"
#~ msgstr ""

#~ msgid "Sample the algorithm but don't change it's state"
#~ msgstr "对算法采样但不改变它的状态"

#~ msgid "**sol_transform**"
#~ msgstr ""

#~ msgid "**jit_problem**"
#~ msgstr "**jit_problem**"

#~ msgid "If the problem can be jit compiled by JAX or not. Default to True."
#~ msgstr "问题是否可以通过JAX进行jit编译。默认为True。"

#~ msgid "**num_objectives**"
#~ msgstr "**num_objectives**"

#~ msgid ""
#~ "Number of objectives. When the problem"
#~ " can be jit compiled, this field "
#~ "is not needed. When the problem "
#~ "cannot be jit compiled, this field "
#~ "should be set, if not, default to"
#~ " 1."
#~ msgstr "目标数量。当问题可以被 JIT（即时编译）时，这个字段不是必需的。当问题不能被 JIT 编译时，应设置这个字段，如果没有设置，默认为 1。"

#~ msgid ""
#~ "Enable the distributed workflow to run"
#~ " across multiple nodes. To use jax's"
#~ " distribution ability, one need to "
#~ "run the same program on all nodes"
#~ " with different parameters in "
#~ "`jax.distributed.initialize`."
#~ msgstr ""
#~ "启用分布式工作流在多个节点上运行。要使用 JAX 的分布式处理能力，需要在所有节点上运行相同的程序，并在 "
#~ "jax.distributed.initialize 中使用不同的参数。"

#~ msgid "The sharded state, distributed amoung all nodes."
#~ msgstr "分布在所有节点上的分片状态。"

#~ msgid "Enable the workflow to run on multiple local devices."
#~ msgstr "允许workflow利用单台机器的多个设备（GPU）。"

#~ msgid "**devices**"
#~ msgstr "**设备**"

#~ msgid "A list of devices. If set to None, all local devices will be used."
#~ msgstr "设备列表。如果设置为“None”，将使用所有本地设备。"

#~ msgid "The sharded state, distributed amoung all devices."
#~ msgstr "分布在所有设备上的分片状态。"

#~ msgid ""
#~ "In EvoX, we almost guarantee that "
#~ "all low-level components are jit-"
#~ "compiled (all operators), and high-level"
#~ " components (`Workflow`) can have both "
#~ "jit-compiled variants (e.g. {doc}`StdWorkflow"
#~ " </api/workflows/standard>`) and non-jit-"
#~ "compiled variants (e.g. {doc}`StdWorkflow "
#~ "</api/workflows/non_jit>`)."
#~ msgstr ""

#~ msgid ""
#~ "This time, we can access the "
#~ "minimum fitness achieved through the "
#~ "`monitor`."
#~ msgstr "这次，我们可以通过 `monitor` 访问达到的最小适应度。"

#~ msgid ""
#~ "Now create brax-based problem. The "
#~ "`batch_size` defines how many environment "
#~ "in a single batch,  and `cap_episode`"
#~ " controls when to truncate the "
#~ "episode."
#~ msgstr "现在创建基于Brax的问题。`batch_size` 定义了单个批次中有多少个环境，而 `cap_episode` 控制了何时截断一个情节。"

#~ msgid ""
#~ "In this case, we set `batch_size` "
#~ "to 4096, which is the same as "
#~ "our population size. This means the "
#~ "whole population will be evaluated in"
#~ " a single pass!"
#~ msgstr "在这种情况下，我们将 `batch_size` 设置为4096，这与我们的种群大小相同。这意味着整个种群将在一次传递中被评估！"

#~ msgid ""
#~ "<svg version=\"1.1\" width=\"1.5em\" "
#~ "height=\"1.5em\" class=\"sd-octicon sd-"
#~ "octicon-mortar-board\" viewBox=\"0 0 24 "
#~ "24\" aria-hidden=\"true\"><path fill-"
#~ "rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 "
#~ "00-.584 0L.458 6.81a.75.75 0 000 "
#~ "1.38L4.25 9.793v3.803a2.901 2.901 0 "
#~ "00-1.327.757c-.579.58-.923 1.41-.923 2.43v4.5c0 "
#~ ".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149"
#~ " 1.09.288 1.925.288s1.477-.14 "
#~ "1.925-.288c.223-.075.396-.15.52-.213a2.11 2.11 0 "
#~ "00.21-.117A.762.762 0 008 "
#~ "21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 0 "
#~ "00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 "
#~ "0l5.208-2.2v4.003a2.552 2.552 0 01-.079.085 "
#~ "4.057 4.057 0 01-.849.65c-.826.488-2.255 "
#~ "1.021-4.572 1.021-.612 0-1.162-.037-1.654-.1a.75.75 "
#~ "0 00-.192 1.487c.56.072 1.173.113 1.846.113"
#~ " 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64"
#~ " 1.163-.896a2.84 2.84 0 00.392-.482h.001A.75.75"
#~ " 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
#~ "000-1.382l-11.25-4.75zM5 15c-.377 "
#~ "0-.745.141-1.017.413-.265.265-.483.7-.483 "
#~ "1.368v4.022c.299.105.797.228 1.5.228s1.201-.123 "
#~ "1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 1.431 0"
#~ " 005 15zm7-3.564L2.678 7.5 12 3.564 "
#~ "21.322 7.5 12 11.436z\"></path></svg> "
#~ "Developer Guide"
#~ msgstr ""
#~ "<svg version=\"1.1\" width=\"1.5em\" "
#~ "height=\"1.5em\" class=\"sd-octicon sd-"
#~ "octicon-mortar-board\" viewBox=\"0 0 24 "
#~ "24\" aria-hidden=\"true\"><path fill-"
#~ "rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 "
#~ "00-.584 0L.458 6.81a.75.75 0 000 "
#~ "1.38L4.25 9.793v3.803a2.901 2.901 0 "
#~ "00-1.327.757c-.579.58-.923 1.41-.923 2.43v4.5c0 "
#~ ".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149"
#~ " 1.09.288 1.925.288s1.477-.14 "
#~ "1.925-.288c.223-.075.396-.15.52-.213a2.11 2.11 0 "
#~ "00.21-.117A.762.762 0 008 "
#~ "21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 0 "
#~ "00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 "
#~ "0l5.208-2.2v4.003a2.552 2.552 0 01-.079.085 "
#~ "4.057 4.057 0 01-.849.65c-.826.488-2.255 "
#~ "1.021-4.572 1.021-.612 0-1.162-.037-1.654-.1a.75.75 "
#~ "0 00-.192 1.487c.56.072 1.173.113 1.846.113"
#~ " 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64"
#~ " 1.163-.896a2.84 2.84 0 00.392-.482h.001A.75.75"
#~ " 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
#~ "000-1.382l-11.25-4.75zM5 15c-.377 "
#~ "0-.745.141-1.017.413-.265.265-.483.7-.483 "
#~ "1.368v4.022c.299.105.797.228 1.5.228s1.201-.123 "
#~ "1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 1.431 0"
#~ " 005 15zm7-3.564L2.678 7.5 12 3.564 "
#~ "21.322 7.5 12 11.436z\"></path></svg> 开发者教程"

