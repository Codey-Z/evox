# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-14 17:17+0800\n"
"PO-Revision-Date: 2024-11-05 08:25+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/projects/evox/evox/zh_Hans/>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../source/apidocs/evox/evox.md:1
msgid "{py:mod}`evox`"
msgstr "{py:mod}`evox`"

#: ../../source/apidocs/evox/evox.algorithms.md:10
#: ../../source/apidocs/evox/evox.md:10
#: ../../source/apidocs/evox/evox.operators.md:10
#: ../../source/apidocs/evox/evox.problems.md:10
msgid "Subpackages"
msgstr "子包"

#: ../../source/apidocs/evox/evox.algorithms.md:1
msgid "{py:mod}`evox.algorithms`"
msgstr "{py:mod}`evox.algorithms`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:31
#: ../../source/apidocs/evox/evox.algorithms.md:22
#: ../../source/apidocs/evox/evox.algorithms.mo.md:21
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:26
#: ../../source/apidocs/evox/evox.core.md:22
#: ../../source/apidocs/evox/evox.metrics.md:21
#: ../../source/apidocs/evox/evox.operators.crossover.md:21
#: ../../source/apidocs/evox/evox.operators.md:22
#: ../../source/apidocs/evox/evox.operators.mutation.md:19
#: ../../source/apidocs/evox/evox.operators.sampling.md:21
#: ../../source/apidocs/evox/evox.operators.selection.md:22
#: ../../source/apidocs/evox/evox.problems.numerical.md:21
#: ../../source/apidocs/evox/evox.utils.md:21
#: ../../source/apidocs/evox/evox.workflows.md:20
msgid "Package Contents"
msgstr "软件包内容"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:26
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:33
#: ../../source/apidocs/evox/evox.algorithms.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.md:23
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:112
#: ../../source/apidocs/evox/evox.core.jit_util.md:46
#: ../../source/apidocs/evox/evox.core.md:24
#: ../../source/apidocs/evox/evox.core.module.md:98
#: ../../source/apidocs/evox/evox.metrics.md:23
#: ../../source/apidocs/evox/evox.operators.crossover.md:23
#: ../../source/apidocs/evox/evox.operators.md:24
#: ../../source/apidocs/evox/evox.operators.mutation.md:21
#: ../../source/apidocs/evox/evox.operators.sampling.md:23
#: ../../source/apidocs/evox/evox.operators.selection.md:24
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.md:23
#: ../../source/apidocs/evox/evox.utils.control_flow.md:12
#: ../../source/apidocs/evox/evox.utils.md:23
#: ../../source/apidocs/evox/evox.workflows.md:22
msgid "Data"
msgstr "数据"

#: ../../source/apidocs/evox/evox.algorithms.md:30
msgid "{py:obj}`__all__ <evox.algorithms.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:52
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:38
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:48
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:45
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:28
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:24
#: ../../source/apidocs/evox/evox.algorithms.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:40
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:168
#: ../../source/apidocs/evox/evox.core.components.md:36
#: ../../source/apidocs/evox/evox.core.jit_util.md:58
#: ../../source/apidocs/evox/evox.core.md:36
#: ../../source/apidocs/evox/evox.core.module.md:162
#: ../../source/apidocs/evox/evox.metrics.gd.md:24
#: ../../source/apidocs/evox/evox.metrics.hv.md:24
#: ../../source/apidocs/evox/evox.metrics.igd.md:24
#: ../../source/apidocs/evox/evox.metrics.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:36
#: ../../source/apidocs/evox/evox.operators.crossover.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:24
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:24
#: ../../source/apidocs/evox/evox.operators.md:36
#: ../../source/apidocs/evox/evox.operators.mutation.md:33
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:28
#: ../../source/apidocs/evox/evox.operators.sampling.md:35
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:24
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:24
#: ../../source/apidocs/evox/evox.operators.selection.md:36
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:68
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:28
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:28
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:32
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:36
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:80
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:42
#: ../../source/apidocs/evox/evox.problems.numerical.md:35
#: ../../source/apidocs/evox/evox.utils.control_flow.md:24
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:76
#: ../../source/apidocs/evox/evox.utils.md:35
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:24
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:40
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:44
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:24
#: ../../source/apidocs/evox/evox.workflows.md:34
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:26
msgid "API"
msgstr "API"

#: ../../source/apidocs/evox/evox.algorithms.md:42
msgid ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."
msgstr ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:1
msgid "{py:mod}`evox.algorithms.de_variants`"
msgstr "{py:mod}`evox.algorithms.de_variants`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:10
#: ../../source/apidocs/evox/evox.core.md:10
#: ../../source/apidocs/evox/evox.metrics.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.md:10
#: ../../source/apidocs/evox/evox.operators.selection.md:10
#: ../../source/apidocs/evox/evox.problems.md:20
#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.md:10
#: ../../source/apidocs/evox/evox.utils.md:10
#: ../../source/apidocs/evox/evox.vis_tools.md:10
#: ../../source/apidocs/evox/evox.workflows.md:10
#, fuzzy
msgid "Submodules"
msgstr "模块类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:32
msgid "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:44
msgid "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"
msgstr "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:1
msgid "{py:mod}`evox.algorithms.de_variants.code`"
msgstr "{py:mod}`evox.algorithms.de_variants.code`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:10
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:10
#: ../../source/apidocs/evox/evox.core.components.md:10
#: ../../source/apidocs/evox/evox.core.jit_util.md:10
#: ../../source/apidocs/evox/evox.core.module.md:10
#: ../../source/apidocs/evox/evox.metrics.gd.md:10
#: ../../source/apidocs/evox/evox.metrics.hv.md:10
#: ../../source/apidocs/evox/evox.metrics.igd.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:10
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:10
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:10
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:10
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:10
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:10
#: ../../source/apidocs/evox/evox.utils.control_flow.md:10
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:10
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:10
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:10
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:10
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:10
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:10
#, fuzzy
msgid "Module Contents"
msgstr "模块类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:12
#: ../../source/apidocs/evox/evox.core.components.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:12
#: ../../source/apidocs/evox/evox.core.module.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:12
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:12
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:12
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:12
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:12
#, fuzzy
msgid "Classes"
msgstr "核心类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:18
msgid "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"
msgstr "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"

#: ../../../src/evox/algorithms/de_variants/code.py:20
#: ../../../src/evox/algorithms/de_variants/code.py:111
#, fuzzy
msgid "The implementation of CoDE algorithm."
msgstr "CoDE算法实现"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:38
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.code.current2rand_1>`"
msgstr ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.code.current2rand_1>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:42
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.code.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.code.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:46
msgid ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.de_variants.code.current2pbest_1_bin>`"
msgstr ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.de_variants.code.current2pbest_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:58
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:54
msgid "[0, 0, 1, 0]"
msgstr "[0, 0, 1, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:68
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:64
msgid "[0, 0, 2, 0]"
msgstr "[0, 0, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:78
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:84
msgid "[0, 0, 1, 2]"
msgstr "[0, 0, 1, 2]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:88
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:74
msgid "[0, 1, 2, 0]"
msgstr "[0, 1, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:98
msgid "[3, 2, 1, 0]"
msgstr "[3, 2, 1, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:108
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:94
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:34
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:58
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:49
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:30
msgid "Bases: {py:obj}`evox.core.Algorithm`"
msgstr "基础: {py:obj}`evox.core.Algorithm`"

#: ../../../src/evox/algorithms/de_variants/code.py:113
msgid ""
"Reference: Wang Y, Cai Z, Zhang Q. Differential evolution with composite "
"trial vector generation strategies and control parameters[J]. IEEE "
"transactions on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"参考文献: Wang Y, Cai Z, Zhang Q. 使用复合试验向量生成策略和控制参数的差分进化[J]. IEEE 进化计算交易, 2011, "
"15(1): 55-66."

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:113
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:99
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:39
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:63
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:54
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:35
#: ../../source/apidocs/evox/evox.core.components.md:47
#: ../../source/apidocs/evox/evox.core.components.md:88
#: ../../source/apidocs/evox/evox.core.components.md:112
#: ../../source/apidocs/evox/evox.core.components.md:144
#: ../../source/apidocs/evox/evox.core.module.md:228
#: ../../source/apidocs/evox/evox.core.module.md:430
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:110
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:43
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:68
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:100
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:102
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:72
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:91
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:122
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:153
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:184
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:215
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:246
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:277
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:35
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:53
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:115
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:139
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:35
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:63
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:35
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:52
msgid "Initialization"
msgstr "初始化"

#: ../../../src/evox/algorithms/de_variants/code.py:117
#, fuzzy
msgid "Initialize the CoDE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.exv.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md
msgid "Parameters"
msgstr "参数"

#: ../../../src/evox/algorithms/de_variants/code.py:119
#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
#: ../../../src/evox/algorithms/de_variants/sade.py:105
#: ../../../src/evox/algorithms/de_variants/shade.py:41
#: ../../../src/evox/algorithms/es_variants/ars.py:41
#: ../../../src/evox/algorithms/es_variants/asebo.py:41
#: ../../../src/evox/algorithms/es_variants/des.py:41
#: ../../../src/evox/algorithms/es_variants/esmc.py:41
#: ../../../src/evox/algorithms/es_variants/guided_es.py:41
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:41
#: ../../../src/evox/algorithms/es_variants/open_es.py:41
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:41
#: ../../../src/evox/algorithms/es_variants/snes.py:41
#: ../../../src/evox/algorithms/mo/moead.py:60
#: ../../../src/evox/algorithms/mo/nsga2.py:41
#: ../../../src/evox/algorithms/mo/rvea.py:41
#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:41
#: ../../../src/evox/algorithms/pso_variants/pso.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
#, fuzzy
msgid "The size of the population."
msgstr "种群大小。"

#: ../../../src/evox/algorithms/de_variants/code.py:120
#: ../../../src/evox/algorithms/de_variants/de.py:42
#: ../../../src/evox/algorithms/de_variants/jade.py:42
#: ../../../src/evox/algorithms/de_variants/sade.py:106
#: ../../../src/evox/algorithms/de_variants/shade.py:42
msgid "The lower bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:121
#: ../../../src/evox/algorithms/de_variants/de.py:43
#: ../../../src/evox/algorithms/de_variants/jade.py:43
#: ../../../src/evox/algorithms/de_variants/sade.py:107
#: ../../../src/evox/algorithms/de_variants/shade.py:43
msgid "The upper bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:122
#, fuzzy
msgid "The number of differential padding vectors to use. Defaults to 5."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/de_variants/code.py:123
msgid ""
"A tensor of control parameter pairs for the algorithm. Defaults to a "
"predefined tensor."
msgstr "算法的控制参数对的张量。默认为预定义的张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:124
msgid ""
"A boolean indicating whether to replace individuals in the population. "
"Defaults to False."
msgstr "一个布尔值，指示是否替换种群中的个体。默认为 False。"

#: ../../../src/evox/algorithms/de_variants/code.py:125
#: ../../../src/evox/algorithms/de_variants/de.py:50
#: ../../../src/evox/algorithms/de_variants/ode.py:50
msgid "The device to use for tensor computations. Defaults to None."
msgstr "用于张量计算的设备。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/code.py:124
#, fuzzy
msgid "Perform one iteration of the CoDE algorithm."
msgstr "执行CoDE算法的一次迭代。"

#: ../../../src/evox/algorithms/de_variants/code.py:126
msgid "This step is composed of the following steps:"
msgstr "此步骤由以下步骤组成："

#: ../../../src/evox/algorithms/de_variants/code.py:127
msgid "Generate trial vectors using the differential sum."
msgstr "使用微分和生成试验向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:128
msgid "Apply crossover to generate a new vector."
msgstr "应用交叉生成一个新向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:129
msgid "Apply mutation to generate a new vector."
msgstr "应用变异以生成新向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:130
#, fuzzy
msgid "Update the population and fitness values."
msgstr "给出用于评估的候选种群。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:1
msgid "{py:mod}`evox.algorithms.de_variants.de`"
msgstr "{py:mod}`evox.algorithms.de_variants.de`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:18
msgid "{py:obj}`DE <evox.algorithms.de_variants.de.DE>`"
msgstr "{py:obj}`DE <evox.algorithms.de_variants.de.DE>`"

#: ../../../src/evox/algorithms/de_variants/de.py:20
#: ../../../src/evox/algorithms/de_variants/de.py:33
msgid "Differential Evolution (DE) algorithm for optimization."
msgstr "差分进化（DE）算法用于优化。"

#: ../../../src/evox/algorithms/de_variants/de.py:37
msgid ""
"`__init__`: Initializes the DE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`: 使用给定的参数初始化 DE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/de.py:38
#: ../../../src/evox/algorithms/de_variants/jade.py:38
#: ../../../src/evox/algorithms/de_variants/ode.py:38
msgid ""
"`init_step`: Performs the initial evaluation of the population's fitness and"
" proceeds to the first optimization step."
msgstr "`init_step`: 执行种群适应度的初始评估，并进入第一次优化步骤。"

#: ../../../src/evox/algorithms/de_variants/de.py:39
msgid ""
"`step`: Executes a single optimization step of the DE algorithm, involving "
"mutation, crossover, and selection processes."
msgstr "`step`：执行DE算法的单个优化步骤，包括变异、交叉和选择过程。"

#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class. It is expected"
" to be provided by the `Problem` class or another external component."
msgstr "请注意，`evaluate` 方法在这个类中未定义。它预计由 `Problem` 类或其他外部组件提供。"

#: ../../../src/evox/algorithms/de_variants/de.py:39
#, fuzzy
msgid "Initialize the DE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/de.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:44
#, fuzzy
msgid ""
"The base vector type used in mutation. Either \"best\" or \"rand\". Defaults"
" to \"rand\"."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/de.py:45
#: ../../../src/evox/algorithms/de_variants/jade.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:45
msgid ""
"The number of difference vectors used in mutation. Must be at least 1 and "
"less than half of the population size. Defaults to 1."
msgstr "在变异中使用的差异向量的数量。必须至少为 1 且小于种群大小的一半。默认为 1。"

#: ../../../src/evox/algorithms/de_variants/de.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor. Defaults to 0.5."
msgstr "施加于差异向量的差异权重 (F)。可以是浮点数或张量。默认为 0.5。"

#: ../../../src/evox/algorithms/de_variants/de.py:47
msgid "The crossover probability (CR). Defaults to 0.9."
msgstr "交叉概率（CR）。默认为 0.9。"

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:45
#, fuzzy
msgid ""
"The mean for initializing the population with a normal distribution. "
"Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/de.py:49
#: ../../../src/evox/algorithms/de_variants/jade.py:46
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Defaults to None."
msgstr "用于用正态分布初始化种群的标准差。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/de.py:46
#: ../../../src/evox/algorithms/de_variants/jade.py:46
#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"Perform the initial evaluation of the population's fitness and proceed to "
"the first optimization step."
msgstr "执行种群适应度的初步评估，并进入第一个优化步骤。"

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:48
#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"This method evaluates the fitness of the initial population and then calls "
"the `step` method to perform the first optimization iteration."
msgstr "此方法评估初始种群的适应度，然后调用 `step` 方法进行第一次优化迭代。"

#: ../../../src/evox/algorithms/de_variants/de.py:54
#, fuzzy
msgid "Execute a single optimization step of the DE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/de.py:56
#: ../../../src/evox/algorithms/de_variants/jade.py:56
#: ../../../src/evox/algorithms/de_variants/ode.py:56
#: ../../../src/evox/algorithms/de_variants/sade.py:128
#: ../../../src/evox/algorithms/de_variants/shade.py:48
msgid "This involves the following sub-steps:"
msgstr "这涉及以下子步骤："

#: ../../../src/evox/algorithms/de_variants/de.py:57
#: ../../../src/evox/algorithms/de_variants/ode.py:57
msgid ""
"Mutation: Generate mutant vectors based on the specified base vector "
"strategy (`best` or `rand`) and the number of difference vectors."
msgstr "Mutation: 生成基准向量策略 (`best` 或 `rand`) 和差异向量数量的基础上，根据这些信息生成变异向量"

#: ../../../src/evox/algorithms/de_variants/de.py:58
#: ../../../src/evox/algorithms/de_variants/ode.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability."
msgstr "交叉：根据交叉概率，在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/de_variants/de.py:59
#: ../../../src/evox/algorithms/de_variants/jade.py:59
#: ../../../src/evox/algorithms/de_variants/ode.py:59
msgid ""
"Selection: Evaluate the fitness of the new population and select the better "
"individuals between the current and new populations."
msgstr "选择：评估新种群的适应度，并在当前种群和新种群之间选择更优的个体。"

#: ../../../src/evox/algorithms/de_variants/de.py:61
#: ../../../src/evox/algorithms/de_variants/ode.py:62
msgid ""
"The method ensures that all new population vectors are clamped within the "
"specified bounds."
msgstr "这个方法确保新种群向量都会被截断在指定范围内。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.jade`"
msgstr "{py:mod}`evox.algorithms.de_variants.jade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:18
msgid "{py:obj}`JaDE <evox.algorithms.de_variants.jade.JaDE>`"
msgstr "{py:obj}`JaDE <evox.algorithms.de_variants.jade.JaDE>`"

#: ../../../src/evox/algorithms/de_variants/jade.py:20
#: ../../../src/evox/algorithms/de_variants/jade.py:33
msgid "Adaptive Differential Evolution (JaDE) algorithm for optimization."
msgstr "自适应差分进化算法 JaDE，用于优化任务。"

#: ../../../src/evox/algorithms/de_variants/jade.py:37
msgid ""
"`__init__`: Initializes the JaDE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：用给定的参数初始化 JaDE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid ""
"`step`: Executes a single optimization step of the JaDE algorithm, involving"
" mutation, crossover, selection, and adaptation of strategy parameters."
msgstr "`step`: 执行 JaDE 算法的单个优化步骤，涉及突变、交叉、选择和策略参数的适应性。"

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid "Initialize the JaDE algorithm with the given parameters."
msgstr "根据给定的参数初始化 JaDE 算法。"

#: ../../../src/evox/algorithms/de_variants/jade.py:47
#: ../../../src/evox/algorithms/de_variants/sade.py:110
#: ../../../src/evox/algorithms/de_variants/shade.py:45
msgid ""
"The device to use for tensor computations (e.g., \"cpu\" or \"cuda\"). "
"Defaults to None."
msgstr "用于张量计算的设备（例如，“cpu”或“cuda”）。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/jade.py:48
msgid ""
"The learning rate for updating the adaptive parameters F_u and CR_u. "
"Defaults to 0.1."
msgstr "自适应参数 F_u 和 CR_u 更新的学习率。默认值为 0.1。"

#: ../../../src/evox/algorithms/de_variants/jade.py:54
#, fuzzy
msgid "Execute a single optimization step of the JaDE algorithm."
msgstr "创建一个基础算法的列表。"

#: ../../../src/evox/algorithms/de_variants/jade.py:57
msgid ""
"Mutation: Generate mutant vectors by combining difference vectors and "
"adapting the mutation factor F."
msgstr "变异：通过结合差异向量并调整变异因子 F 来生成突变向量。"

#: ../../../src/evox/algorithms/de_variants/jade.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability CR."
msgstr "交叉：根据交叉概率 CR 在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/de_variants/jade.py:60
msgid ""
"Adaptation: Update the adaptive parameters F_u and CR_u based on the "
"successful mutations."
msgstr "自适应参数的更新：根据成功的突变来更新参数F_u和CR_u。"

#: ../../../src/evox/algorithms/de_variants/jade.py:62
#, fuzzy
msgid "Select p-best vectors from the population for mutation."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/algorithms/de_variants/jade.py:64
msgid ""
"Fraction of the population to consider as top-p best. Must be between 0 and "
"1."
msgstr "考虑为 top-p 最佳的群体比例。必须在 0 和 1 之间。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
msgid "Returns"
msgstr "返回值"

#: ../../../src/evox/algorithms/de_variants/jade.py:65
msgid "A tensor containing selected p-best vectors."
msgstr "包含选定的 p-best 向量的张量。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:1
msgid "{py:mod}`evox.algorithms.de_variants.ode`"
msgstr "{py:mod}`evox.algorithms.de_variants.ode`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:18
msgid "{py:obj}`ODE <evox.algorithms.de_variants.ode.ODE>`"
msgstr "{py:obj}`ODE <evox.algorithms.de_variants.ode.ODE>`"

#: ../../../src/evox/algorithms/de_variants/ode.py:20
#: ../../../src/evox/algorithms/de_variants/ode.py:33
msgid ""
"Opposition-based Differential Evolution (ODE) algorithm for optimization."
msgstr "反对基差差分进化 (ODE) 算法用于优化。"

#: ../../../src/evox/algorithms/de_variants/ode.py:37
msgid ""
"`__init__`: Initializes the ODE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：使用给定的参数初始化 ODE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"`step`: Executes a single optimization step of the ODE algorithm, involving "
"mutation, crossover, selection, and opposition-based mechanisms."
msgstr "`step`: 执行ODE算法的单个优化步骤，包括变异、交叉、选择和基于对抗的机制。"

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"Initialize the Opposition-based Differential Evolution (ODE) algorithm with "
"the given parameters."
msgstr "使用给定的参数初始化基于对抗的差分进化（ODE）算法。"

#: ../../../src/evox/algorithms/de_variants/ode.py:42
#: ../../../src/evox/algorithms/pso_variants/clpso.py:42
#: ../../../src/evox/algorithms/pso_variants/cso.py:42
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:42
msgid "The lower bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/ode.py:43
#: ../../../src/evox/algorithms/pso_variants/clpso.py:43
#: ../../../src/evox/algorithms/pso_variants/cso.py:43
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:43
#: ../../../src/evox/algorithms/pso_variants/pso.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:43
msgid "The upper bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor of shape [num_difference_vectors]. Defaults to 0.5."
msgstr "应用于差异向量的差异权重 (F)。可以是一个浮点数或形状为 [num_difference_vectors] 的张量。默认值为 0.5。"

#: ../../../src/evox/algorithms/de_variants/ode.py:47
msgid "The crossover probability (CR). Must be in (0, 1]. Defaults to 0.9."
msgstr "交叉概率（CR）。必须在（0，1]之间。默认值为0.9。"

#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"The mean for initializing the population with a normal distribution. Must be"
" provided with stdev if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的均值。如果使用，则必须提供标准差（stdev）。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/ode.py:49
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Must be provided with mean if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的标准差。若使用，则必须提供均值。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/ode.py:54
#, fuzzy
msgid "Execute a single optimization step of the ODE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/ode.py:60
msgid ""
"Opposition-Based Mechanism: Generate opposition-based population, evaluate "
"their fitness, and perform selection to potentially replace current "
"individuals with their opposites if they are better."
msgstr "对立机制：生成对立种群，评估它们的适应度，并进行选择，以便在它们更好的情况下，潜在地用它们的对立个体替换当前个体。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.sade`"
msgstr "{py:mod}`evox.algorithms.de_variants.sade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:18
msgid "{py:obj}`SaDE <evox.algorithms.de_variants.sade.SaDE>`"
msgstr "{py:obj}`SaDE <evox.algorithms.de_variants.sade.SaDE>`"

#: ../../../src/evox/algorithms/de_variants/sade.py:20
#: ../../../src/evox/algorithms/de_variants/sade.py:97
#, fuzzy
msgid "The implementation of SaDE algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.sade.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.de_variants.sade.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.sade.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.de_variants.sade.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:38
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.sade.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.sade.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:42
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.sade.current2rand_1>`"
msgstr "**当前随机1 <evox.algorithms.de_variants.sade.current2rand_1>**"

#: ../../../src/evox/algorithms/de_variants/sade.py:99
msgid ""
"Reference: Qin A K, Huang V L, Suganthan P N. Differential evolution "
"algorithm with strategy adaptation for global numerical optimization[J]. "
"IEEE transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"参考：Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm with "
"strategy adaptation for global numerical optimization[J]. IEEE transactions "
"on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../../src/evox/algorithms/de_variants/sade.py:103
#, fuzzy
msgid "Initialize the SaDE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/sade.py:108
#: ../../../src/evox/algorithms/de_variants/shade.py:44
#, fuzzy
msgid "The number of differential padding vectors to use. Defaults to 9."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/de_variants/sade.py:109
#, fuzzy
msgid "The size of memory. Defaults to 50."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/sade.py:126
#, fuzzy
msgid "Execute a single optimization step of the SaDE algorithm."
msgstr "创建一个基础算法的列表。"

#: ../../../src/evox/algorithms/de_variants/sade.py:129
msgid "Generate new population using differential evolution."
msgstr "使用差分进化生成新种群。"

#: ../../../src/evox/algorithms/de_variants/sade.py:130
#, fuzzy
msgid "Evaluate the fitness of the new population."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/algorithms/de_variants/sade.py:131
msgid "Update the best individual and best fitness."
msgstr "更新最佳个体和最佳适应度。"

#: ../../../src/evox/algorithms/de_variants/sade.py:132
msgid "Update the success and failure memory."
msgstr "更新成功和失败的记忆。"

#: ../../../src/evox/algorithms/de_variants/sade.py:133
msgid "Update the CR memory."
msgstr "更新 CR 内存。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.shade`"
msgstr "{py:mod}`evox.algorithms.de_variants.shade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:18
msgid "{py:obj}`SHADE <evox.algorithms.de_variants.shade.SHADE>`"
msgstr "{py:obj}`SHADE <evox.algorithms.de_variants.shade.SHADE>`"

#: ../../../src/evox/algorithms/de_variants/shade.py:20
#: ../../../src/evox/algorithms/de_variants/shade.py:33
#, fuzzy
msgid "The implementation of SHADE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/shade.py:35
msgid ""
"Reference: Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"参考文献: Tanabe R, Fukunaga A. Success-history based parameter adaptation for "
"differential evolution[C]//2013 IEEE congress on evolutionary computation. "
"IEEE, 2013: 71-78."

#: ../../../src/evox/algorithms/de_variants/shade.py:39
#, fuzzy
msgid "Initialize the SHADE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/shade.py:46
#, fuzzy
msgid "Perform a single step of the SHADE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/shade.py:49
msgid "Generate trial vectors using the SHADE algorithm."
msgstr "使用SHADE算法生成试验向量。"

#: ../../../src/evox/algorithms/de_variants/shade.py:50
#, fuzzy
msgid "Evaluate the fitness of the trial vectors."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/algorithms/de_variants/shade.py:51
#, fuzzy
msgid "Update the population."
msgstr "种群。"

#: ../../../src/evox/algorithms/de_variants/shade.py:52
msgid "Update the memory."
msgstr "更新记忆。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:1
msgid "{py:mod}`evox.algorithms.es_variants`"
msgstr "{py:mod}`evox.algorithms.es_variants`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:39
msgid "{py:obj}`__all__ <evox.algorithms.es_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.es_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:51
msgid ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."
msgstr ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:1
msgid "{py:mod}`evox.algorithms.es_variants.adam_step`"
msgstr "{py:mod}`evox.algorithms.es_variants.adam_step`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:12
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:22
#: ../../source/apidocs/evox/evox.core.module.md:30
#: ../../source/apidocs/evox/evox.metrics.gd.md:12
#: ../../source/apidocs/evox/evox.metrics.hv.md:12
#: ../../source/apidocs/evox/evox.metrics.igd.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:12
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:12
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:24
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:12
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:48
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:24
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:12
#, fuzzy
msgid "Functions"
msgstr "测试函数"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:18
msgid ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.es_variants.adam_step.adam_single_tensor>`"
msgstr ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.es_variants.adam_step.adam_single_tensor>`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:1
msgid "{py:mod}`evox.algorithms.es_variants.ars`"
msgstr "{py:mod}`evox.algorithms.es_variants.ars`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:18
msgid "{py:obj}`ARS <evox.algorithms.es_variants.ars.ARS>`"
msgstr "{py:obj}`ARS <evox.algorithms.es_variants.ars.ARS>`"

#: ../../../src/evox/algorithms/es_variants/ars.py:20
#: ../../../src/evox/algorithms/es_variants/ars.py:33
#, fuzzy
msgid "The implementation of the ARS algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/ars.py:35
msgid ""
"Reference: Simple random search provides a competitive approach to "
"reinforcement learning (https://arxiv.org/pdf/1803.07055.pdf)"
msgstr ""
"参考文献：Simple random search provides a competitive approach to reinforcement "
"learning (https://arxiv.org/pdf/1803.07055.pdf)"

#: ../../../src/evox/algorithms/es_variants/ars.py:38
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
#: ../../../src/evox/algorithms/es_variants/des.py:39
#: ../../../src/evox/algorithms/es_variants/esmc.py:39
#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
#: ../../../src/evox/algorithms/es_variants/snes.py:39
msgid ""
"This code has been inspired by or utilizes the algorithmic implementation "
"from evosax. More information about evosax can be found at the following "
"URL: GitHub Link: https://github.com/RobertTLange/evosax"
msgstr ""
"这段代码受到了 evosax 中算法实现的启发或使用了其实现。有关 evosax 的更多信息，请访问以下网址：GitHub "
"链接：https://github.com/RobertTLange/evosax"

#: ../../../src/evox/algorithms/es_variants/ars.py:39
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
#, fuzzy
msgid "Initialize the ARS algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/ars.py:42
#: ../../../src/evox/algorithms/es_variants/asebo.py:42
#: ../../../src/evox/algorithms/es_variants/des.py:42
#: ../../../src/evox/algorithms/es_variants/esmc.py:42
#: ../../../src/evox/algorithms/es_variants/guided_es.py:42
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:42
#: ../../../src/evox/algorithms/es_variants/open_es.py:42
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:42
#: ../../../src/evox/algorithms/es_variants/snes.py:42
msgid "The initial center of the population. Must be a 1D tensor."
msgstr "种群的初始中心。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/ars.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:43
#, fuzzy
msgid "The ratio of elite population. Defaults to 0.1."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/ars.py:44
#: ../../../src/evox/algorithms/es_variants/asebo.py:44
#: ../../../src/evox/algorithms/es_variants/esmc.py:44
#: ../../../src/evox/algorithms/es_variants/guided_es.py:44
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:44
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:44
#, fuzzy
msgid "The learning rate for the optimizer. Defaults to 0.05."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/ars.py:45
#: ../../../src/evox/algorithms/es_variants/asebo.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:45
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:45
#, fuzzy
msgid "The standard deviation of the noise. Defaults to 0.03."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/ars.py:46
#: ../../../src/evox/algorithms/es_variants/asebo.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:43
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:43
#: ../../../src/evox/algorithms/es_variants/open_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:43
#: ../../../src/evox/algorithms/es_variants/snes.py:43
msgid ""
"The optimizer to use. Defaults to None. Currently, only \"adam\" or None is "
"supported."
msgstr "使用的优化器（optimizer）。 默认情况下为 None。 仅 support \"adam\" 或 None。\n"

#: ../../../src/evox/algorithms/es_variants/ars.py:47
#: ../../../src/evox/algorithms/es_variants/asebo.py:51
#: ../../../src/evox/algorithms/es_variants/cma_es.py:45
#: ../../../src/evox/algorithms/es_variants/des.py:45
#: ../../../src/evox/algorithms/es_variants/esmc.py:48
#: ../../../src/evox/algorithms/es_variants/guided_es.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:53
#: ../../../src/evox/algorithms/es_variants/nes.py:75
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:50
#: ../../../src/evox/algorithms/es_variants/open_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:50
#: ../../../src/evox/algorithms/es_variants/snes.py:48
#: ../../../src/evox/algorithms/pso_variants/clpso.py:47
#: ../../../src/evox/algorithms/pso_variants/cso.py:47
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:53
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:50
#: ../../../src/evox/algorithms/pso_variants/pso.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:47
msgid "The device to use for the tensors. Defaults to None."
msgstr "设备的使用者（设备用于存放张量的硬件）。默认为 None。"

#: ../../../src/evox/algorithms/es_variants/ars.py:46
#, fuzzy
msgid "Perform a single step of the ARS algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:1
msgid "{py:mod}`evox.algorithms.es_variants.asebo`"
msgstr "{py:mod}`evox.algorithms.es_variants.asebo`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:18
msgid "{py:obj}`ASEBO <evox.algorithms.es_variants.asebo.ASEBO>`"
msgstr "{py:obj}`ASEBO <evox.algorithms.es_variants.asebo.ASEBO>`"

#: ../../../src/evox/algorithms/es_variants/asebo.py:20
#: ../../../src/evox/algorithms/es_variants/asebo.py:33
#, fuzzy
msgid "The implementation of the ASEBO algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/asebo.py:35
msgid ""
"Reference: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"
msgstr ""
"参考文献: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"

#: ../../../src/evox/algorithms/es_variants/asebo.py:45
#, fuzzy
msgid "The decay factor for the learning rate. Defaults to 1.0."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
#, fuzzy
msgid "The minimum value for the learning rate. Defaults to 0.001."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
#: ../../../src/evox/algorithms/es_variants/esmc.py:45
#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:46
#, fuzzy
msgid "The decay factor for the standard deviation. Defaults to 1.0."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:49
#: ../../../src/evox/algorithms/es_variants/esmc.py:46
#: ../../../src/evox/algorithms/es_variants/guided_es.py:47
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:47
#, fuzzy
msgid "The minimum value for the standard deviation. Defaults to 0.01."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:50
#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
#, fuzzy
msgid "The dimension of the subspace. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
#, fuzzy
msgid "The main step of the ASEBO algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
msgid ""
"This function first computes the subspace spanned by the gradient of the "
"fitness function and then projects the gradient onto the subspace. It then "
"computes the step direction using the projected gradient and updates the "
"center and standard deviation of the search distribution."
msgstr ""
"此函数首先计算由适应度函数的梯度所张成的子空间，然后将梯度投影到该子空间。接着，它使用投影后的梯度计算步长方向，并更新搜索分布的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.cma_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.cma_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:18
msgid "{py:obj}`CMAES <evox.algorithms.es_variants.cma_es.CMAES>`"
msgstr "{py:obj}`CMAES <evox.algorithms.es_variants.cma_es.CMAES>`"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:20
#: ../../../src/evox/algorithms/es_variants/cma_es.py:33
#, fuzzy
msgid ""
"The CMA-ES algorithm as described in \"The CMA Evolution Strategy: A "
"Tutorial\" from https://arxiv.org/abs/1604.00772."
msgstr ""
"这个实现遵循了《CMA 演化策略：教程》（The CMA Evolution Strategy: A "
"Tutorial），详情可见：https://arxiv.org/pdf/1604.00772.pdf。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:39
msgid "Initialize the CMA-ES algorithm with the given parameters."
msgstr "使用给定的参数初始化 CMA-ES 算法。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:41
#, fuzzy
msgid "The size of the population with the notation \\lambda."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:42
msgid "The initial mean of the population. Must be a 1D tensor."
msgstr "种群的初始均值。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:43
msgid "The overall standard deviation, i.e., the step size of the algorithm."
msgstr "整体标准差，即算法的步长。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:44
msgid ""
"The recombination weights of the population. Defaults to None and is "
"calculated automatically with recommended values."
msgstr "种群的重组权重。默认为 None，并根据推荐值自动计算。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:46
#, fuzzy
msgid "The main step of the CMA-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:48
msgid ""
"In this step, the algorithm generates a new population, evaluates it, and "
"updates the mean, covariance matrix, and step size correspondingly."
msgstr "在这一步，算法生成一个新种群，评估它，并相应地更新均值、协方差矩阵和步长。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:1
msgid "{py:mod}`evox.algorithms.es_variants.des`"
msgstr "{py:mod}`evox.algorithms.es_variants.des`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:18
msgid "{py:obj}`DES <evox.algorithms.es_variants.des.DES>`"
msgstr "{py:obj}`DES <evox.algorithms.es_variants.des.DES>`"

#: ../../../src/evox/algorithms/es_variants/des.py:20
#: ../../../src/evox/algorithms/es_variants/des.py:33
#: ../../../src/evox/algorithms/es_variants/esmc.py:20
#: ../../../src/evox/algorithms/es_variants/esmc.py:33
#, fuzzy
msgid "The implementation of the DES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/des.py:35
msgid ""
"Reference: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"
msgstr ""
"参考文献: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"

#: ../../../src/evox/algorithms/es_variants/des.py:39
#, fuzzy
msgid "Initialize the DES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/des.py:43
#, fuzzy
msgid "The temperature parameter for the softmax. Defaults to 12.5."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/des.py:44
#, fuzzy
msgid "The initial standard deviation of the noise. Defaults to 0.1."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/des.py:46
msgid ""
"Step the DES algorithm by sampling the population, evaluating the fitness, "
"and updating the center."
msgstr "通过对种群进行采样、评估适应度和更新中心，逐步执行DES算法。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:1
msgid "{py:mod}`evox.algorithms.es_variants.esmc`"
msgstr "{py:mod}`evox.algorithms.es_variants.esmc`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:18
msgid "{py:obj}`ESMC <evox.algorithms.es_variants.esmc.ESMC>`"
msgstr "{py:obj}`ESMC <evox.algorithms.es_variants.esmc.ESMC>`"

#: ../../../src/evox/algorithms/es_variants/esmc.py:35
msgid ""
"Reference: Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"
msgstr ""
"参考文献：Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"

#: ../../../src/evox/algorithms/es_variants/esmc.py:39
#, fuzzy
msgid "Initialize the ESMC algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/esmc.py:46
#, fuzzy
msgid "One iteration of the ESMC algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/esmc.py:48
msgid ""
"This function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "此函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.guided_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.guided_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:18
msgid "{py:obj}`GuidedES <evox.algorithms.es_variants.guided_es.GuidedES>`"
msgstr "{py:obj}`GuidedES <evox.algorithms.es_variants.guided_es.GuidedES>`"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:20
#: ../../../src/evox/algorithms/es_variants/guided_es.py:33
#, fuzzy
msgid "The implementation of the Guided-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:35
msgid ""
"Reference: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"
msgstr ""
"参考文献: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
#, fuzzy
msgid "Initialize the Guided-ES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
#, fuzzy
msgid "Run one step of the Guided-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
#: ../../../src/evox/algorithms/es_variants/snes.py:48
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估他们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.nes`"
msgstr "{py:mod}`evox.algorithms.es_variants.nes`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:18
msgid "{py:obj}`XNES <evox.algorithms.es_variants.nes.XNES>`"
msgstr "{py:obj}`XNES <evox.algorithms.es_variants.nes.XNES>`"

#: ../../../src/evox/algorithms/es_variants/nes.py:20
#: ../../../src/evox/algorithms/es_variants/nes.py:37
#, fuzzy
msgid "The implementation of the xNES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:22
msgid "{py:obj}`SeparableNES <evox.algorithms.es_variants.nes.SeparableNES>`"
msgstr "{py:obj}`SeparableNES <evox.algorithms.es_variants.nes.SeparableNES>`"

#: ../../../src/evox/algorithms/es_variants/nes.py:24
#: ../../../src/evox/algorithms/es_variants/nes.py:61
#, fuzzy
msgid "The implementation of the Separable NES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/nes.py:39
msgid ""
"Reference: Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"
msgstr ""
"参考文献：Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"

#: ../../../src/evox/algorithms/es_variants/nes.py:43
#, fuzzy
msgid "Initialize the xNES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/nes.py:45
#: ../../../src/evox/algorithms/es_variants/nes.py:69
msgid "The initial mean vector of the population. Must be a 1D tensor."
msgstr "种群的初始均值向量。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:46
msgid "The initial covariance matrix of the population. Must be a 2D tensor."
msgstr "种群的初始协方差矩阵。必须是一个二维张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:47
#: ../../../src/evox/algorithms/es_variants/nes.py:71
#, fuzzy
msgid "The size of the population. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:48
#: ../../../src/evox/algorithms/es_variants/nes.py:72
#, fuzzy
msgid "The recombination weights of the population. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:73
#, fuzzy
msgid "The learning rate for the mean vector. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
#: ../../../src/evox/algorithms/es_variants/nes.py:74
#, fuzzy
msgid "The learning rate for the variance vector. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/nes.py:51
#, fuzzy
msgid "The learning rate for the B matrix. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
#, fuzzy
msgid ""
"Whether to use the covariance matrix as a Cholesky factorization result. "
"Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
#, fuzzy
msgid "Run one step of the xNES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
#: ../../../src/evox/algorithms/es_variants/nes.py:76
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and covariance of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和协方差。"

#: ../../../src/evox/algorithms/es_variants/nes.py:63
#: ../../../src/evox/algorithms/es_variants/snes.py:35
msgid ""
"Reference: Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"
msgstr ""
"参考文献：Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"

#: ../../../src/evox/algorithms/es_variants/nes.py:67
#, fuzzy
msgid "Initialize the Separable NES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/nes.py:70
msgid ""
"The initial standard deviation for each dimension. Must be a 1D tensor."
msgstr "每个维度的初始标准差。必须是一个 1D 张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:74
#, fuzzy
msgid "Run one step of the Separable NES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.noise_reuse_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.noise_reuse_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:18
msgid ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.es_variants.noise_reuse_es.NoiseReuseES>`"
msgstr ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.es_variants.noise_reuse_es.NoiseReuseES>`"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:20
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:33
#, fuzzy
msgid "The implementation of the Noise-Reuse-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:35
msgid ""
"Reference: Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"
msgstr ""
"参考文献：Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:48
#, fuzzy
msgid "The inner problem length. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:49
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:49
#, fuzzy
msgid "The number of inner problems. Defaults to 10."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
#, fuzzy
msgid "Take a single step of the NoiseReuseES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
msgid ""
"This function follows the algorithm described in the reference paper. It "
"first generates a set of perturbations for the current population. Then, it "
"evaluates the fitness of the population with the perturbations. Afterwards, "
"it calculates the gradient of the policy parameters using the perturbations "
"and the fitness. Finally, it updates the policy parameters using the "
"gradient and the learning rate."
msgstr ""
"此函数遵循参考论文中描述的算法。它首先为当前族群生成一组扰动。然后，它评估带有扰动的族群的适应度。之后，它使用扰动和适应度计算策略参数的梯度。最后，它使用梯度和学习率更新策略参数。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.open_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.open_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:18
msgid "{py:obj}`OpenES <evox.algorithms.es_variants.open_es.OpenES>`"
msgstr "{py:obj}`OpenES <evox.algorithms.es_variants.open_es.OpenES>`"

#: ../../../src/evox/algorithms/es_variants/open_es.py:20
#: ../../../src/evox/algorithms/es_variants/open_es.py:33
#, fuzzy
msgid ""
"The OpenES algorithm as described in \"Evolution Strategies as a Scalable "
"Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864."
msgstr ""
"实现论文 \"Evolution Strategies as a Scalable Alternative to Reinforcement "
"Learning\" 中描述的算法，链接为https://arxiv.org/abs/1703.03864"

#: ../../../src/evox/algorithms/es_variants/open_es.py:39
#, fuzzy
msgid "Initialize the OpenES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:43
msgid "The learning rate for the optimizer."
msgstr "优化器的学习率。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:44
msgid "The standard deviation of the noise."
msgstr "噪声的标准差。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
#, fuzzy
msgid "Whether to use mirrored sampling. Defaults to True."
msgstr "是否对整个步骤函数进行 `jit` 编译。默认值为 `True`"

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
msgid ""
"Step the OpenES algorithm by evaluating the fitness of the current "
"population and updating the center."
msgstr "通过评估当前种群的适应度并更新中心，执行 OpenES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.persistent_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.persistent_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:18
msgid ""
"{py:obj}`PersistentES "
"<evox.algorithms.es_variants.persistent_es.PersistentES>`"
msgstr ""
"{py:obj}`PersistentES "
"<evox.algorithms.es_variants.persistent_es.PersistentES>`"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:20
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:33
#, fuzzy
msgid "The implementation of the Persistent ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:35
msgid ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"
msgstr ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
#, fuzzy
msgid "Initialize the Persistent-ES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.snes`"
msgstr "{py:mod}`evox.algorithms.es_variants.snes`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:18
msgid "{py:obj}`SNES <evox.algorithms.es_variants.snes.SNES>`"
msgstr "{py:obj}`SNES <evox.algorithms.es_variants.snes.SNES>`"

#: ../../../src/evox/algorithms/es_variants/snes.py:20
#: ../../../src/evox/algorithms/es_variants/snes.py:33
#, fuzzy
msgid "The implementation of the SNES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/snes.py:39
#, fuzzy
msgid "Initialize the SNES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/snes.py:44
#, fuzzy
msgid "The learning rate for the mean. Defaults to 1.0."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:45
#, fuzzy
msgid "The standard deviation of the noise. Defaults to 1.0."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
#, fuzzy
msgid "The temperature of the softmax in computing weights. Defaults to 12.5."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:47
#, fuzzy
msgid "The type of weights to use. Defaults to \"temp\"."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
#, fuzzy
msgid "Run one step of the SNES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:1
msgid "{py:mod}`evox.algorithms.es_variants.sort_utils`"
msgstr "{py:mod}`evox.algorithms.es_variants.sort_utils`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:18
msgid ""
"{py:obj}`sort_by_key <evox.algorithms.es_variants.sort_utils.sort_by_key>`"
msgstr ""
"{py:obj}`sort_by_key <evox.algorithms.es_variants.sort_utils.sort_by_key>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:1
msgid "{py:mod}`evox.algorithms.mo`"
msgstr "{py:mod}`evox.algorithms.mo`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:29
msgid "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:41
msgid "['RVEA', 'NSGA2', 'MOEAD']"
msgstr "['RVEA', 'NSGA2', 'MOEAD']"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:1
msgid "{py:mod}`evox.algorithms.mo.moead`"
msgstr "{py:mod}`evox.algorithms.mo.moead`"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:18
msgid "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"
msgstr "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"

#: ../../../src/evox/algorithms/mo/moead.py:20
#: ../../../src/evox/algorithms/mo/moead.py:52
msgid "Implementation of the Original MOEA/D algorithm."
msgstr "原始 MOEA/D 算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:30
msgid "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"
msgstr "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"

#: ../../../src/evox/algorithms/mo/moead.py:54
#: ../../../src/evox/algorithms/mo/nsga2.py:38
#: ../../../src/evox/algorithms/mo/rvea.py:37
#, fuzzy
msgid "References"
msgstr "API文档"

#: ../../../src/evox/algorithms/mo/moead.py:55
msgid ""
"\"MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition,\" "
"IEEE Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/4358754>`_"
msgstr ""
"\"MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition,\" "
"IEEE Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/4358754>`_"

#: ../../../src/evox/algorithms/mo/moead.py:59
#: ../../../src/evox/metrics/gd.py:39 ../../../src/evox/metrics/igd.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:113
#: ../../../src/evox/operators/selection/rvea_selection.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:182
#, fuzzy
msgid "Note"
msgstr "Note"

#: ../../../src/evox/algorithms/mo/moead.py:59
msgid ""
"This implementation is based on the original paper and may not be the most "
"efficient implementation. It can not be traced by JIT."
msgstr "本实现基于原始论文，可能不是最有效的实现。它无法通过 JIT 进行跟踪。"

#: ../../../src/evox/algorithms/mo/moead.py:58
#, fuzzy
msgid "Initializes the MOEA/D algorithm."
msgstr "并行MOEA/D算法"

#: ../../../src/evox/algorithms/mo/moead.py:61
#: ../../../src/evox/algorithms/mo/nsga2.py:42
#: ../../../src/evox/algorithms/mo/rvea.py:42
msgid "The number of objective functions in the optimization problem."
msgstr "优化问题中的目标函数数量。"

#: ../../../src/evox/algorithms/mo/moead.py:62
#: ../../../src/evox/algorithms/mo/nsga2.py:43
msgid "The lower bounds for the decision variables (1D tensor)."
msgstr "决策变量的下界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/moead.py:63
#: ../../../src/evox/algorithms/mo/nsga2.py:44
msgid "The upper bounds for the decision variables (1D tensor)."
msgstr "决策变量的上界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/moead.py:64
#: ../../../src/evox/algorithms/mo/nsga2.py:45
#: ../../../src/evox/algorithms/mo/rvea.py:48
msgid "The selection operation for evolutionary strategy (optional)."
msgstr "进化策略的选择操作（可选）。"

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
msgid ""
"The mutation operation, defaults to polynomial_mutation if not provided "
"(optional)."
msgstr "基因突变操作，该选项的缺省值是 `polynomial_mutation`，如果未提供，则使用默认值 (可选)。"

#: ../../../src/evox/algorithms/mo/moead.py:66
msgid ""
"The crossover operation, defaults to simulated_binary_half if not provided "
"(optional)."
msgstr "交叉操作，如果未提供，则默认为 simulated_binary_half（可选）。"

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
msgid ""
"The device on which computations should run (optional). Defaults to "
"PyTorch's default device."
msgstr "计算应该运行的设备（可选）。默认为 PyTorch 的默认设备。"

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "Perform the initialization step of the workflow."
msgstr "执行工作流的初始化步骤。"

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
#: ../../../src/evox/algorithms/mo/rvea.py:48
#: ../../../src/evox/workflows/std_workflow.py:107
msgid ""
"Calls the `init_step` of the algorithm if overwritten; otherwise, its `step`"
" method will be invoked."
msgstr "调用算法的 `init_step` 如果被重写；否则，将调用其 `step` 方法。"

#: ../../../src/evox/algorithms/mo/moead.py:73
msgid "Perform a single optimization step of the workflow."
msgstr "执行工作流程的单个优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:1
msgid "{py:mod}`evox.algorithms.mo.nsga2`"
msgstr "{py:mod}`evox.algorithms.mo.nsga2`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:18
msgid "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"
msgstr "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"

#: ../../../src/evox/algorithms/mo/nsga2.py:20
#: ../../../src/evox/algorithms/mo/nsga2.py:33
msgid ""
"An implementation of the Non-dominated Sorting Genetic Algorithm II (NSGA-"
"II) for multi-objective optimization problems."
msgstr "非支配排序遗传算法 II (NSGA-II) 的实现，用于多目标优化问题。"

#: ../../../src/evox/algorithms/mo/nsga2.py:35
msgid ""
"This class provides a framework for solving multi-objective optimization "
"problems using a non-dominated sorting genetic algorithm, which is widely "
"used for Pareto-based optimization."
msgstr "此类提供了一个框架，用于通过非支配排序遗传算法解决多目标优化问题，该算法广泛用于基于帕累托的优化。"

#: ../../../src/evox/algorithms/mo/nsga2.py:39
msgid ""
"\"A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II,\" IEEE "
"Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/996017>`_"
msgstr ""
"\"A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II,\" IEEE "
"Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/996017>`_"

#: ../../../src/evox/algorithms/mo/nsga2.py:39
#, fuzzy
msgid "Initializes the NSGA-II algorithm."
msgstr "NSGA-II算法"

#: ../../../src/evox/algorithms/mo/nsga2.py:47
msgid ""
"The crossover operation, defaults to simulated_binary if not provided "
"(optional)."
msgstr "交叉操作，如果未提供（可选），默认为 simulated_binary。"

#: ../../../src/evox/algorithms/mo/nsga2.py:54
msgid "Perform the optimization step of the workflow."
msgstr "执行工作流的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:1
msgid "{py:mod}`evox.algorithms.mo.rvea`"
msgstr "{py:mod}`evox.algorithms.mo.rvea`"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:18
msgid "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"
msgstr "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"

#: ../../../src/evox/algorithms/mo/rvea.py:20
#: ../../../src/evox/algorithms/mo/rvea.py:33
msgid ""
"An implementation of the Reference Vector Guided Evolutionary Algorithm "
"(RVEA) for multi-objective optimization problems."
msgstr ""
"Reference Vector Guided Evolutionary Algorithm (RVEA) "
"多目标优化问题的参考向量引导进化算法(RVEA) 的实现"

#: ../../../src/evox/algorithms/mo/rvea.py:35
msgid ""
"This class is designed to solve multi-objective optimization problems using "
"a reference vector guided evolutionary algorithm."
msgstr "这类是设计用来使用参考向量引导的进化算法来解决多目标优化问题的。"

#: ../../../src/evox/algorithms/mo/rvea.py:38
msgid ""
"\"a reference vector guided evolutionary algorithm for many-objective "
"optimization,\" ieee. `link <https://ieeexplore.ieee.org/document/7386636>`"
msgstr ""
"\"a reference vector guided evolutionary algorithm for many-objective "
"optimization,\" ieee. `link <https://ieeexplore.ieee.org/document/7386636>`"

#: ../../../src/evox/algorithms/mo/rvea.py:40
msgid ""
"\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
"RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"
msgstr ""
"\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
"RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"

#: ../../../src/evox/algorithms/mo/rvea.py:39
#, fuzzy
msgid "Initialize the RVEA algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/mo/rvea.py:43
#: ../../../src/evox/operators/mutation/pm_mutation.py:34
msgid "The lower bounds for the decision variables."
msgstr "**决策变量的下限值**"

#: ../../../src/evox/algorithms/mo/rvea.py:44
#: ../../../src/evox/operators/mutation/pm_mutation.py:35
msgid "The upper bounds for the decision variables."
msgstr "决策变量的上限界值。"

#: ../../../src/evox/algorithms/mo/rvea.py:45
msgid ""
"A parameter for controlling the rate of change of penalty. Defaults to 2."
msgstr "一个参数，用于控制惩罚的变化速率。默认值为 2。"

#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "The frequency of reference vector adaptation. Defaults to 0.1."
msgstr "引用向量适应的频率。默认为 0.1。"

#: ../../../src/evox/algorithms/mo/rvea.py:47
#, fuzzy
msgid "The maximum number of generations. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/mo/rvea.py:49
msgid "The mutation operation (optional)."
msgstr "变异操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:50
msgid "The crossover operation (optional)."
msgstr "交叉操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:51
msgid "The device on which computations should run (optional)."
msgstr "运行计算的设备（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:102
#, fuzzy
msgid "Perform a single optimization step."
msgstr "🌐 **多功能优化套件**:"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:1
msgid "{py:mod}`evox.algorithms.pso_variants`"
msgstr "{py:mod}`evox.algorithms.pso_variants`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:34
msgid "{py:obj}`__all__ <evox.algorithms.pso_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.pso_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:46
msgid "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"
msgstr "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.clpso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.clpso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:18
msgid "{py:obj}`CLPSO <evox.algorithms.pso_variants.clpso.CLPSO>`"
msgstr "{py:obj}`CLPSO <evox.algorithms.pso_variants.clpso.CLPSO>`"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:20
#: ../../../src/evox/algorithms/pso_variants/clpso.py:33
#: ../../../src/evox/algorithms/pso_variants/cso.py:20
#: ../../../src/evox/algorithms/pso_variants/cso.py:33
#, fuzzy
msgid "The basic CSO algorithm."
msgstr "算法。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:37
msgid ""
"`__init__`: Initializes the CLPSO algorithm with given static parameters "
"including lower and upper bounds for particle positions."
msgstr "`__init__`: 初始化 CLPSO 算法，使用给定的静态参数，包括粒子位置的下限和上限。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:38
msgid ""
"`setup`: Initializes the CLPSO algorithm and sets up initial population, "
"velocity, and buffers for tracking best local and global positions and "
"fitness values."
msgstr "`setup`: 初始化 CLPSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid ""
"`step`: Performs a single optimization step using CLPSO, updating local best"
" positions and fitness values, and adjusting velocity and positions based on"
" inertia, cognitive, and social components."
msgstr ""
"**单步优化** (`step`): \n"
"使用CLPSO执行单步优化，更新个人最佳位置和适应值，根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:40
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class, it is a proxy "
"function of `Problem.evaluate` set by workflow; therefore, it cannot be used"
" in class methods other than `step`."
msgstr ""
"请注意，`evaluate`方法在此类中未定义，它是由工作流设置的`Problem.evaluate`的代理函数；因此，它无法在除`step`之外的类方法中使用。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid "Initialize the CLPSO algorithm with the given static parameters."
msgstr "用给定的静态参数初始化 CLPSO 算法。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:44
msgid "The inertia weight (w). Defaults to 0.5."
msgstr "惯性权重 (w)。默认值为 0.5。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:45
msgid "The cognitive weight (c). Defaults to 1.5."
msgstr "认知权重（c）。默认为1.5。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "The social weight (P_c). Defaults to 0.05."
msgstr "社会权重 (P_c)。默认为 0.05。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "Perform a single optimization step using CLPSO."
msgstr "使用 CLPSO 执行单次优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:48
#: ../../../src/evox/algorithms/pso_variants/pso.py:48
msgid ""
"This function evaluates the fitness of the current population, updates the "
"local best positions and fitness values, and adjusts the velocity and "
"positions of particles based on inertia, cognitive, and social components. "
"It ensures that the updated positions and velocities are clamped within the "
"specified bounds."
msgstr ""
"该函数用于评估当前种群的适应度，更新局部最优位置和适应度值并根据惯性、认知和社会组件调整粒子的速度和位置该函数确保在更新位置和速度后，粒子的位置和速度都在指定的范围内。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:54
#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid ""
"The local best positions and fitness values are updated if the current "
"fitness is better than the recorded local best. The global best position and"
" fitness are determined using helper functions."
msgstr "如果当前的适应度比记录的局部最佳更好，则更新局部最佳位置和适应度值。全局最佳位置和适应度通过辅助函数确定。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:58
#: ../../../src/evox/algorithms/pso_variants/pso.py:58
msgid ""
"The velocity is updated based on the weighted sum of the previous velocity, "
"the cognitive component (personal best), and the social component (global "
"best). The population positions are then updated using the new velocities."
msgstr "速度是基于以前速度的加权总和、认知成分（个人最好）和社会成分（全局最好）进行更新的。然后，使用新的速度更新种群位置。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.cso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.cso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:18
msgid "{py:obj}`CSO <evox.algorithms.pso_variants.cso.CSO>`"
msgstr "{py:obj}`CSO <evox.algorithms.pso_variants.cso.CSO>`"

#: ../../../src/evox/algorithms/pso_variants/cso.py:37
msgid "`__init__`: Initializes the CSO algorithm with given parameters."
msgstr "`__init__`: 使用给定参数初始化 CSO 算法。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:38
msgid ""
"`setup`: Initializes the CSO algorithm with given lower and upper bounds for"
" particle positions, and sets up initial population, velocity, and buffers "
"for tracking best local and global positions and fitness values."
msgstr "`setup`: 使用给定的粒子位置下限和上限初始化 CSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
msgid ""
"`step`: Performs a single optimization step using CSO, updating local best "
"positions and fitness values, and adjusting velocity and positions based on "
"inertia, cognitive, and social components."
msgstr "`step`：使用 CSO 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
#, fuzzy
msgid "Initialize the CSO algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:44
msgid "The inertia weight. Defaults to 0.0."
msgstr "惯性权重。默认值为 0.0。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:45
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:47
#, fuzzy
msgid "The mean of the normal distribution. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:48
msgid "The standard deviation of the normal distribution. Defaults to None."
msgstr "正态分布的标准差。默认为 None。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
msgid "Perform a single optimization step using CSO."
msgstr "使用 CSO 进行单次优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:48
msgid ""
"This function updates the position and velocity of each particle in the "
"population using the CSO algorithm. The CSO algorithm is an optimization "
"algorithm that uses a combination of both the PSO and the DE algorithms to "
"search for the optimal solution."
msgstr "该函数使用CSO算法更新种群中每个粒子的位置和速度。CSO算法是一种优化算法，它结合了PSO和DE算法来搜索最佳解决方案。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.dms_pso_el`"
msgstr "{py:mod}`evox.algorithms.pso_variants.dms_pso_el`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:18
msgid "{py:obj}`DMSPSOEL <evox.algorithms.pso_variants.dms_pso_el.DMSPSOEL>`"
msgstr "{py:obj}`DMSPSOEL <evox.algorithms.pso_variants.dms_pso_el.DMSPSOEL>`"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:20
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:33
#, fuzzy
msgid "The DMSPSOEL algorithm."
msgstr "算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:37
msgid "`__init__`: Initializes the DMSPSOEL algorithm with given parameters."
msgstr "`__init__`: 通过给定的参数来初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:38
msgid ""
"`setup`: Initializes the DMSPSOEL algorithm with given lower and upper "
"bounds for particle positions, and sets up initial population, velocity, and"
" buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`: 初始化 DMSPSOEL 算法，设置粒子位置的下限和上限，并配置初始种群、速度，以及用于跟踪最佳局部和全局位置与适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid ""
"`step`: Performs a single optimization step using DMSPSOEL, updating local "
"best positions and fitness values, and adjusting velocity and positions "
"based on inertia, cognitive, and social components."
msgstr "`step`: 使用 DMSPSOEL 执行单次优化步骤，更新本地最佳位置和适应度值，并根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid "Initialize the DMSPSOEL algorithm with the given parameters."
msgstr "使用给定参数初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:43
msgid "The size of the dynamic sub-swarm. Defaults to 10."
msgstr "动态子种群的大小。默认值：10。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:44
msgid "The number of dynamic sub-swarms. Defaults to 5."
msgstr "动态子种群的数量。默认为5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:45
msgid "The size of the following sub-swarm. Defaults to 10."
msgstr "以下子群体的大小。默认为10。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
msgid "The number of iterations for regrouping. Defaults to 50."
msgstr "重组的迭代次数。默认为50。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:47
#, fuzzy
msgid "The maximum number of iterations. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid "The inertia weight. Defaults to 0.7."
msgstr "惯性权重。默认值为0.7。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:49
msgid "The cognitive weight. Defaults to 1.5."
msgstr "认知权重。默认为 1.5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:50
msgid "The social weight. Defaults to 1.5."
msgstr "社会权重。默认为 1.5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:51
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:52
msgid "The social weight. Defaults to 1.0."
msgstr "社交权重。默认为 1.0。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
#, fuzzy
msgid "Perform a single step of the DMSPSOEL algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid ""
"This function updates the population, velocity, personal best location, and "
"personal best fitness based on the current fitness values. It also updates "
"the local and global best positions and fitness values based on the dynamic "
"sub-swarm and following sub-swarm. Finally, it updates the iteration count."
msgstr ""
"此函数根据当前的适应度值更新种群、速度、个人最佳位置和个人最佳适应度。它还根据动态子群和跟随子群更新局部和全局最佳位置及适应度值。最后，它更新迭代计数。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.fs_pso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.fs_pso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:18
msgid "{py:obj}`FSPSO <evox.algorithms.pso_variants.fs_pso.FSPSO>`"
msgstr "{py:obj}`FSPSO <evox.algorithms.pso_variants.fs_pso.FSPSO>`"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:20
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:33
#, fuzzy
msgid "The Feature Selection PSO algorithm."
msgstr "这个算法的状态。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:39
msgid "Initialize the FSPSO algorithm with the given parameters."
msgstr "使用给定参数初始化FSPSO算法。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:44
#: ../../../src/evox/algorithms/pso_variants/pso.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:44
msgid "The inertia weight. Defaults to 0.6."
msgstr "惯性权重。默认值为0.6。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:45
#: ../../../src/evox/algorithms/pso_variants/pso.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:45
msgid "The cognitive weight. Defaults to 2.5."
msgstr "认知权重。默认为 2.5。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
#: ../../../src/evox/algorithms/pso_variants/pso.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "The social weight. Defaults to 0.8."
msgstr "社会权重。默认值为 0.8。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:49
msgid "The mutation rate. Defaults to 0.01."
msgstr "变异率。默认为 0.01。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
msgid "Perform a normal optimization step using FSPSO."
msgstr "使用 FSPSO 执行常规优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.pso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.pso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:18
msgid "{py:obj}`PSO <evox.algorithms.pso_variants.pso.PSO>`"
msgstr "{py:obj}`PSO <evox.algorithms.pso_variants.pso.PSO>`"

#: ../../../src/evox/algorithms/pso_variants/pso.py:20
#: ../../../src/evox/algorithms/pso_variants/pso.py:33
msgid "The basic Particle Swarm Optimization (PSO) algorithm."
msgstr "基本粒子群优化算法 (PSO)"

#: ../../../src/evox/algorithms/pso_variants/pso.py:37
msgid ""
"`__init__`: Initializes the PSO algorithm with given parameters (population "
"size, lower and upper bounds, inertia weight, cognitive weight, and social "
"weight)."
msgstr ""
"**__init__**\n"
"初始化 PSO 算法（Particle Swarm Optimization）与给定的参数（人口大小、下限和上限、惯性权重、认知权重和社会权重）。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:38
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (PSO), updating local best positions and fitness values, and "
"adjusting velocity and positions based on inertia, cognitive, and social "
"components."
msgstr "`step`: 执行单次粒子群优化（PSO）步骤，更新局部最佳位置和适应度值，并基于惯性、认知和社会组件调整速度和位置。\n"

#: ../../../src/evox/algorithms/pso_variants/pso.py:39
#, fuzzy
msgid "Initialize the PSO algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:46
msgid "Perform a normal optimization step using PSO."
msgstr "使用PSO执行常规优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid "Perform the first step of the PSO optimization."
msgstr "执行 PSO 优化的第一步。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:56
msgid "See `step` for more details."
msgstr "请查看 `step` 以获取更多详细信息。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_gs`"
msgstr "{py:mod}`evox.algorithms.pso_variants.sl_pso_gs`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:18
msgid "{py:obj}`SLPSOGS <evox.algorithms.pso_variants.sl_pso_gs.SLPSOGS>`"
msgstr "{py:obj}`SLPSOGS <evox.algorithms.pso_variants.sl_pso_gs.SLPSOGS>`"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Gaussian "
"Sampling for Demonstrator Choice (SLPSOGS) algorithm."
msgstr "基本的粒子群优化社交学习 PSO 使用高斯采样进行示范选择 (SLPSOGS) 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:37
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:37
msgid ""
"`__init__`: Initializes the SLPSOGS algorithm with given parameters "
"(population size, inertia weight, cognitive weight, and social weight)."
msgstr "`__init__`: 使用给定的参数（种群大小、惯性权重、认知权重和社会权重）初始化SLPSOGS算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:38
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:38
msgid ""
"`setup`: Initializes the SLPSOGS algorithm with given lower and upper bounds"
" for particle positions, and sets up initial population, velocity, and "
"buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`：初始化 SLPSOGS 算法，设置粒子位置的下界和上界，并建立初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (SLPSOGS), updating local best positions and fitness values, "
"and adjusting velocity and positions based on inertia, cognitive, and social"
" components."
msgstr ""
"`step`: 使用粒子群优化 (SLPSOGS) 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交成分调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
msgid "Initialize the SLPSOGS algorithm with the given parameters."
msgstr "使用给定参数初始化 SLPSOGS 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
msgid "Perform a normal optimization step using SLPSOGS."
msgstr "使用 SLPSOGS 执行一个正常的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_us`"
msgstr "{py:mod}`evox.algorithms.pso_variants.sl_pso_us`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:18
msgid "{py:obj}`SLPSOUS <evox.algorithms.pso_variants.sl_pso_us.SLPSOUS>`"
msgstr "{py:obj}`SLPSOUS <evox.algorithms.pso_variants.sl_pso_us.SLPSOUS>`"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Uniform "
"Sampling for Demonstrator Choice (SLPSOUS) algorithm."
msgstr "基本的粒子群优化社会学习 PSO 使用均匀采样进行演示选择 (SLPSOUS) 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid "Initialize the SLPSOUS algorithm with the given parameters."
msgstr "用给定的参数初始化 SLPSOUS 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "Perform a normal optimization step using SLPSOUS."
msgstr "执行一个使用 SLPSOUS 的正常优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.utils`"
msgstr "{py:mod}`evox.algorithms.pso_variants.utils`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:18
msgid "{py:obj}`min_by <evox.algorithms.pso_variants.utils.min_by>`"
msgstr "{py:obj}`min_by <evox.algorithms.pso_variants.utils.min_by>`"

#: ../../../src/evox/algorithms/pso_variants/utils.py:20
#: ../../../src/evox/algorithms/pso_variants/utils.py:34
msgid "Find the value with the minimum key."
msgstr "找到具有最小键的值。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:22
msgid ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.pso_variants.utils.random_select_from_mask>`"
msgstr ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.pso_variants.utils.random_select_from_mask>`"

#: ../../../src/evox/algorithms/pso_variants/utils.py:24
#: ../../../src/evox/algorithms/pso_variants/utils.py:41
msgid "Randomly select `s` elements from a 1D mask using uniform noise."
msgstr "随机从 1D 掩码中使用均匀噪声随机选择 `s` 个元素。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:36
msgid "A tensor or list of tensors."
msgstr "一个张量或一个列表的张量"

#: ../../../src/evox/algorithms/pso_variants/utils.py:37
msgid "A tensor or list of tensors corresponding to the values."
msgstr "一个张量或与值对应的张量列表。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:39
msgid "The value with the minimum key and the corresponding key."
msgstr "具有最小键的值及其对应的键。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:43
msgid "A tensor used as the random seed."
msgstr "用于随机种子的张量。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:44
msgid "A tensor of shape (N,) containing {0, 1}."
msgstr "一个形状为 (N,) 的张量，包含 {0, 1}。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:45
#, fuzzy
msgid "The number of elements to select."
msgstr "目标数量"

#: ../../../src/evox/algorithms/pso_variants/utils.py:47
msgid "A new mask tensor with exactly s elements set to 1."
msgstr "一个新的掩码张量，其中恰好有 s 个元素设置为 1。"

#: ../../source/apidocs/evox/evox.core.md:1
msgid "{py:mod}`evox.core`"
msgstr "{py:mod}`evox.core`"

#: ../../source/apidocs/evox/evox.core.md:30
msgid "{py:obj}`__all__ <evox.core.__all__>`"
msgstr "{py:obj}`__all__ <evox.core.__all__>`"

#: ../../source/apidocs/evox/evox.core.md:42
msgid ""
"['_vmap_fix', 'debug_print', 'Parameter', 'Mutable', 'ModuleBase', "
"'use_state', 'trace_impl', 'vmap_..."
msgstr ""
"['_vmap_fix', 'debug_print', 'Parameter', 'Mutable', 'ModuleBase', "
"'use_state', 'trace_impl', 'vmap_..."

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:1
msgid "{py:mod}`evox.core._vmap_fix`"
msgstr "{py:mod}`evox.core._vmap_fix`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:18
msgid "{py:obj}`_set_func_id <evox.core._vmap_fix._set_func_id>`"
msgstr "{py:obj}`_set_func_id <evox.core._vmap_fix._set_func_id>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:22
msgid ""
"{py:obj}`unwrap_batch_tensor <evox.core._vmap_fix.unwrap_batch_tensor>`"
msgstr ""
"{py:obj}`unwrap_batch_tensor <evox.core._vmap_fix.unwrap_batch_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:24
#: ../../../src/evox/core/_vmap_fix.py:181
msgid ""
"Unwraps a batched tensor into its original tensor and the batch "
"dimensions/sizes."
msgstr "将批量张量展开为其原始张量及批量维度/大小。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:26
msgid "{py:obj}`wrap_batch_tensor <evox.core._vmap_fix.wrap_batch_tensor>`"
msgstr "{py:obj}`wrap_batch_tensor <evox.core._vmap_fix.wrap_batch_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:28
#: ../../../src/evox/core/_vmap_fix.py:188
msgid ""
"Wraps a original tensor into its batched form with given batch dimensions."
msgstr "将原始张量封装到其批量形式中，给定批量维度。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:30
msgid "{py:obj}`_get_batched_size <evox.core._vmap_fix._get_batched_size>`"
msgstr "{py:obj}`_get_batched_size <evox.core._vmap_fix._get_batched_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:34
msgid ""
"{py:obj}`get_vmap_batch_sizes <evox.core._vmap_fix.get_vmap_batch_sizes>`"
msgstr ""
"{py:obj}`get_vmap_batch_sizes <evox.core._vmap_fix.get_vmap_batch_sizes>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:38
msgid ""
"{py:obj}`vmap_increment_nesting "
"<evox.core._vmap_fix.vmap_increment_nesting>`"
msgstr ""
"{py:obj}`vmap_increment_nesting "
"<evox.core._vmap_fix.vmap_increment_nesting>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:42
msgid "{py:obj}`_flat_vmap <evox.core._vmap_fix._flat_vmap>`"
msgstr "{py:obj}`_flat_vmap <evox.core._vmap_fix._flat_vmap>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:46
msgid "{py:obj}`batched_random <evox.core._vmap_fix.batched_random>`"
msgstr "{py:obj}`batched_random <evox.core._vmap_fix.batched_random>`"

#: ../../../src/evox/core/_vmap_fix.py:48
#: ../../../src/evox/core/_vmap_fix.py:234
msgid "Generate a batched tensor of random values."
msgstr "生成一个包含随机值的批量张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:50
msgid ""
"{py:obj}`batched_random_like <evox.core._vmap_fix.batched_random_like>`"
msgstr ""
"{py:obj}`batched_random_like <evox.core._vmap_fix.batched_random_like>`"

#: ../../../src/evox/core/_vmap_fix.py:52
#: ../../../src/evox/core/_vmap_fix.py:241
msgid ""
"Generate a batched tensor of random values with the same shape as the given "
"tensor."
msgstr "生成一个与给定张量形状相同的随机值批处理张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:54
msgid "{py:obj}`_batch_size <evox.core._vmap_fix._batch_size>`"
msgstr "{py:obj}`_batch_size <evox.core._vmap_fix._batch_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:58
msgid "{py:obj}`_batch_rand <evox.core._vmap_fix._batch_rand>`"
msgstr "{py:obj}`_batch_rand <evox.core._vmap_fix._batch_rand>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:62
msgid "{py:obj}`_batch_randn <evox.core._vmap_fix._batch_randn>`"
msgstr "{py:obj}`_batch_randn <evox.core._vmap_fix._batch_randn>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:66
msgid "{py:obj}`_batch_randint <evox.core._vmap_fix._batch_randint>`"
msgstr "{py:obj}`_batch_randint <evox.core._vmap_fix._batch_randint>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:70
msgid "{py:obj}`_batch_randperm <evox.core._vmap_fix._batch_randperm>`"
msgstr "{py:obj}`_batch_randperm <evox.core._vmap_fix._batch_randperm>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:74
msgid "{py:obj}`_batch_rand_like <evox.core._vmap_fix._batch_rand_like>`"
msgstr "{py:obj}`_batch_rand_like <evox.core._vmap_fix._batch_rand_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:78
msgid "{py:obj}`_batch_randn_like <evox.core._vmap_fix._batch_randn_like>`"
msgstr "{py:obj}`_batch_randn_like <evox.core._vmap_fix._batch_randn_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:82
msgid ""
"{py:obj}`_batch_randint_like <evox.core._vmap_fix._batch_randint_like>`"
msgstr ""
"{py:obj}`_batch_randint_like <evox.core._vmap_fix._batch_randint_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:86
msgid "{py:obj}`_batch_getitem <evox.core._vmap_fix._batch_getitem>`"
msgstr "{py:obj}`_batch_getitem <evox.core._vmap_fix._batch_getitem>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:90
msgid "{py:obj}`_batch_setitem <evox.core._vmap_fix._batch_setitem>`"
msgstr "{py:obj}`_batch_setitem <evox.core._vmap_fix._batch_setitem>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:94
msgid "{py:obj}`use_batch_fixing <evox.core._vmap_fix.use_batch_fixing>`"
msgstr "{py:obj}`use_batch_fixing <evox.core._vmap_fix.use_batch_fixing>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:98
msgid "{py:obj}`align_vmap_tensor <evox.core._vmap_fix.align_vmap_tensor>`"
msgstr "{py:obj}`align_vmap_tensor <evox.core._vmap_fix.align_vmap_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:100
#: ../../../src/evox/core/_vmap_fix.py:436
msgid ""
"Aligns a tensor with the batching dimensions of a current batched tensor."
msgstr "将张量与当前批处理张量的批处理维度对齐。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:102
msgid "{py:obj}`_debug_print <evox.core._vmap_fix._debug_print>`"
msgstr "{py:obj}`_debug_print <evox.core._vmap_fix._debug_print>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:106
msgid "{py:obj}`debug_print <evox.core._vmap_fix.debug_print>`"
msgstr "{py:obj}`debug_print <evox.core._vmap_fix.debug_print>`"

#: ../../../src/evox/core/_vmap_fix.py:108
#: ../../../src/evox/core/_vmap_fix.py:450
msgid ""
"Prints a formatted string with one positional tensor used for debugging "
"inside JIT traced functions on-the-fly."
msgstr "打印一个格式化字符串，包含一个用于调试的定位张量，在 JIT 跟踪的函数中实时使用。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:118
msgid "{py:obj}`_vmap_batch_sizes <evox.core._vmap_fix._vmap_batch_sizes>`"
msgstr "{py:obj}`_vmap_batch_sizes <evox.core._vmap_fix._vmap_batch_sizes>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:122
msgid "{py:obj}`_original_size <evox.core._vmap_fix._original_size>`"
msgstr "{py:obj}`_original_size <evox.core._vmap_fix._original_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:126
msgid "{py:obj}`_original_rand <evox.core._vmap_fix._original_rand>`"
msgstr "{py:obj}`_original_rand <evox.core._vmap_fix._original_rand>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:130
msgid "{py:obj}`_original_randn <evox.core._vmap_fix._original_randn>`"
msgstr "{py:obj}`_original_randn <evox.core._vmap_fix._original_randn>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:134
msgid "{py:obj}`_original_randint <evox.core._vmap_fix._original_randint>`"
msgstr "{py:obj}`_original_randint <evox.core._vmap_fix._original_randint>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:138
msgid "{py:obj}`_original_randperm <evox.core._vmap_fix._original_randperm>`"
msgstr "{py:obj}`_original_randperm <evox.core._vmap_fix._original_randperm>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:142
msgid ""
"{py:obj}`_original_rand_like <evox.core._vmap_fix._original_rand_like>`"
msgstr ""
"{py:obj}`_original_rand_like <evox.core._vmap_fix._original_rand_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:146
msgid ""
"{py:obj}`_original_randn_like <evox.core._vmap_fix._original_randn_like>`"
msgstr ""
"{py:obj}`_original_randn_like <evox.core._vmap_fix._original_randn_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:150
msgid ""
"{py:obj}`_original_randint_like "
"<evox.core._vmap_fix._original_randint_like>`"
msgstr ""
"{py:obj}`_original_randint_like "
"<evox.core._vmap_fix._original_randint_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:154
msgid "{py:obj}`_original_get_item <evox.core._vmap_fix._original_get_item>`"
msgstr "{py:obj}`_original_get_item <evox.core._vmap_fix._original_get_item>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:158
msgid "{py:obj}`_original_set_item <evox.core._vmap_fix._original_set_item>`"
msgstr "{py:obj}`_original_set_item <evox.core._vmap_fix._original_set_item>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:162
msgid "{py:obj}`_batch_fixing <evox.core._vmap_fix._batch_fixing>`"
msgstr "{py:obj}`_batch_fixing <evox.core._vmap_fix._batch_fixing>`"

#: ../../../src/evox/core/_vmap_fix.py:183
msgid "The batched tensor to be unwrapped."
msgstr "要解包的批处理张量。"

#: ../../../src/evox/core/_vmap_fix.py:185
msgid ""
"A tuple of the original tensor, the batch dimensions, and the batch sizes."
msgstr "原始张量、批次维度和批次大小的元组。"

#: ../../../src/evox/core/_vmap_fix.py:190
msgid "The original tensor to be wrapped."
msgstr "要包装的原始张量。"

#: ../../../src/evox/core/_vmap_fix.py:191
#, fuzzy
msgid "The batch dimension(s)."
msgstr "批处理大小。"

#: ../../../src/evox/core/_vmap_fix.py:193
#, fuzzy
msgid "The batched tensor."
msgstr "批处理大小。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:203
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:419
#: ../../source/apidocs/evox/evox.core.module.md:361
#: ../../source/apidocs/evox/evox.core.module.md:372
msgid "'ContextVar(...)'"
msgstr "'ContextVar(...)'"

#: ../../../src/evox/core/_vmap_fix.py:236
msgid ""
"Given a random function (e.g. "
"[`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html),"
" [`torch.rand`](https://pytorch.org/docs/stable/generated/torch.rand.html), "
"etc.) and its size arguments, this function generates a batched tensor of "
"random values by applying the given function to the size extended with the "
"current vmap batch size."
msgstr ""
"给定一个随机函数（例如 "
"[`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html)、[`torch.rand`](https://pytorch.org/docs/stable/generated/torch.rand.html)"
" 等）及其大小参数，该函数通过将给定函数应用于扩展当前 vmap 批大小的大小，生成一个随机值的批量张量。"

#: ../../../src/evox/core/_vmap_fix.py:241
#: ../../../src/evox/core/_vmap_fix.py:248
msgid "A function that generates a tensor of random values."
msgstr "生成随机值的张量的函数。"

#: ../../../src/evox/core/_vmap_fix.py:242
msgid "The size arguments to the given function."
msgstr "给定函数的大小参数。"

#: ../../../src/evox/core/_vmap_fix.py:243
#: ../../../src/evox/core/_vmap_fix.py:250
msgid "The keyword arguments to the given function."
msgstr "给定函数的关键字参数。"

#: ../../../src/evox/core/_vmap_fix.py:245
#: ../../../src/evox/core/_vmap_fix.py:252
msgid "The batched tensor of random values."
msgstr "随机值的批量张量。"

#: ../../../src/evox/core/_vmap_fix.py:243
msgid ""
"Given a random function (e.g. "
"[`torch.randn_like`](https://pytorch.org/docs/stable/generated/torch.randn_like.html),"
" "
"[`torch.rand_like`](https://pytorch.org/docs/stable/generated/torch.rand_like.html),"
" etc.) and a tensor, this function generates a batched tensor of random "
"values by applying the given function to the tensor extended with the "
"current vmap batch size."
msgstr ""
"给定一个随机函数（例如 "
"[`torch.randn_like`](https://pytorch.org/docs/stable/generated/torch.randn_like.html)、[`torch.rand_like`](https://pytorch.org/docs/stable/generated/torch.rand_like.html)"
" 等）和一个张量， 此函数通过将给定函数应用于当前 vmap 批次大小扩展的张量，生成一个批量的随机值张量。"

#: ../../../src/evox/core/_vmap_fix.py:249
msgid "The tensor to generate random values like."
msgstr "生成随机值的张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:248
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:258
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:268
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:278
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:288
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:298
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:308
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:318
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:328
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:338
#: ../../source/apidocs/evox/evox.core.module.md:522
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:87
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:57
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:52
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:63
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:74
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:85
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:96
#, fuzzy
msgid "None"
msgstr "Notes"

#: ../../../src/evox/core/_vmap_fix.py:438
msgid ""
"This function adjusts the input tensor `value` to match the batch dimensions"
" of `current_value`, which is assumed to be a batched tensor. If `value` is "
"already a batched tensor or `current_value` is not a batched tensor, it "
"returns `value` unchanged."
msgstr ""
"该函数将输入张量 `value` 调整为匹配 `current_value` 的批次维度，后者被假设为批次张量。如果 `value` 已经是批次张量或者"
" `current_value` 不是批次张量，它会返回 `value` 不变。"

#: ../../../src/evox/core/_vmap_fix.py:443
msgid ""
"The tensor to be aligned. If not a torch.Tensor, it is returned unchanged."
msgstr "要对齐的张量。如果不是一个 torch.Tensor，则保持不变返回。"

#: ../../../src/evox/core/_vmap_fix.py:445
msgid ""
"The reference batched tensor. If None or not a batched tensor, value is "
"returned unchanged."
msgstr "引用批量张量。如果是 None 或者不是批量张量，则返回的值保持不变。"

#: ../../../src/evox/core/_vmap_fix.py:449
msgid ""
"The input value aligned with the batch dimensions of current_value, if "
"applicable."
msgstr "输入值与当前值的批次维度对齐（如果适用）。"

#: ../../../src/evox/core/_vmap_fix.py:452
msgid ""
"When vectorized-mapping, it unwraps the batched tensor to print the "
"underlying values. Otherwise, the function behaves like "
"`format.format(*args, **kwargs)`."
msgstr "在向量化映射时，它会展开批量张量以打印底层值。否则，该函数的行为类似于 `format.format(*args, **kwargs)`。"

#: ../../../src/evox/core/_vmap_fix.py:454
msgid "A string format."
msgstr "字符串格式。"

#: ../../../src/evox/core/_vmap_fix.py:455
#, fuzzy
msgid "The positional tensor."
msgstr "状态。"

#: ../../../src/evox/core/_vmap_fix.py:456
#, fuzzy
msgid "The unchanged tensor."
msgstr "缩放因子"

#: ../../source/apidocs/evox/evox.core.components.md:1
msgid "{py:mod}`evox.core.components`"
msgstr "{py:mod}`evox.core.components`"

#: ../../source/apidocs/evox/evox.core.components.md:18
msgid "{py:obj}`Algorithm <evox.core.components.Algorithm>`"
msgstr "{py:obj}`Algorithm <evox.core.components.Algorithm>`"

#: ../../../src/evox/core/components.py:20
#: ../../../src/evox/core/components.py:45
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:22
msgid "{py:obj}`Problem <evox.core.components.Problem>`"
msgstr "{py:obj}`Problem <evox.core.components.Problem>`"

#: ../../../src/evox/core/components.py:24
#: ../../../src/evox/core/components.py:86
#, fuzzy
msgid "Base class for all problems"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:26
msgid "{py:obj}`Workflow <evox.core.components.Workflow>`"
msgstr "{py:obj}`Workflow <evox.core.components.Workflow>`"

#: ../../../src/evox/core/components.py:28
#: ../../../src/evox/core/components.py:110
#, fuzzy
msgid "The base class for workflow."
msgstr "所有EvoX模块的基础类。"

#: ../../source/apidocs/evox/evox.core.components.md:30
msgid "{py:obj}`Monitor <evox.core.components.Monitor>`"
msgstr "{py:obj}`Monitor <evox.core.components.Monitor>`"

#: ../../../src/evox/core/components.py:32
#: ../../../src/evox/core/components.py:142
#, fuzzy
msgid "The monitor base class."
msgstr "问题类"

#: ../../source/apidocs/evox/evox.core.components.md:42
#: ../../source/apidocs/evox/evox.core.components.md:83
#: ../../source/apidocs/evox/evox.core.components.md:107
#: ../../source/apidocs/evox/evox.core.components.md:139
msgid "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"

#: ../../../src/evox/core/components.py:48
msgid ""
"If a subclass have defined `trace_impl` of `step`, its corresponding "
"`init_step` must be overwritten even though nothing special is to be "
"included due to Python's object-oriented limitations."
msgstr ""
"如果子类定义了 `step` 的 `trace_impl` 方法，即使不需要添加任何特殊内容，由于 Python 对象模型的限制，其对应的 "
"`init_step` 方法必须被覆盖重写。"

#: ../../../src/evox/core/components.py:116
#: ../../../src/evox/core/components.py:148
#: ../../../src/evox/core/module.py:47 ../../../src/evox/core/module.py:51
#: ../../../src/evox/core/module.py:92 ../../../src/evox/core/module.py:232
#, fuzzy
msgid "Initialize the ModuleBase."
msgstr "初始化这个模块和所有的子模块"

#: ../../../src/evox/core/components.py:118
#: ../../../src/evox/core/components.py:150
#: ../../../src/evox/core/module.py:49 ../../../src/evox/core/module.py:53
#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:234
msgid "Variable length argument list, passed to the parent class initializer."
msgstr "可变长度参数列表，传递给父类的初始化函数。"

#: ../../../src/evox/core/components.py:119
#: ../../../src/evox/core/components.py:151
#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:54
#: ../../../src/evox/core/module.py:95 ../../../src/evox/core/module.py:235
msgid "Arbitrary keyword arguments, passed to the parent class initializer."
msgstr "任意关键字参数，传递给父类初始化器。"

#: ../../../src/evox/core/components.py:121
#: ../../../src/evox/core/components.py:153
#: ../../../src/evox/core/module.py:52 ../../../src/evox/core/module.py:56
#: ../../../src/evox/core/module.py:97 ../../../src/evox/core/module.py:237
msgid ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."
msgstr ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."

#: ../../../src/evox/core/components.py:58
#, fuzzy
msgid "Execute the algorithm procedure for one step."
msgstr "告诉算法更多的信息"

#: ../../../src/evox/core/components.py:66
msgid ""
"Initialize the algorithm and execute the algorithm procedure for the first "
"step."
msgstr "初始化算法并执行算法过程的第一步。"

#: ../../../src/evox/core/components.py:75
msgid ""
"Evaluate the fitness at given points. This function is a proxy function of "
"`Problem.evaluate` set by workflow. By default, this functions raises "
"`NotImplementedError`."
msgstr ""
"在给定点评估适应度。这个函数是由工作流设置的 `Problem.evaluate` 的代理函数。默认情况下，这个函数会引发 "
"`NotImplementedError`。"

#: ../../../src/evox/core/components.py:79
#: ../../../src/evox/core/components.py:101
msgid "The population."
msgstr "种群。"

#: ../../../src/evox/core/components.py:81
#: ../../../src/evox/core/components.py:103
#, fuzzy
msgid "The fitness."
msgstr "适应度值"

#: ../../../src/evox/core/components.py:99
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: ../../../src/evox/core/components.py:106
msgid ""
"If this function contains external evaluations that cannot be JIT by "
"`torch.jit`, please wrap it with `torch.jit.ignore`."
msgstr "如果此函数包含无法通过 `torch.jit` JIT 的外部评估，请使用 `torch.jit.ignore` 对其进行包装。"

#: ../../../src/evox/core/components.py:123
#: ../../../src/evox/workflows/std_workflow.py:105
msgid "Perform the first optimization step of the workflow."
msgstr "用于让工作流执行一步的函数。"

#: ../../../src/evox/core/components.py:131
msgid "The basic function to step a workflow."
msgstr "基本功能以逐步执行工作流。"

#: ../../../src/evox/core/components.py:144
msgid ""
"Monitors are used to monitor the evolutionary process. They contains a set "
"of callbacks, which will be called at specific points during the execution "
"of the workflow. Monitor itself lives outside the main workflow, so jit is "
"not required."
msgstr ""
"监视器用于监控进化过程。它们包含一组回调，这些回调将在工作流执行的特定时刻被调用。Monitor 本身位于主工作流之外，因此不需要 jit。"

#: ../../../src/evox/core/components.py:149
msgid ""
"To implements a monitor, implement your own callbacks and override the hooks"
" method. The hooks method should return a list of strings, which are the "
"names of the callbacks. Currently the supported callbacks are:"
msgstr ""
"要实现一个监视器，您需要实现自己的回调并重写 hooks 方法。hooks 方法应返回一个字符串列表，这些字符串是回调的名称。目前支持的回调有："

#: ../../../src/evox/core/components.py:153
msgid "`post_ask`, `pre_eval`, `post_eval`, and `pre_tell`."
msgstr "`post_ask`、`pre_eval`、`post_eval` 和 `pre_tell`。"

#: ../../../src/evox/core/components.py:155
msgid "Set the static variables according to `config`."
msgstr "根据 `config` 设置静态变量。"

#: ../../../src/evox/core/components.py:157
#, fuzzy
msgid "The configuration."
msgstr "种群。"

#: ../../../src/evox/core/components.py:159
#: ../../../src/evox/core/module.py:247
#, fuzzy
msgid "This module."
msgstr "这个模块的状态。"

#: ../../../src/evox/core/components.py:163
msgid "The hook function to be executed before the solution transformation."
msgstr "解决方案转换前执行的钩子函数。"

#: ../../../src/evox/core/components.py:165
msgid ""
"The population (candidate solutions) before the solution transformation."
msgstr "种群（候选解）的初始演化状态"

#: ../../../src/evox/core/components.py:171
msgid "The hook function to be executed after the solution transformation."
msgstr "解决方案转换后执行的钩子函数。"

#: ../../../src/evox/core/components.py:173
#: ../../../src/evox/core/components.py:179
msgid "The hook function to be executed before the fitness transformation."
msgstr "在适应度转换之前执行的钩子函数。"

#: ../../../src/evox/core/components.py:181
msgid "The fitnesses before the fitness transformation."
msgstr "在适应度转换之前的适应度。"

#: ../../../src/evox/core/components.py:187
msgid "The hook function to be executed after the fitness transformation."
msgstr "在适应度转换后要执行的钩子函数。"

#: ../../../src/evox/core/components.py:189
msgid "The fitnesses after the fitness transformation."
msgstr "适应度变换后的适应度值。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:1
msgid "{py:mod}`evox.core.jit_util`"
msgstr "{py:mod}`evox.core.jit_util`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:18
msgid "{py:obj}`MappedUseStateFunc <evox.core.jit_util.MappedUseStateFunc>`"
msgstr "{py:obj}`MappedUseStateFunc <evox.core.jit_util.MappedUseStateFunc>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:28
msgid "{py:obj}`vmap <evox.core.jit_util.vmap>`"
msgstr "{py:obj}`vmap <evox.core.jit_util.vmap>`"

#: ../../../src/evox/core/jit_util.py:30 ../../../src/evox/core/jit_util.py:97
msgid ""
"Vectorized map the given function to its mapped version, see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""
"向量化映射将给定的函数映射到其映射版本，更多信息请参见 "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html)。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:32
msgid "{py:obj}`_clone_inputs <evox.core.jit_util._clone_inputs>`"
msgstr "{py:obj}`_clone_inputs <evox.core.jit_util._clone_inputs>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:36
msgid ""
"{py:obj}`_form_positional_inputs "
"<evox.core.jit_util._form_positional_inputs>`"
msgstr ""
"{py:obj}`_form_positional_inputs "
"<evox.core.jit_util._form_positional_inputs>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:40
msgid "{py:obj}`jit <evox.core.jit_util.jit>`"
msgstr "{py:obj}`jit <evox.core.jit_util.jit>`"

#: ../../../src/evox/core/jit_util.py:42
#: ../../../src/evox/core/jit_util.py:118
msgid ""
"Just-In-Time (JIT) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""
"通过 "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) 或 "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`) 对给定的 `func` 进行即时编译 (JIT)。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:52
msgid "{py:obj}`T <evox.core.jit_util.T>`"
msgstr "{py:obj}`T <evox.core.jit_util.T>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:64
#: ../../source/apidocs/evox/evox.core.module.md:515
msgid "Bases: {py:obj}`typing.Protocol`"
msgstr "Bases: {py:obj}`typing.Protocol`"

#: ../../../src/evox/core/jit_util.py:71
#, fuzzy
msgid "Initialize the state of the mapped function."
msgstr "为问题初始化设置。"

#: ../../../src/evox/core/jit_util.py:73
msgid ""
"The batch size of the state. If None, the batch size of the state is "
"indicated by VMAP_DIM_CONST. Defaults to None."
msgstr "状态的批处理大小。如果为 None，则状态的批处理大小由 VMAP_DIM_CONST 指示。默认为 None。"

#: ../../../src/evox/core/jit_util.py:74
msgid ""
"Whether to torch.expand or torch.repeat the state tensors to the given batch"
" size."
msgstr "是否将状态张量使用 torch.expand 或 torch.repeat 扩展到给定的批量大小。"

#: ../../../src/evox/core/jit_util.py:76
msgid ""
"The initialized state, with the same keys as the state of the original "
"function."
msgstr "初始化状态，具有与原始函数状态相同的键。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:87
#: ../../source/apidocs/evox/evox.core.module.md:192
#: ../../source/apidocs/evox/evox.core.module.md:601
#: ../../source/apidocs/evox/evox.core.module.md:635
msgid "'TypeVar(...)'"
msgstr "TypeVar(...)"

#: ../../../src/evox/core/jit_util.py:99
msgid "The function to be mapped. See torch.vmap."
msgstr "要映射的函数。请参见 torch.vmap。"

#: ../../../src/evox/core/jit_util.py:100
msgid "The inputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr "输入的批次维度。请参阅 torch.vmap。默认为 0。"

#: ../../../src/evox/core/jit_util.py:101
msgid "The outputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr "输出的批次维度。请参见 torch.vmap。默认为 0。"

#: ../../../src/evox/core/jit_util.py:102
msgid ""
"Whether to trace the mapped function with torch.jit.trace or simply use "
"torch.vmap. NOTICE: if trace=False`, all of the following inputs related to "
"tracing will be ignored."
msgstr ""
"是否使用 `torch.jit.trace` 追踪已映射的函数，还是简单地使用 `torch.vmap`。注意：如果 "
"`trace=False`，所有与追踪相关的输入将被忽略。"

#: ../../../src/evox/core/jit_util.py:103
msgid ""
"The ndim of the expected inputs of the batched function; thus, it must be at"
" least 1. Giving a single integer means same ndim for all inputs. Defaults "
"to 1."
msgstr "批处理函数期望输入的维度（ndim）；因此，它必须至少为 1。给定一个整数意味着所有输入具有相同的维度。默认值为 1。"

#: ../../../src/evox/core/jit_util.py:104
#, fuzzy
msgid "The . Defaults to None."
msgstr "数据集名称。"

#: ../../../src/evox/core/jit_util.py:105
msgid "description. Defaults to None."
msgstr "描述。默认为 None。"

#: ../../../src/evox/core/jit_util.py:106
#: ../../../src/evox/core/jit_util.py:132
msgid ""
"Strictly check the inputs or not. See torch.jit.trace. Defaults to False."
msgstr "严格检查输入与否。参见 torch.jit.trace。默认为 False。"

#: ../../../src/evox/core/jit_util.py:107
#: ../../../src/evox/core/jit_util.py:133
msgid ""
"Check the traced function or not. See torch.jit.trace. Defaults to False."
msgstr "检查是否跟踪了该函数。参见 torch.jit.trace。默认为 False。"

#: ../../../src/evox/core/jit_util.py:108
msgid ""
"The optional batched current state for a use_state wrapped function. If "
"None, a new batched state will be returned for each call of "
"init_state(None). Ignored when func is not wrapped by use_state. Defaults to"
" None."
msgstr ""
"可选的批处理当前状态，用于被 use_state 包裹的函数。如果为 None，则每次调用 init_state(None) "
"时将返回一个新的批处理状态。当 func 没有被 use_state 包裹时，该选项被忽略。默认值为 None。"

#: ../../../src/evox/core/jit_util.py:109
msgid ""
"When tracing, the example inputs may be broadcasted with additional "
"dimension(s) of size VMAP_DIM_CONST. Defaults to 13."
msgstr "依赖于 trace 时，示例输入可能会添加一个或多个大小为 VMAP_DIM_CONST 的维度。默认值：13。"

#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#, fuzzy
msgid "Raises"
msgstr "Raises"

#: ../../../src/evox/core/jit_util.py:111
msgid "If the function argument types are not supported"
msgstr "如果函数参数类型不支持"

#: ../../../src/evox/core/jit_util.py:113
msgid ""
"The “batched” (vectorized mapped) version of func. If the given func is "
"wrapped by use_state, the returned function will have a "
"init_state(batch_size: int) -> batched_state or init_state(None) -> "
"batched_state."
msgstr ""
"“批处理”（向量化映射）版本的 func。如果给定的 func 被 use_state 包裹，返回的函数将具有 "
"init_state(batch_size: int) -> batched_state 或 init_state(None) -> "
"batched_state。"

#: ../../../src/evox/core/jit_util.py:120
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260004
msgid ""
"This function wrapper effectively deals with nested JIT and vector map "
"(`vmap`) expressions like `jit(func1)` -> `vmap` -> `jit(func2)`, preventing"
" possible errors."
msgstr ""
"该函数包装器有效处理嵌套的 JIT 和向量映射 (`vmap`) 表达式，如 `jit(func1)` -> `vmap` -> "
"`jit(func2)`，从而防止可能出现的错误。"

#: ../../../src/evox/core/jit_util.py:128
msgid "The target function to be JIT"
msgstr "要进行 JIT 的目标函数"

#: ../../../src/evox/core/jit_util.py:129
msgid ""
"Whether using torch.jit.trace or torch.jit.script to JIT. Defaults to False."
msgstr "是否使用 torch.jit.trace 或 torch.jit.script 进行 JIT。默认为 False。"

#: ../../../src/evox/core/jit_util.py:130
#, fuzzy
msgid "Whether JIT lazily or immediately. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/jit_util.py:131
msgid ""
"When lazy=False, the example inputs must be provided immediately, otherwise "
"ignored. Can be only positional arguments (a tuple), only keyword arguments "
"(a dict), or a tuple of positional arguments and keyword arguments (a tuple "
"of tuple and dict). Defaults to None."
msgstr ""
"当 lazy=False 时，示例输入必须立即提供，否则将被忽略。可以是仅位置参数（一个 tuple），仅关键字参数（一个 "
"dict），或位置参数和关键字参数的组合（一个 tuple 和 dict 的 tuple）。Defaults to None。"

#: ../../../src/evox/core/jit_util.py:134
#, fuzzy
msgid "Whether func is a generator or not. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/jit_util.py:135
msgid ""
"Whether to use torch.jit.trace directly (no_cache=True) or run the function "
"to make it cache internals when lazy=False. Defaults to False. Has no effect"
" when trace=False. This value must be set to False if the function contains "
"a instant call to torch.jit.trace which will be used inside a "
"torch.jit.script so that the JIT traced result shall be cached."
msgstr ""
"是否直接使用 torch.jit.trace （no_cache=True）或在 lazy=False 时运行函数以使其缓存内部内容。默认为 "
"False。当 trace=False 时没有效果。如果函数包含对 torch.jit.trace 的即时调用，并将在 torch.jit.script"
" 内部使用，则该值必须设置为 False，以便 JIT 跟踪的结果将被缓存。"

#: ../../../src/evox/core/jit_util.py:136
msgid ""
"Whether to return the dummy output of func as the second output or not. "
"Defaults to False. Has no effect when trace=False or lazy=True or "
"no_cache=True."
msgstr ""
"是否将 `func` 的 dummy 输出作为第二个输出返回默认值为False。如果 `trace=False` 或 `lazy=True` 或 "
"`no_cache=True` 则无效。"

#: ../../../src/evox/core/jit_util.py:137
msgid ""
"The manual seed to be set before each running of the function. Defaults to "
"None. Has no effect when trace=False. None means no manual seed will be set."
" Notice that any value other than None changes the GLOBAL random seed."
msgstr ""
"在每次运行该函数之前要设置的手动种子。默认为 None。当 trace=False 时没有效果。None "
"表示不设置手动种子。注意，任何其他值都将改变全局随机种子。"

#: ../../../src/evox/core/jit_util.py:139
msgid "The JIT version of func"
msgstr "func 的 JIT 版本"

#: ../../source/apidocs/evox/evox.core.module.md:1
msgid "{py:mod}`evox.core.module`"
msgstr "{py:mod}`evox.core.module`"

#: ../../source/apidocs/evox/evox.core.module.md:18
msgid "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"
msgstr "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"

#: ../../../src/evox/core/module.py:20 ../../../src/evox/core/module.py:226
#, fuzzy
msgid "The base module for all algorithms and problems in the library."
msgstr "EvoX中的自定义算法和问题"

#: ../../source/apidocs/evox/evox.core.module.md:22
msgid "{py:obj}`_WrapClassBase <evox.core.module._WrapClassBase>`"
msgstr "{py:obj}`_WrapClassBase <evox.core.module._WrapClassBase>`"

#: ../../source/apidocs/evox/evox.core.module.md:26
msgid "{py:obj}`UseStateFunc <evox.core.module.UseStateFunc>`"
msgstr "{py:obj}`UseStateFunc <evox.core.module.UseStateFunc>`"

#: ../../source/apidocs/evox/evox.core.module.md:36
msgid "{py:obj}`_if_none <evox.core.module._if_none>`"
msgstr "{py:obj}`_if_none <evox.core.module._if_none>`"

#: ../../source/apidocs/evox/evox.core.module.md:40
msgid "{py:obj}`_is_magic <evox.core.module._is_magic>`"
msgstr "{py:obj}`_is_magic <evox.core.module._is_magic>`"

#: ../../source/apidocs/evox/evox.core.module.md:44
msgid "{py:obj}`Parameter <evox.core.module.Parameter>`"
msgstr "{py:obj}`Parameter <evox.core.module.Parameter>`"

#: ../../../src/evox/core/module.py:46 ../../../src/evox/core/module.py:202
msgid "Wraps a value as parameter with `requires_grad=False`."
msgstr "将一个值包装为参数，`requires_grad=False`。"

#: ../../source/apidocs/evox/evox.core.module.md:48
msgid "{py:obj}`Mutable <evox.core.module.Mutable>`"
msgstr "{py:obj}`Mutable <evox.core.module.Mutable>`"

#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:209
msgid "Wraps a value as a mutable tensor."
msgstr "将值包装为可变张量。"

#: ../../source/apidocs/evox/evox.core.module.md:52
msgid ""
"{py:obj}`assign_load_state_dict <evox.core.module.assign_load_state_dict>`"
msgstr ""
"{py:obj}`assign_load_state_dict <evox.core.module.assign_load_state_dict>`"

#: ../../../src/evox/core/module.py:54 ../../../src/evox/core/module.py:216
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants."
msgstr "将参数和缓冲区从 state_dict 复制到此模块及其后代。"

#: ../../source/apidocs/evox/evox.core.module.md:56
msgid "{py:obj}`use_state_context <evox.core.module.use_state_context>`"
msgstr "{py:obj}`use_state_context <evox.core.module.use_state_context>`"

#: ../../../src/evox/core/module.py:58 ../../../src/evox/core/module.py:382
msgid "A context manager to set the value of `using_state` temporarily."
msgstr "一个上下文管理器，用于临时设置 `using_state` 的值。"

#: ../../source/apidocs/evox/evox.core.module.md:60
msgid ""
"{py:obj}`trace_caching_state_context "
"<evox.core.module.trace_caching_state_context>`"
msgstr ""
"{py:obj}`trace_caching_state_context "
"<evox.core.module.trace_caching_state_context>`"

#: ../../../src/evox/core/module.py:62 ../../../src/evox/core/module.py:389
msgid ""
"A context manager to set the value of `trace_caching_state` temporarily."
msgstr "一个上下文管理器，用于暂时设置 `trace_caching_state` 的值。"

#: ../../source/apidocs/evox/evox.core.module.md:64
msgid "{py:obj}`is_using_state <evox.core.module.is_using_state>`"
msgstr "{py:obj}`is_using_state <evox.core.module.is_using_state>`"

#: ../../../src/evox/core/module.py:66 ../../../src/evox/core/module.py:396
msgid "Get the current state of the `using_state`."
msgstr "获取当前的 `using_state` 状态。"

#: ../../source/apidocs/evox/evox.core.module.md:68
msgid ""
"{py:obj}`is_trace_caching_state <evox.core.module.is_trace_caching_state>`"
msgstr ""
"{py:obj}`is_trace_caching_state <evox.core.module.is_trace_caching_state>`"

#: ../../../src/evox/core/module.py:70 ../../../src/evox/core/module.py:403
msgid "Get the current state of the `trace_caching_state`."
msgstr "获取当前的 `trace_caching_state` 状态。"

#: ../../source/apidocs/evox/evox.core.module.md:72
msgid ""
"{py:obj}`tracing_or_using_state <evox.core.module.tracing_or_using_state>`"
msgstr ""
"{py:obj}`tracing_or_using_state <evox.core.module.tracing_or_using_state>`"

#: ../../../src/evox/core/module.py:74 ../../../src/evox/core/module.py:410
msgid ""
"Check if we are currently JIT tracing (inside a `torch.jit.trace`), in a "
"`use_state_context`, or in a `trace_caching_state`."
msgstr ""
"检查我们当前是否在进行 JIT 跟踪（在 `torch.jit.trace` 内），在 `use_state_context` 中，或者在 "
"`trace_caching_state` 中。"

#: ../../source/apidocs/evox/evox.core.module.md:76
msgid "{py:obj}`_get_vars <evox.core.module._get_vars>`"
msgstr "{py:obj}`_get_vars <evox.core.module._get_vars>`"

#: ../../source/apidocs/evox/evox.core.module.md:80
msgid "{py:obj}`use_state <evox.core.module.use_state>`"
msgstr "{py:obj}`use_state <evox.core.module.use_state>`"

#: ../../../src/evox/core/module.py:82 ../../../src/evox/core/module.py:574
msgid ""
"Transform the given stateful function (which in-place alters `nn.Module`s) "
"to a pure-functional version that receives an additional `state` parameter "
"(of type `Dict[str, torch.Tensor]`) and returns the altered state "
"additionally."
msgstr ""
"将给定的有状态函数（在原地更改 `nn.Module`s）转换为一个纯函数版本，该版本接收一个额外的 `state` 参数（类型为 `Dict[str,"
" torch.Tensor]`），并额外返回更改后的状态。"

#: ../../source/apidocs/evox/evox.core.module.md:84
msgid "{py:obj}`trace_impl <evox.core.module.trace_impl>`"
msgstr "{py:obj}`trace_impl <evox.core.module.trace_impl>`"

#: ../../../src/evox/core/module.py:86 ../../../src/evox/core/module.py:611
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a trace-JIT-time proxy of the given `target` method."
msgstr "用于注释的辅助函数，表明被包装的方法应被视为给定`target`方法的trace-JIT-time代理。"

#: ../../source/apidocs/evox/evox.core.module.md:88
msgid "{py:obj}`vmap_impl <evox.core.module.vmap_impl>`"
msgstr "{py:obj}`vmap_impl <evox.core.module.vmap_impl>`"

#: ../../../src/evox/core/module.py:90 ../../../src/evox/core/module.py:628
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a vmap-JIT-time proxy of the given `target` method."
msgstr "一个辅助函数，用于标记被包装的方法应被视为给定 `target` 方法的 vmap-JIT 时间代理。"

#: ../../source/apidocs/evox/evox.core.module.md:92
msgid "{py:obj}`jit_class <evox.core.module.jit_class>`"
msgstr "{py:obj}`jit_class <evox.core.module.jit_class>`"

#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:655
msgid ""
"A helper function used to JIT script (`torch.jit.script`) or trace "
"(`torch.jit.trace_module`) all member methods of class `cls`."
msgstr ""
"用于 JIT 脚本 (`torch.jit.script`) 或跟踪 (`torch.jit.trace_module`) 类 `cls` "
"的所有成员方法的辅助函数。"

#: ../../source/apidocs/evox/evox.core.module.md:104
msgid ""
"{py:obj}`_WRAPPING_MODULE_NAME <evox.core.module._WRAPPING_MODULE_NAME>`"
msgstr ""
"{py:obj}`_WRAPPING_MODULE_NAME <evox.core.module._WRAPPING_MODULE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:108
msgid "{py:obj}`ParameterT <evox.core.module.ParameterT>`"
msgstr "{py:obj}`ParameterT <evox.core.module.ParameterT>`"

#: ../../source/apidocs/evox/evox.core.module.md:112
msgid "{py:obj}`_using_state <evox.core.module._using_state>`"
msgstr "{py:obj}`_using_state <evox.core.module._using_state>`"

#: ../../source/apidocs/evox/evox.core.module.md:116
msgid "{py:obj}`_trace_caching_state <evox.core.module._trace_caching_state>`"
msgstr ""
"{py:obj}`_trace_caching_state <evox.core.module._trace_caching_state>`"

#: ../../source/apidocs/evox/evox.core.module.md:120
msgid "{py:obj}`_SUBMODULE_PREFIX <evox.core.module._SUBMODULE_PREFIX>`"
msgstr "{py:obj}`_SUBMODULE_PREFIX <evox.core.module._SUBMODULE_PREFIX>`"

#: ../../source/apidocs/evox/evox.core.module.md:124
msgid "{py:obj}`_USE_STATE_NAME <evox.core.module._USE_STATE_NAME>`"
msgstr "{py:obj}`_USE_STATE_NAME <evox.core.module._USE_STATE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:128
msgid "{py:obj}`_STATE_ARG_NAME <evox.core.module._STATE_ARG_NAME>`"
msgstr "{py:obj}`_STATE_ARG_NAME <evox.core.module._STATE_ARG_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:132
msgid "{py:obj}`_EMPTY_NAME <evox.core.module._EMPTY_NAME>`"
msgstr "{py:obj}`_EMPTY_NAME <evox.core.module._EMPTY_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:136
msgid ""
"{py:obj}`_TORCHSCRIPT_MODIFIER <evox.core.module._TORCHSCRIPT_MODIFIER>`"
msgstr ""
"{py:obj}`_TORCHSCRIPT_MODIFIER <evox.core.module._TORCHSCRIPT_MODIFIER>`"

#: ../../source/apidocs/evox/evox.core.module.md:140
msgid "{py:obj}`_TRACE_WRAP_NAME <evox.core.module._TRACE_WRAP_NAME>`"
msgstr "{py:obj}`_TRACE_WRAP_NAME <evox.core.module._TRACE_WRAP_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:144
msgid "{py:obj}`T <evox.core.module.T>`"
msgstr "{py:obj}`T <evox.core.module.T>`"

#: ../../source/apidocs/evox/evox.core.module.md:148
msgid "{py:obj}`_VMAP_WRAP_NAME <evox.core.module._VMAP_WRAP_NAME>`"
msgstr "{py:obj}`_VMAP_WRAP_NAME <evox.core.module._VMAP_WRAP_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:152
msgid "{py:obj}`ClassT <evox.core.module.ClassT>`"
msgstr "{py:obj}`ClassT <evox.core.module.ClassT>`"

#: ../../source/apidocs/evox/evox.core.module.md:156
msgid "{py:obj}`_BASE_NAME <evox.core.module._BASE_NAME>`"
msgstr "{py:obj}`_BASE_NAME <evox.core.module._BASE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:168
msgid "'__wrapping_module__'"
msgstr "'__wrapping_module__'"

#: ../../../src/evox/core/module.py:204
#, fuzzy
msgid "The parameter value."
msgstr "参数"

#: ../../../src/evox/core/module.py:205
#, fuzzy
msgid "The dtype of the parameter. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/core/module.py:206
#, fuzzy
msgid "The device of the parameter. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/core/module.py:207
#, fuzzy
msgid "Whether the parameter requires gradient. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/module.py:209
#, fuzzy
msgid "The parameter."
msgstr "参数"

#: ../../../src/evox/core/module.py:211
msgid "The value to be wrapped."
msgstr "要包装的值。"

#: ../../../src/evox/core/module.py:212
#, fuzzy
msgid "The dtype of the tensor. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:213
#, fuzzy
msgid "The device of the tensor. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:215
msgid "The wrapped tensor."
msgstr "被包装的张量。"

#: ../../../src/evox/core/module.py:218
msgid ""
"This method is used to mimic the behavior of `ModuleBase.load_state_dict` so"
" that a regular `nn.Module` can be used with `vmap`."
msgstr ""
"该方法用来模仿 `ModuleBase.load_state_dict` 的行为，使得一个普通的 `nn.Module` 能被用于 `vmap` 中。"

#: ../../source/apidocs/evox/evox.core.module.md:223
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:32
msgid "Bases: {py:obj}`torch.nn.Module`"
msgstr "Bases: {py:obj}`torch.nn.Module`"

#: ../../../src/evox/core/module.py:229
msgid "This module is an object-oriented one that can contain mutable values."
msgstr "该模块是一种面向对象的模块，可以包含可变值。"

#: ../../../src/evox/core/module.py:230
msgid ""
"Functional programming model is supported via `self.state_dict(...)` and "
"`self.load_state_dict(...)`."
msgstr ""
"支持功能编程模型是通过 `self.state_dict(...)` 和 `self.load_state_dict(...)` 来实现的。"

#: ../../../src/evox/core/module.py:231
msgid ""
"The module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr "建议将非静态成员的模块初始化写在重写的 `setup`（或其他成员方法）中，而不是 `__init__` 中。"

#: ../../../src/evox/core/module.py:232
msgid ""
"Basically, predefined submodule(s) which will be ADDED to this module and "
"accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr "基本上，预定义的子模块应被视为“非静态成员”，这些模块将被添加到此模块并在成员方法中稍后访问，而其他任何成员应视为“静态成员”。"

#: ../../../src/evox/core/module.py:235
msgid "Static methods to be JIT shall be defined as is, e.g.,"
msgstr "静态方法将按原样定义为 JIT，例如，"

#: ../../../src/evox/core/module.py:241
msgid ""
"If a class member function with python dynamic control flows like `if` were "
"to be JIT, a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""
"如果一个类成员函数具有像 `if` 这样的 Python 动态控制流，并且需要 JIT，则应使用一个单独的静态方法，格式为 `jit(..., "
"trace=False)` 或 `torch.jit.script_if_tracing`："

#: ../../../src/evox/core/module.py:261
msgid ""
"`ModuleBase` is usually used with `jit_class` to automatically JIT all non-"
"magic member methods:"
msgstr "`ModuleBase` 通常与 `jit_class` 一起使用，以自动 JIT 所有非魔法成员方法："

#: ../../../src/evox/core/module.py:244
msgid ""
"Setup the module. Module initialization lines should be written in the "
"overwritten method of `setup` rather than `__init__`."
msgstr "设置模块。模块初始化行应写在重写的 `setup` 方法中，而不是 `__init__` 中。"

#: ../../../src/evox/core/module.py:250
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable initialization cannot. Therefore, multiple calls of `setup` for "
"multiple initializations are possible."
msgstr "静态初始化仍然可以在 `__init__` 中编写，而可变初始化则不可以。因此，对于多个初始化，可以多次调用 `setup`。"

#: ../../../src/evox/core/module.py:252
msgid ""
"Prepares the control flow state of the module by collecting and merging the "
"state and non-local variables from the specified target functions."
msgstr "准备通过收集和合并指定目标函数的状态和非本地变量来准备模块的控制流状态。"

#: ../../../src/evox/core/module.py:254
msgid ""
"This function is used alongside with `after_control_flow()` to enable your "
"control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `after_control_flow()`."
msgstr ""
"**用于控制流操作（控制分支等）的前向操作**\n"
"\n"
"本函数与 `after_control_flow()` 配合使用，确保控制流操作（ `utils.control_flow.*` ）正确处理副作用。如果控制流操作没有副作用，则完全可以忽略本函数和 `after_control_flow()`。"

#: ../../../src/evox/core/module.py:256
msgid "Functions whose non-local variables are to be collected."
msgstr "收集非本地变量的函数。"

#: ../../../src/evox/core/module.py:257
msgid "See torch.nn.Module.state_dict(..., keep_vars). Defaults to True."
msgstr "See torch.nn.Module.state_dict(..., keep_vars). 默认为 True."

#: ../../../src/evox/core/module.py:259
msgid ""
"A tuple containing the merged state dictionary, a list of state keys, and a "
"list of non-local variable names."
msgstr "一个包含合并状态字典、状态键列表和非局部变量名称列表的元组。"

#: ../../../src/evox/core/module.py:261
msgid ""
"If not all target functions are local, global, or this class member "
"functions"
msgstr "如果不是所有目标函数都是局部的、全局的或这个类的成员函数"

#: ../../../src/evox/core/module.py:263
#: ../../../src/evox/problems/neuroevolution/brax.py:128
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:86
msgid "Warning"
msgstr "警告"

#: ../../../src/evox/core/module.py:264
msgid ""
"The non-local variables collected here can ONLY be used as read-only ones. "
"In-place modifications to these variables may not raise any error and "
"silently produce incorrect results."
msgstr "此处收集的非本地变量只能用作只读变量。对这些变量的就地修改可能不会引发任何错误，并在不经意间产生不正确的结果。"

#: ../../../src/evox/core/module.py:260
msgid ""
"Restores the module state to the one before `prepare_control_flow` from the "
"given `state` and returns the non-local variables collected in "
"`prepare_control_flow`."
msgstr "将模块状态恢复到在给定 `state` 之前的状态，并返回在 `prepare_control_flow` 中收集的非本地变量。"

#: ../../../src/evox/core/module.py:262
msgid ""
"This function is used alongside with `prepare_control_flow()` to enable your"
" control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `prepare_control_flow()`."
msgstr ""
"此函数与 `prepare_control_flow()` 一起使用，以使您的控制流操作 (`utils.control_flow.*`) "
"正确处理副作用。如果控制流操作没有副作用，您可以安全地忽略此函数和 `prepare_control_flow()`。"

#: ../../../src/evox/core/module.py:264
msgid "The state dictionary to restore the module state from."
msgstr "用于从中恢复模块状态的状态字典。"

#: ../../../src/evox/core/module.py:265
msgid "The keys of the state dictionary that represent the module state."
msgstr "表示模块状态的状态字典的键。"

#: ../../../src/evox/core/module.py:266
msgid ""
"The keys of the state dictionary that represent the non-local variables."
msgstr "表示非局部变量的状态字典的键。"

#: ../../../src/evox/core/module.py:268
msgid "The non-local variables dictionary collected in prepare_control_flow."
msgstr "在prepare_control_flow中收集的非局部变量字典。"

#: ../../../src/evox/core/module.py:271
msgid "See `prepare_control_flow()`."
msgstr "查看 `prepare_control_flow()` 。"

#: ../../../src/evox/core/module.py:268
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants. Overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""
"将参数和缓冲区从 state_dict 复制到此模块及其子模块中。覆盖 "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)。"

#: ../../../src/evox/core/module.py:271
msgid ""
"A dict containing parameters and buffers used to update this module. See "
"torch.nn.Module.load_state_dict."
msgstr "一个包含用于更新该模块的参数和缓冲区的字典。请参阅 torch.nn.Module.load_state_dict。"

#: ../../../src/evox/core/module.py:272
msgid ""
"Use the original torch.nn.Module.load_state_dict to copy the state_dict to "
"current state (copy=True) or use this implementation that assigns the values"
" of this module to the ones in the state_dict (copy=False). Defaults to "
"False."
msgstr ""
"使用原始的torch.nn.Module.load_state_dict来复制state_dict到当前状态（copy=True）或者使用此实现来将此模块的值分配给state_dict中的值（copy=False）。默认为False。"

#: ../../../src/evox/core/module.py:273
msgid ""
"The original arguments of torch.nn.Module.load_state_dict. Ignored if "
"copy=False."
msgstr ""
"torch.nn.Module.load_state_dict 的原始参数。\n"
"如果 copy=False，会忽略这些参数。"

#: ../../../src/evox/core/module.py:275
msgid ""
"If copy=True, returns the return of torch.nn.Module.load_state_dict; "
"otherwise, no return."
msgstr "如果 copy=True, 则返回 torch.nn.Module.load_state_dict 的返回值; 否则,不返回。"

#: ../../../src/evox/core/module.py:276
#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Define a mutable value in this module that can be accessed via `self.[name]`"
" and modified in-place."
msgstr "定义一个可变值，并将其在 `self.[name]` 中暴露出来，可以通过 `self.[name] = [值]` 来修改。"

#: ../../../src/evox/core/module.py:278
#, fuzzy
msgid "The mutable value's name."
msgstr "数据集名称。"

#: ../../../src/evox/core/module.py:279
msgid "The mutable value, can be a tuple, list, dictionary of a torch.Tensor."
msgstr "可变值可以是一个元组、列表或一个 torch.Tensor 的字典。"

#: ../../../src/evox/core/module.py:281
msgid "If the mutable value's type is not supported yet."
msgstr "如果可变值的类型尚不受支持。"

#: ../../../src/evox/core/module.py:282
msgid "If the name is invalid."
msgstr "如果名称无效。"

#: ../../../src/evox/core/module.py:328
msgid "Get the mutable value(s) stored in this list-like module."
msgstr "获取存储在此类列表模块中的可变值。"

#: ../../../src/evox/core/module.py:330 ../../../src/evox/core/module.py:339
msgid "The key used to index mutable value(s)."
msgstr "用于索引可变值的关键。"

#: ../../../src/evox/core/module.py:332
msgid "If key is out of range."
msgstr "如果键超出范围。"

#: ../../../src/evox/core/module.py:333
msgid "If key is of wrong type."
msgstr "如果 key 类型错误。"

#: ../../../src/evox/core/module.py:335
msgid "The indexed mutable value(s)."
msgstr "索引可变值。"

#: ../../../src/evox/core/module.py:336
msgid "Set the mutable value(s) stored in this list-like module."
msgstr "设置存储在此类列表模块中的可变值。"

#: ../../../src/evox/core/module.py:338
msgid "The new mutable value(s)."
msgstr "新的可变值。"

#: ../../../src/evox/core/module.py:384
msgid ""
"When entering the context, the value of `using_state` is set to "
"`new_use_state` and a token is obtained. When exiting the context, the value"
" of `using_state` is reset to its previous value."
msgstr ""
"当进入上下文时，`using_state` 的值被设置为 `new_use_state`，并获得一个令牌。当退出上下文时，`using_state` "
"的值被重置为之前的值。"

#: ../../../src/evox/core/module.py:387
#, fuzzy
msgid "The new value of using_state. Defaults to True."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:391
msgid ""
"When entering the context, the value of `trace_caching_state` is set to "
"`new_trace_caching_state` and a token is obtained. When exiting the context,"
" the value of `trace_caching_state` is reset to its previous value."
msgstr ""
"在进入上下文时，`trace_caching_state` 的值被设置为 `new_trace_caching_state` "
"并获取一个令牌。当退出上下文时，`trace_caching_state` 的值被重置为其先前的值。"

#: ../../../src/evox/core/module.py:394
#, fuzzy
msgid "The new value of trace_caching_state. Defaults to True."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:398
#, fuzzy
msgid "The current state of the using_state."
msgstr "算法的新状态"

#: ../../../src/evox/core/module.py:405
msgid "The current state of the trace_caching_state."
msgstr "当前的 trace_caching_state 状态。"

#: ../../../src/evox/core/module.py:412
msgid "True if either condition is true, False otherwise."
msgstr "如果任一条件为真，则返回 True；否则返回 False。"

#: ../../source/apidocs/evox/evox.core.module.md:417
msgid "'__submodule_'"
msgstr "'__submodule_'"

#: ../../source/apidocs/evox/evox.core.module.md:495
msgid "'__use_state__'"
msgstr "'__use_state__'"

#: ../../source/apidocs/evox/evox.core.module.md:505
msgid "'state'"
msgstr "'state'"

#: ../../../src/evox/core/module.py:533
msgid ""
"Get the cloned state of the closures of the function when it is wrapped by "
"`use_state`."
msgstr "获取函数被 `use_state` 包装时闭包的克隆状态。"

#: ../../../src/evox/core/module.py:535
#, fuzzy
msgid "Whether to clone the original state or not. Defaults to True."
msgstr "是否对整个步骤函数进行 `jit` 编译。默认值为 `True`"

#: ../../../src/evox/core/module.py:537
#, fuzzy
msgid "The cloned state of the closures."
msgstr "算法的新状态"

#: ../../../src/evox/core/module.py:541
msgid "Set the closures of the function to the given state."
msgstr "将函数的闭包设置为给定状态。"

#: ../../../src/evox/core/module.py:543
msgid ""
"The new state to set to. If state=None, the new state would be the original "
"state when the function is wrapped by use_state. Defaults to None."
msgstr "要设置的新状态。如果 state=None，那么新状态将是当函数被 use_state 包裹时的原始状态。默认值为 None。"

#: ../../source/apidocs/evox/evox.core.module.md:557
msgid "'___empty___'"
msgstr "'___empty___'"

#: ../../../src/evox/core/module.py:576
msgid "The stateful function to be transformed or its generator function."
msgstr "要转换的有状态函数或其生成函数。"

#: ../../../src/evox/core/module.py:577
msgid ""
"Whether func is a function or a function generator (e.g. a lambda that "
"returns the stateful function). Defaults to True."
msgstr "func 是一个函数还是一个函数生成器（例如，返回有状态函数的 lambda）。默认为 True。"

#: ../../../src/evox/core/module.py:579
msgid ""
"The transformed pure-functional version of func. It contains a init_state() "
"-> state attribute that returns the copy of the current state that func uses"
" and can be used as example inputs of the additional state parameter. It "
"also contains a set_state(state) attribute to set the global state to the "
"given one (of course not JIT-compatible)."
msgstr ""
"`func` 的纯函数版本。它包含一个 `init_state() -> state` 属性，该属性返回 `func` "
"使用的当前状态的副本，并可用作附加状态参数的示例输入。它还包含一个 `set_state(state)` 属性，用于将全局状态设置为给定状态（当然不兼容"
" JIT）。"

#: ../../../src/evox/core/module.py:582
msgid ""
"Since PyTorch cannot JIT or vectorized-map a function with empty dictionary,"
" list, or tuple as its input, this function transforms the given function to"
" a function WITHOUT the additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and does NOT return the altered state additionally."
msgstr ""
"由于 PyTorch 不能对输入为空字典、列表或元组的函数进行 JIT 编译或矢量映射，该函数将给定函数转换为一个没有额外 `state` 参数（类型为"
" `Dict[str, torch.Tensor]`）的函数，并且不额外返回修改后的状态。"

#: ../../source/apidocs/evox/evox.core.module.md:581
msgid "'_torchscript_modifier'"
msgstr "'_torchscript_modifier'"

#: ../../source/apidocs/evox/evox.core.module.md:591
msgid "'__trace_wrapped__'"
msgstr "'__trace_wrapped__'"

#: ../../../src/evox/core/module.py:613 ../../../src/evox/core/module.py:630
msgid "Can ONLY be used inside a `jit_class` for a member method."
msgstr "只能在 `jit_class` 中的成员方法中使用。"

#: ../../../src/evox/core/module.py:615 ../../../src/evox/core/module.py:632
msgid "The target method invoked when not tracing JIT."
msgstr "未追踪 JIT 时调用的目标方法。"

#: ../../../src/evox/core/module.py:617 ../../../src/evox/core/module.py:634
msgid "The wrapping function to annotate the member method."
msgstr "用于注解成员方法的包装函数。"

#: ../../../src/evox/core/module.py:620 ../../../src/evox/core/module.py:637
msgid ""
"The target function and the annotated function MUST have same input/output "
"signatures (e.g. number of arguments and types); otherwise, the resulting "
"behavior is UNDEFINED."
msgstr "目标函数和注解函数 MUST拥有同样的输入/输出签名（例如参数个数和类型）；否则产生的行为是未定义的。"

#: ../../../src/evox/core/module.py:621 ../../../src/evox/core/module.py:638
msgid ""
"If the annotated function are to be `vmap`, it cannot contain any in-place "
"operations to `self` since such operations are not well-defined and cannot "
"be compiled."
msgstr "如果注解的函数是 `vmap`，则它不能包含对 `self` 的任何原地操作，因为这样的操作是不明确的，并且不能被编译。"

#: ../../../src/evox/core/module.py:624 ../../../src/evox/core/module.py:641
#, fuzzy
msgid "See `use_state`."
msgstr "状态。"

#: ../../source/apidocs/evox/evox.core.module.md:618
msgid "'__vmap_wrapped__'"
msgstr "__vmap_wrapped__"

#: ../../source/apidocs/evox/evox.core.module.md:645
msgid "'base'"
msgstr "基类"

#: ../../../src/evox/core/module.py:657
msgid "The original class whose member methods are to be lazy JIT."
msgstr "原始类，其成员方法将被延迟 JIT。"

#: ../../../src/evox/core/module.py:658
#, fuzzy
msgid "Whether to trace the module or to script the module. Default to False."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../../src/evox/core/module.py:660
msgid "Returns:     The wrapped class."
msgstr "返回：     被封装的类。"

#: ../../../src/evox/core/module.py:664
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with `jit_class`, the workflow(s) will do the trick for you."
msgstr "在许多情况下，您不需要使用 `jit_class` 来包装您的自定义算法或问题，工作流将为您完成此任务。"

#: ../../../src/evox/core/module.py:665
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional"
msgstr ""
"设置 `trace=True` 时，所有成员函数都会被有效地修改，以额外返回 `self`，因为副作用无法被追踪。如果您想保留副作用，请将 "
"`trace=False`，并使用 `use_state` 函数来包装成员方法以生成纯函数。"

#: ../../../src/evox/core/module.py:666
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220012
msgid ""
"Similarly, all module-wide operations like `self.to(...)` can only returns "
"the unwrapped module, which may not be desired. Since most of them are in-"
"place operations, a simple `module.to(...)` can be used instead of `module ="
" module.to(...)`."
msgstr ""
"类似地，所有模块级的操作如 `self.to(...)` 只能返回未包装的模块，这可能不是我们想要的。由于它们大多是就地操作，可以使用简单的 "
"`module.to(...)` 来替代 `module = module.to(...)`。"

#: ../../source/apidocs/evox/evox.metrics.md:1
msgid "{py:mod}`evox.metrics`"
msgstr "{py:mod}`evox.metrics`"

#: ../../source/apidocs/evox/evox.metrics.md:29
msgid "{py:obj}`__all__ <evox.metrics.__all__>`"
msgstr "{py:obj}`__all__ <evox.metrics.__all__>`"

#: ../../source/apidocs/evox/evox.metrics.md:41
msgid "['gd', 'hv', 'igd']"
msgstr "['gd', 'hv', 'igd']"

#: ../../source/apidocs/evox/evox.metrics.gd.md:1
msgid "{py:mod}`evox.metrics.gd`"
msgstr "{py:mod}`evox.metrics.gd`"

#: ../../source/apidocs/evox/evox.metrics.gd.md:18
msgid "{py:obj}`gd <evox.metrics.gd.gd>`"
msgstr "{py:obj}`gd <evox.metrics.gd.gd>`"

#: ../../../src/evox/metrics/gd.py:20 ../../../src/evox/metrics/gd.py:30
msgid ""
"Calculate the Generational Distance (GD) metric between a set of solutions "
"and the Pareto front."
msgstr "计算一组解与帕累托前沿之间的世代距离（GD）指标。"

#: ../../../src/evox/metrics/gd.py:32 ../../../src/evox/metrics/igd.py:32
msgid ""
"A tensor of shape (n, m), where n is the number of solutions and m is the "
"number of objectives. Represents the set of solutions to be evaluated."
msgstr "一个形状为 (n, m) 的张量，其中 n 是解的数量，m 是目标的数量。表示要评估的解集。"

#: ../../../src/evox/metrics/gd.py:34 ../../../src/evox/metrics/igd.py:34
msgid ""
"A tensor of shape (k, m), where k is the number of points on the Pareto "
"front and m is the number of objectives. Represents the true Pareto front."
msgstr "一个形状为 (k, m) 的张量，其中 k 是帕累托前沿上的点数，m 是目标数量。表示真实的帕累托前沿。"

#: ../../../src/evox/metrics/gd.py:37
msgid ""
"The GD score, a scalar representing the average distance of the solutions to"
" the Pareto front."
msgstr "GD 分数是一种标量，代表着解与帕雷托前沿的平均距离。"

#: ../../../src/evox/metrics/gd.py:40
msgid ""
"The GD score is lower when the approximation is closer to the Pareto front."
msgstr "GD 得分会随着近似值逼近帕累托前沿而降低。"

#: ../../source/apidocs/evox/evox.metrics.hv.md:1
msgid "{py:mod}`evox.metrics.hv`"
msgstr "{py:mod}`evox.metrics.hv`"

#: ../../source/apidocs/evox/evox.metrics.hv.md:18
msgid "{py:obj}`hv <evox.metrics.hv.hv>`"
msgstr "{py:obj}`hv <evox.metrics.hv.hv>`"

#: ../../../src/evox/metrics/hv.py:20 ../../../src/evox/metrics/hv.py:30
msgid "Monte Carlo Hypervolume Calculation using bounding cube method."
msgstr "蒙特卡罗超体积计算使用边界立方体方法。"

#: ../../../src/evox/metrics/hv.py:32
msgid "Objective points of shape (n_points, n_objs)."
msgstr "目标点的形状为 (n_points, n_objs)。"

#: ../../../src/evox/metrics/hv.py:33
msgid "Reference point of shape (n_objs, )."
msgstr "形状为 (n_objs, ) 的参考点。"

#: ../../../src/evox/metrics/hv.py:34
msgid "Number of Monte Carlo samples."
msgstr "蒙特卡罗样本数量。"

#: ../../../src/evox/metrics/hv.py:35
#, fuzzy
msgid "Estimated hypervolume."
msgstr "超体积"

#: ../../source/apidocs/evox/evox.metrics.igd.md:1
msgid "{py:mod}`evox.metrics.igd`"
msgstr "{py:mod}`evox.metrics.igd`"

#: ../../source/apidocs/evox/evox.metrics.igd.md:18
msgid "{py:obj}`igd <evox.metrics.igd.igd>`"
msgstr "{py:obj}`igd <evox.metrics.igd.igd>`"

#: ../../../src/evox/metrics/igd.py:20 ../../../src/evox/metrics/igd.py:30
msgid ""
"Calculate the Inverted Generational Distance (IGD) metric between a set of "
"solutions and the Pareto front."
msgstr "计算一组解决方案与帕累托前沿之间的逆向代际距离 (IGD) 指标。"

#: ../../../src/evox/metrics/igd.py:36
msgid ""
"The power parameter used in the calculation (default is 1). This defines the"
" distance metric (L^p norm)."
msgstr "计算中使用的幂参数（默认为1）。这定义了距离度量（L^p 范数）。"

#: ../../../src/evox/metrics/igd.py:38
msgid ""
"The IGD score, a scalar representing the average distance of the solutions "
"to the Pareto front."
msgstr "IGD得分是一个标量，表示解到帕累托前沿的平均距离。"

#: ../../../src/evox/metrics/igd.py:41
msgid ""
"The IGD score is lower when the approximation is closer to the Pareto front."
msgstr "当近似值接近Pareto前沿时，IGD得分较低。"

#: ../../source/apidocs/evox/evox.operators.md:1
msgid "{py:mod}`evox.operators`"
msgstr "{py:mod}`evox.operators`"

#: ../../source/apidocs/evox/evox.operators.md:30
msgid "{py:obj}`__all__ <evox.operators.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.__all__>`"

#: ../../source/apidocs/evox/evox.operators.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'non_dominate_rank', "
"'non_dominated_sort_script']"
msgstr ""
"['NonDominatedSort', 'crowding_distance', 'non_dominate_rank', "
"'non_dominated_sort_script']"

#: ../../source/apidocs/evox/evox.operators.crossover.md:1
msgid "{py:mod}`evox.operators.crossover`"
msgstr "{py:mod}`evox.operators.crossover`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:29
msgid "{py:obj}`__all__ <evox.operators.crossover.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.crossover.__all__>`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:41
msgid ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."
msgstr ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:1
msgid "{py:mod}`evox.operators.crossover.differential_evolution`"
msgstr "{py:mod}`evox.operators.crossover.differential_evolution`"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:18
msgid ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"
msgstr ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:20
#: ../../../src/evox/operators/crossover/differential_evolution.py:42
msgid "Computes the difference vectors' sum in differential evolution."
msgstr "计算差分演化中的差异向量总和。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:22
msgid ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"
msgstr ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:24
#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "Performs binary crossover in differential evolution."
msgstr "在差分演化中执行二进制交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:26
msgid ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"
msgstr ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:28
#: ../../../src/evox/operators/crossover/differential_evolution.py:56
msgid "Performs exponential crossover in differential evolution."
msgstr "在差分演化中执行指数交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:30
msgid ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"
msgstr ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:32
#: ../../../src/evox/operators/crossover/differential_evolution.py:63
msgid "Performs arithmetic recombination in differential evolution."
msgstr "在演化算法中进行差分进化的算术重组。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:44
msgid "The number of padding difference vectors."
msgstr "padding差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:45
msgid "The number of difference vectors used in mutation."
msgstr "变异过程中使用的差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:46
msgid "The index of current individual."
msgstr "当前个体的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:47
#, fuzzy
msgid "The population tensor."
msgstr "状态。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "The difference sum and the index of first difference vector."
msgstr "差分总和和第一个差分向量的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:51
#: ../../../src/evox/operators/crossover/differential_evolution.py:58
#: ../../../src/evox/operators/crossover/differential_evolution.py:65
#, fuzzy
msgid "The mutated vector for each individual in the population."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:52
#: ../../../src/evox/operators/crossover/differential_evolution.py:59
#: ../../../src/evox/operators/crossover/differential_evolution.py:66
msgid "The current vector for each individual in the population."
msgstr "每个个体在种群中的当前向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:53
#: ../../../src/evox/operators/crossover/differential_evolution.py:60
#, fuzzy
msgid "The crossover probability for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:55
#: ../../../src/evox/operators/crossover/differential_evolution.py:62
msgid "The trial vector after crossover for each individual."
msgstr "每个个体交叉后的试验向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:67
msgid "The coefficient for each individual."
msgstr "每个个体的系数。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:69
msgid "The trial vector after recombination for each individual."
msgstr "每个个体重组后的试验向量。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:1
msgid "{py:mod}`evox.operators.crossover.sbx`"
msgstr "{py:mod}`evox.operators.crossover.sbx`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:18
msgid ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"
msgstr ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"

#: ../../../src/evox/operators/crossover/sbx.py:20
#: ../../../src/evox/operators/crossover/sbx.py:30
msgid "Simulated binary crossover (SBX)"
msgstr "模拟二进制交叉 (SBX)"

#: ../../../src/evox/operators/crossover/sbx.py:32
#: ../../../src/evox/operators/crossover/sbx_half.py:32
msgid "Parent solutions in a 2D tensor (size: n x d)."
msgstr "在二维张量中的父解 (大小: n x d)。"

#: ../../../src/evox/operators/crossover/sbx.py:33
#: ../../../src/evox/operators/crossover/sbx_half.py:33
#, fuzzy
msgid "Probability of doing crossover."
msgstr "交叉概率"

#: ../../../src/evox/operators/crossover/sbx.py:34
#: ../../../src/evox/operators/crossover/sbx_half.py:34
msgid "Distribution index of SBX."
msgstr "SBX的分配指数。"

#: ../../../src/evox/operators/crossover/sbx.py:36
#: ../../../src/evox/operators/crossover/sbx_half.py:36
msgid "Offspring solutions after crossover."
msgstr "交叉后的后代解。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:1
msgid "{py:mod}`evox.operators.crossover.sbx_half`"
msgstr "{py:mod}`evox.operators.crossover.sbx_half`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:18
msgid ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"
msgstr ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"

#: ../../../src/evox/operators/crossover/sbx_half.py:20
#: ../../../src/evox/operators/crossover/sbx_half.py:30
msgid ""
"Generate half of the offspring solutions after simulated binary crossover "
"(SBX)."
msgstr "在进行模拟二进制交叉（SBX）后生成一半的后代解。"

#: ../../source/apidocs/evox/evox.operators.mutation.md:1
msgid "{py:mod}`evox.operators.mutation`"
msgstr "{py:mod}`evox.operators.mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:27
msgid "{py:obj}`__all__ <evox.operators.mutation.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.mutation.__all__>`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:39
msgid "['polynomial_mutation']"
msgstr "['polynomial_mutation']"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:1
msgid "{py:mod}`evox.operators.mutation.pm_mutation`"
msgstr "{py:mod}`evox.operators.mutation.pm_mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:18
msgid ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"
msgstr ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"

#: ../../../src/evox/operators/mutation/pm_mutation.py:20
#: ../../../src/evox/operators/mutation/pm_mutation.py:30
msgid "Polynomial mutation. Inspired by PlatEMO."
msgstr "多项式变异。灵感来自 PlatEMO。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:33
#, fuzzy
msgid "The input population (size: n x d)."
msgstr "种群。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:36
#, fuzzy
msgid "Probability of mutation."
msgstr "交叉概率"

#: ../../../src/evox/operators/mutation/pm_mutation.py:37
msgid "The distribution index for polynomial mutation."
msgstr "多项式变异的分布指数。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:39
msgid "The mutated population. (size: n x d)"
msgstr "变异种群。(大小: n x d)"

#: ../../source/apidocs/evox/evox.operators.sampling.md:1
msgid "{py:mod}`evox.operators.sampling`"
msgstr "{py:mod}`evox.operators.sampling`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:29
msgid "{py:obj}`__all__ <evox.operators.sampling.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.sampling.__all__>`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:41
msgid ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."
msgstr ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:1
msgid "{py:mod}`evox.operators.sampling.gird`"
msgstr "{py:mod}`evox.operators.sampling.gird`"

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:18
msgid "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"
msgstr "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"

#: ../../../src/evox/operators/sampling/gird.py:20
#: ../../../src/evox/operators/sampling/gird.py:30
msgid "Grid sampling. Inspired by PlatEMO."
msgstr "网格采样。受PlatEMO启发。"

#: ../../../src/evox/operators/sampling/gird.py:33
msgid "Number of grid points along each axis."
msgstr "每个轴上的网格点数。"

#: ../../../src/evox/operators/sampling/gird.py:34
msgid "Dimensionality of the grid (number of axes)."
msgstr "网格的维度（轴的数量）。"

#: ../../../src/evox/operators/sampling/gird.py:36
msgid "Grid points, and the number of samples."
msgstr "网格点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:1
msgid "{py:mod}`evox.operators.sampling.latin_hypercube`"
msgstr "{py:mod}`evox.operators.sampling.latin_hypercube`"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:18
msgid ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:20
#: ../../../src/evox/operators/sampling/latin_hypercube.py:34
msgid "Generate Latin Hypercube samples in the unit hypercube."
msgstr "在单位超立方体中生成拉丁超立方体样本。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:22
msgid ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:24
#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"Generate Latin Hypercube samples in the given hypercube defined by `lb` and "
"`ub`."
msgstr ""
"**生成拉丁超立方样本**\n"
"\n"
"生成拉丁超立方样本在给定的超立方体中，该超立方体由 `lb` 和 `ub` 定义。\n"
"\n"
"```python\n"
"self.latins = Algorithms.latin_hypercube_sample(self.lb, self.ub, self.population_size)\n"
"```"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:36
#: ../../../src/evox/operators/sampling/latin_hypercube.py:43
#, fuzzy
msgid "The number of sample points to generate."
msgstr "需要初始化的拷贝的数量"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:37
#: ../../../src/evox/operators/sampling/latin_hypercube.py:44
#, fuzzy
msgid "The dimensionality of the samples."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:38
msgid "The device on which to generate the samples."
msgstr "生成样本的设备。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:39
#: ../../../src/evox/operators/sampling/latin_hypercube.py:47
#, fuzzy
msgid "Whether to scramble the order of the samples. Defaults to True."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，每列代表一个维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:45
msgid ""
"The lower bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as ub."
msgstr "超立方体的下界。必须是与 `ub` 具有相同形状、数据类型和设备的一维张量。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:46
msgid ""
"The upper bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as lb."
msgstr "超立方体的上界。必须是一个一维张量，其形状、数据类型和设备与 lb 相同。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:49
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension whose device is the same as lb and ub."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，各列代表一个维度，其设备与 lb 和 ub 一致。"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:1
msgid "{py:mod}`evox.operators.sampling.uniform`"
msgstr "{py:mod}`evox.operators.sampling.uniform`"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:18
msgid ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"
msgstr ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"

#: ../../../src/evox/operators/sampling/uniform.py:20
#: ../../../src/evox/operators/sampling/uniform.py:30
msgid ""
"Uniform sampling using Das and Dennis's method, Deb and Jain's method. "
"Inspired by PlatEMO's NBI algorithm."
msgstr "使用Das和Dennis的方法进行均匀采样，Deb和Jain的方法。灵感来源于PlatEMO的NBI算法。"

#: ../../../src/evox/operators/sampling/uniform.py:33
#, fuzzy
msgid "Number of points to generate."
msgstr "需要初始化的拷贝的数量"

#: ../../../src/evox/operators/sampling/uniform.py:34
#, fuzzy
msgid "Dimensionality of the grid."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/operators/sampling/uniform.py:36
msgid "The generated points, and the number of samples."
msgstr "生成的点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.selection.md:1
msgid "{py:mod}`evox.operators.selection`"
msgstr "{py:mod}`evox.operators.selection`"

#: ../../source/apidocs/evox/evox.operators.selection.md:30
msgid "{py:obj}`__all__ <evox.operators.selection.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.selection.__all__>`"

#: ../../source/apidocs/evox/evox.operators.selection.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'nd_environmental_selection', "
"'non_dominate_rank', 'non_do..."
msgstr ""
"['NonDominatedSort', 'crowding_distance', 'nd_environmental_selection', "
"'non_dominate_rank', 'non_do..."

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:1
msgid "{py:mod}`evox.operators.selection.find_pbest`"
msgstr "{py:mod}`evox.operators.selection.find_pbest`"

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:18
msgid ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"
msgstr ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"

#: ../../../src/evox/operators/selection/find_pbest.py:20
#: ../../../src/evox/operators/selection/find_pbest.py:30
#, fuzzy
msgid ""
"Selects a random personal-best vector from the population for each "
"individual."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/operators/selection/find_pbest.py:32
msgid ""
"The proportion of the population to consider as best. Must be between 0 and "
"1."
msgstr "种群中考虑为最好的比例。必须在 0 和 1 之间。"

#: ../../../src/evox/operators/selection/find_pbest.py:33
msgid "The population tensor of shape (pop_size, dim)."
msgstr "种群张量，形状为 (pop_size, dim)。"

#: ../../../src/evox/operators/selection/find_pbest.py:34
msgid "The fitness tensor of shape (pop_size,)."
msgstr "适应度张量的形状为 (pop_size,)。"

#: ../../../src/evox/operators/selection/find_pbest.py:36
msgid ""
"A tensor containing the selected personal-best vector for each individual."
msgstr "一个张量，包含每个个体的选择的个人最佳向量。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:1
msgid "{py:mod}`evox.operators.selection.non_dominate`"
msgstr "{py:mod}`evox.operators.selection.non_dominate`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:18
msgid ""
"{py:obj}`NonDominatedSort "
"<evox.operators.selection.non_dominate.NonDominatedSort>`"
msgstr ""
"{py:obj}`NonDominatedSort "
"<evox.operators.selection.non_dominate.NonDominatedSort>`"

#: ../../../src/evox/operators/selection/non_dominate.py:20
#: ../../../src/evox/operators/selection/non_dominate.py:108
msgid ""
"A module for performing non-dominated sorting, implementing caching and "
"support for PyTorch's full map-reduce method."
msgstr "一个用于执行非支配排序的模块，实现了缓存并支持PyTorch的完整映射-归约方法。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:30
msgid ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"
msgstr ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"

#: ../../../src/evox/operators/selection/non_dominate.py:32
#: ../../../src/evox/operators/selection/non_dominate.py:74
msgid ""
"Return the domination relation matrix A, where A_{ij} is True if x_i "
"dominates y_j."
msgstr "返回支配关系矩阵 A，其中 A_{ij} 为 True，如果 x_i 支配 y_j。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:34
msgid ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"
msgstr ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:36
#: ../../../src/evox/operators/selection/non_dominate.py:81
msgid "Update the dominate count and ranks for the current Pareto front."
msgstr "更新当前帕累托前沿的主导计数和等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:38
msgid ""
"{py:obj}`non_dominated_sort_script "
"<evox.operators.selection.non_dominate.non_dominated_sort_script>`"
msgstr ""
"{py:obj}`non_dominated_sort_script "
"<evox.operators.selection.non_dominate.non_dominated_sort_script>`"

#: ../../../src/evox/operators/selection/non_dominate.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:88
msgid "Perform non-dominated sort using PyTorch in torch.script mode."
msgstr "在torch.script模式下使用PyTorch执行非支配排序。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:42
msgid ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"
msgstr ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"

#: ../../../src/evox/operators/selection/non_dominate.py:44
#: ../../../src/evox/operators/selection/non_dominate.py:145
msgid ""
"Compute the crowding distance for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:46
msgid ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"
msgstr ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:48
#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid ""
"Compute the non-domination rank for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的非支配等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:50
msgid ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"
msgstr ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"

#: ../../../src/evox/operators/selection/non_dominate.py:52
#: ../../../src/evox/operators/selection/non_dominate.py:159
msgid ""
"Perform environmental selection based on non-domination rank and crowding "
"distance."
msgstr "基于非支配等级和拥挤距离进行环境选择。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:62
msgid ""
"{py:obj}`_NDS_cache <evox.operators.selection.non_dominate._NDS_cache>`"
msgstr ""
"{py:obj}`_NDS_cache <evox.operators.selection.non_dominate._NDS_cache>`"

#: ../../../src/evox/operators/selection/non_dominate.py:76
msgid ""
"An array with shape (n1, m) where n1 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n1, m) 的数组，其中 n1 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:77
msgid ""
"An array with shape (n2, m) where n2 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n2, m) 的数组，其中 n2 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:79
msgid "The domination relation matrix of x and y."
msgstr "x 和 y 的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:83
msgid "The domination relation matrix between individuals."
msgstr "个体之间的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:84
msgid "The count of how many individuals dominate each individual."
msgstr "每个个体被多少个体所支配的计数。"

#: ../../../src/evox/operators/selection/non_dominate.py:85
msgid "A tensor indicating which individuals are in the current Pareto front."
msgstr "一个张量表示当前帕累托前沿中的个体。"

#: ../../../src/evox/operators/selection/non_dominate.py:86
msgid "A tensor storing the rank of each individual."
msgstr "每个个体的等级的张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:87
msgid "The current Pareto front rank."
msgstr "当前帕累托前沿排名"

#: ../../../src/evox/operators/selection/non_dominate.py:89
msgid ""
"rank: Updated rank tensor.  dominate_count: Updated dominate count tensor."
msgstr ""
"**rank:** 更新的排名张量。\n"
"**dominate_count:** 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:90
msgid "**rank**: Updated rank tensor."
msgstr "**rank**: 更新后的等级张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:91
msgid "**dominate_count**: Updated dominate count tensor."
msgstr "**dominate_count**: 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:90
#: ../../../src/evox/operators/selection/non_dominate.py:131
#: ../../../src/evox/operators/selection/non_dominate.py:139
msgid ""
"An array with shape (n, m) where n is the population size and m is the "
"number of objectives."
msgstr "具有形状 (n, m) 的数组，其中 n 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:92
#: ../../../src/evox/operators/selection/non_dominate.py:133
#: ../../../src/evox/operators/selection/non_dominate.py:141
msgid "A one-dimensional tensor representing the ranking, starting from 0."
msgstr "一个一维张量表示排名，从0开始。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:105
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:30
msgid "Bases: {py:obj}`evox.core.ModuleBase`"
msgstr "Bases: {py:obj}`evox.core.ModuleBase`"

#: ../../../src/evox/operators/selection/non_dominate.py:110
msgid ""
"This class provides an efficient implementation of non-dominated sorting "
"using both direct computation and a traceable map-reduce method for large-"
"scale multi-objective optimization problems."
msgstr "该类提供了一种高效的非支配排序实现，使用直接计算和可追踪的地图-归约方法，适用于大规模多目标优化问题。"

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"This class is designed to automatically identify script and trace modes, "
"with a particular focus on supporting `vmap`. In script mode, use "
"`non_dominated_sort_script`, and in trace mode, use "
"`trace_non_dominated_sort`."
msgstr ""
"该类旨在自动识别脚本和跟踪模式，特别关注支持`vmap`。在脚本模式下，使用`non_dominated_sort_script`，在跟踪模式下，使用`trace_non_dominated_sort"

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"Initialize the NonDominatedSort module, setting up caching for efficient "
"reuse."
msgstr "初始化 NonDominatedSort 模块，为高效重用设置缓存。"

#: ../../../src/evox/operators/selection/non_dominate.py:129
msgid ""
"Perform non-dominated sorting using PyTorch's scripting mechanism for "
"efficient computation."
msgstr "使用 PyTorch 的脚本机制执行非支配排序以提高计算效率。"

#: ../../../src/evox/operators/selection/non_dominate.py:137
msgid ""
"Perform non-dominated sorting using PyTorch's tracing mechanism for "
"efficient computation."
msgstr "使用PyTorch的追踪机制进行非支配排序，以提高计算效率。"

#: ../../../src/evox/operators/selection/non_dominate.py:147
msgid ""
"The crowding distance is a measure of the diversity of solutions within a "
"Pareto front."
msgstr ""
"**Pareto 前景中解的多样性度量：**\n"
"\n"
"**Crowding Distance**\n"
"\n"
"Crowding距离是Pareto前景中解的多样性度量。 \n"
"\n"
"**References**\n"
"\n"
"[1] \n"
"[2]"

#: ../../../src/evox/operators/selection/non_dominate.py:149
#: ../../../src/evox/operators/selection/non_dominate.py:156
#: ../../../src/evox/operators/selection/non_dominate.py:162
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" an objective."
msgstr "一个二维张量，其中每一行代表一个解，每一列代表一个目标。"

#: ../../../src/evox/operators/selection/non_dominate.py:150
msgid "A 1D boolean tensor indicating which solutions should be considered."
msgstr "一个 1D 布尔张量，指示哪些解决方案应该被考虑。"

#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid "A 1D tensor containing the crowding distance for each solution."
msgstr "一个 1D 张量，包含每个解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:154
msgid ""
"The non-domination rank is a measure of the Pareto optimality of each "
"solution."
msgstr "每个解的帕累托最优度被称为非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:158
msgid "A 1D tensor containing the non-domination rank for each solution."
msgstr "一个 1D 张量，包含每个解的非支配排名。"

#: ../../../src/evox/operators/selection/non_dominate.py:161
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" a decision variable."
msgstr "一个二维张量，其中每行代表一个解决方案，每列代表一个决策变量。"

#: ../../../src/evox/operators/selection/non_dominate.py:163
#, fuzzy
msgid "The number of solutions to select."
msgstr "子种群的个数。"

#: ../../../src/evox/operators/selection/non_dominate.py:165
msgid ""
"A tuple of four tensors:x: The selected solutions.  f: The corresponding "
"objective values.  rank: The non-domination rank of the selected solutions."
"  crowding_dis: The crowding distance of the selected solutions."
msgstr ""
"一个由四个张量组成的元组：x：选择的解。 f：对应的目标值。 rank：选择的解的非支配等级。 crowding_dis：选择的解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:166
msgid "A tuple of four tensors:"
msgstr "一个包含四个张量的元组："

#: ../../../src/evox/operators/selection/non_dominate.py:167
#, fuzzy
msgid "**x**: The selected solutions."
msgstr "获取当前的最优解。"

#: ../../../src/evox/operators/selection/non_dominate.py:168
msgid "**f**: The corresponding objective values."
msgstr "**f**: 对应的目标值。"

#: ../../../src/evox/operators/selection/non_dominate.py:169
msgid "**rank**: The non-domination rank of the selected solutions."
msgstr "**rank**: 演化算法中的非支配等级，即选定的解决方案的非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:170
msgid "**crowding_dis**: The crowding distance of the selected solutions."
msgstr "**crowding_dis**: 所选解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:1
msgid "{py:mod}`evox.operators.selection.rvea_selection`"
msgstr "{py:mod}`evox.operators.selection.rvea_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:18
msgid "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"
msgstr "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:20
#: ../../../src/evox/operators/selection/rvea_selection.py:34
msgid "Compute the APD (Angle-Penalized Distance) based on the given inputs."
msgstr "根据给定的输入计算APD（角惩罚距离）。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:22
msgid ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"
msgstr ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:24
#: ../../../src/evox/operators/selection/rvea_selection.py:41
msgid ""
"Perform the Reference Vector Guided Evolutionary Algorithm (RVEA) selection "
"process."
msgstr "执行参考向量指导演化算法 (RVEA) 选择过程。"

#: ../../../src/evox/operators/selection/rvea_selection.py:36
msgid "A tensor representing the indices of the partition."
msgstr "表示分区索引的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:37
msgid "A tensor representing the gamma."
msgstr "一个表示伽马的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:38
#, fuzzy
msgid "A tensor representing the angle."
msgstr "一个表示状态的类"

#: ../../../src/evox/operators/selection/rvea_selection.py:39
msgid "A tensor of shape (n, m) representing the objectives of the solutions."
msgstr "一个形状为 (n, m) 的张量，表示解的目标。"

#: ../../../src/evox/operators/selection/rvea_selection.py:40
msgid ""
"A tensor representing the parameter theta used for scaling the reference "
"vector."
msgstr "一个张量表示用于缩放参考向量的参数 theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:42
msgid "A tensor containing the APD values for each solution."
msgstr "一个包含每个解的 APD 值的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:43
msgid ""
"This function selects solutions based on the Reference Vector Guided "
"Evolutionary Algorithm. It calculates the distances and angles between "
"solutions and reference vectors, and returns the next set of solutions to be"
" evolved."
msgstr "此函数基于参考向量引导的演化算法选择解决方案。它计算解决方案与参考向量之间的距离和角度，并返回下一组待演化的解决方案。"

#: ../../../src/evox/operators/selection/rvea_selection.py:47
msgid ""
"A tensor of shape (n, d) representing the current population solutions."
msgstr "一个形状为 (n, d) 的张量，表示当前种群的解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:48
#: ../../../src/evox/problems/numerical/dtlz.py:68
msgid ""
"A tensor of shape (n, m) representing the objective values for each "
"solution."
msgstr "表示每个解的目标值的张量，以形状 (n, m) 表示。"

#: ../../../src/evox/operators/selection/rvea_selection.py:49
msgid "A tensor of shape (r, m) representing the reference vectors."
msgstr "一个形状为 (r, m) 的张量，表示参考向量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:50
msgid "A tensor representing the parameter theta used in the APD calculation."
msgstr "一个张量，表示在APD计算中使用的参数theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid ""
"A tuple containing:next_x: The next selected solutions.  next_f: The "
"objective values of the next selected solutions."
msgstr "一个元组包含：next_x：下一个选定的解决方案。 next_f：下一个选定的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid "A tuple containing:"
msgstr "一个元组包含："

#: ../../../src/evox/operators/selection/rvea_selection.py:53
#, fuzzy
msgid "next_x: The next selected solutions."
msgstr "获取当前的最优解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:54
msgid "next_f: The objective values of the next selected solutions."
msgstr "next_f: 下一个选择的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:57
msgid ""
"The function computes the distances between the solutions and reference "
"vectors, and selects the solutions with the minimum APD. It currently uses a"
" suboptimal selection implementation, and future improvements will optimize "
"the process using a `segment_sort` or `segment_argmin` in CUDA."
msgstr ""
"该函数计算解与参考向量之间的距离，并选择具有最小APD的解。它当前使用的是次优选择实现，未来的改进将使用CUDA中的`segment_sort`或`segment_argmin`来优化该过程。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:1
msgid "{py:mod}`evox.operators.selection.tournament_selection`"
msgstr "{py:mod}`evox.operators.selection.tournament_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:18
msgid ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"
msgstr ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:20
#: ../../../src/evox/operators/selection/tournament_selection.py:34
msgid "Perform tournament selection based on multiple fitness values."
msgstr "基于多个适应度值执行锦标赛选择。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:22
msgid ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"
msgstr ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:24
#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid "Perform tournament selection based on single fitness values."
msgstr "根据单一适应度值执行锦标赛选择。"

#: ../../../src/evox/operators/selection/tournament_selection.py:36
#: ../../../src/evox/operators/selection/tournament_selection.py:43
msgid "Number of rounds of selection (how many solutions to select)."
msgstr "选择轮数（选择多少个解）。"

#: ../../../src/evox/operators/selection/tournament_selection.py:37
msgid ""
"A list of 1D tensors, each representing the fitness values of candidates for"
" different objectives."
msgstr "一个1D张量的列表，每个张量表示不同目标的候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:38
#: ../../../src/evox/operators/selection/tournament_selection.py:45
msgid "Number of candidates in each tournament. Defaults to 2."
msgstr "每个锦标赛中的候选人数量。 默认值为 2。"

#: ../../../src/evox/operators/selection/tournament_selection.py:39
#: ../../../src/evox/operators/selection/tournament_selection.py:46
msgid "Indices of the selected solutions after tournament selection."
msgstr "所选解决方案在锦标赛选择后的索引。"

#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values across multiple objectives."
msgstr "此函数通过随机选择每轮的一组候选者进行锦标赛选择，并根据他们在多个目标上的适应度值从每组中选择最佳者。"

#: ../../../src/evox/operators/selection/tournament_selection.py:44
msgid "A 1D tensor representing the fitness values of candidates."
msgstr "一个一维张量，表示候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:48
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values."
msgstr "此函数通过随机选择每轮的候选者组来执行锦标赛选择，并根据他们的适应度值从每组中选择最佳者。"

#: ../../source/apidocs/evox/evox.problems.md:1
msgid "{py:mod}`evox.problems`"
msgstr "{py:mod}`evox.problems`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:1
msgid "{py:mod}`evox.problems.hpo_wrapper`"
msgstr "{py:mod}`evox.problems.hpo_wrapper`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:18
msgid "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"
msgstr "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:20
#: ../../../src/evox/problems/hpo_wrapper.py:41
msgid ""
"The base class for hyper parameter optimization (HPO) monitors used in "
"`HPOProblem.workflow.monitor`."
msgstr "用于`HPOProblem.workflow.monitor`中的超参数优化（HPO）监控的基类。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:22
msgid ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"
msgstr ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:24
#: ../../../src/evox/problems/hpo_wrapper.py:66
msgid ""
"The monitor for hyper parameter optimization (HPO) that records the best "
"fitness found so far in the optimization process."
msgstr "用于超参数优化（HPO）的监视器，记录在优化过程中迄今为止发现的最佳适应度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:26
msgid ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"
msgstr ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"

#: ../../../src/evox/problems/hpo_wrapper.py:28
#: ../../../src/evox/problems/hpo_wrapper.py:98
msgid "The problem for hyper parameter optimization (HPO)."
msgstr "超参数优化（HPO）问题。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:38
msgid "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"

#: ../../../src/evox/problems/hpo_wrapper.py:55
#: ../../../src/evox/problems/hpo_wrapper.py:87
msgid ""
"Get the best fitness found so far in the optimization process that this "
"monitor is monitoring."
msgstr "在此监控器监控的优化过程中，获取迄今为止找到的最佳适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:57
#: ../../../src/evox/problems/hpo_wrapper.py:89
#, fuzzy
msgid "The best fitness so far."
msgstr "获取当前的最优适应度值。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:63
msgid "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"
msgstr "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"

#: ../../../src/evox/problems/hpo_wrapper.py:72
msgid "Initialize the HPO fitness monitor."
msgstr "初始化 HPO 适应度监控器。"

#: ../../../src/evox/problems/hpo_wrapper.py:74
msgid ""
"The metric function to use for multi-objective optimization, unused in "
"single-objective optimization. Currently we only support \"IGD\" or \"HV\" "
"for multi-objective optimization. Defaults to None."
msgstr "用于多目标优化的度量函数，在单目标优化中不使用。目前，我们仅支持多目标优化的“IGD”或“HV”。默认为None。"

#: ../../../src/evox/problems/hpo_wrapper.py:79
msgid ""
"Update the best fitness value found so far based on the provided fitness "
"tensor and multi-objective metric."
msgstr "根据提供的适应度张量和多目标度量更新迄今为止找到的最佳适应度值。"

#: ../../../src/evox/problems/hpo_wrapper.py:81
msgid ""
"A tensor representing fitness values. It can be either a 1D tensor for "
"single-objective optimization or a 2D tensor for multi-objective "
"optimization."
msgstr "表示适应度值的张量。对于单目标优化，它可以是一个一维张量；对于多目标优化，它可以是一个二维张量。"

#: ../../../src/evox/problems/hpo_wrapper.py:83
#, fuzzy
msgid "If the dimensionality of the fitness tensor is not 1 or 2."
msgstr "这个问题的完整的维度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:97
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:67
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:86
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:48
msgid "Bases: {py:obj}`evox.core.Problem`"
msgstr "Bases: {py:obj}`evox.core.Problem`"

#: ../../../src/evox/problems/hpo_wrapper.py:104
#, fuzzy
msgid "Initialize the HPO problem wrapper."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/hpo_wrapper.py:106
msgid "The number of iterations to be executed in the optimization process."
msgstr "在优化过程中要执行的迭代次数。"

#: ../../../src/evox/problems/hpo_wrapper.py:107
msgid ""
"The number of instances to be executed in parallel in the optimization "
"process."
msgstr "在优化过程中并行执行的实例数量。"

#: ../../../src/evox/problems/hpo_wrapper.py:108
msgid ""
"The workflow to be used in the optimization process. Must be wrapped by "
"core.jit_class."
msgstr "在优化过程中使用的工作流。必须由 core.jit_class 包装。"

#: ../../../src/evox/problems/hpo_wrapper.py:109
msgid ""
"Whether to copy the initial state of the workflow for each evaluation. "
"Defaults to True. If your workflow contains operations that IN-PLACE modify "
"the tensor(s) in initial state, this should be set to True. Otherwise, you "
"can set it to False to save memory."
msgstr ""
"是否为每次评估复制工作流的初始状态。默认为 True。如果您的工作流包含对初始状态中的张量进行原地修改的操作，则应将其设置为 "
"True。否则，您可以将其设置为 False 以节省内存。"

#: ../../../src/evox/problems/hpo_wrapper.py:111
msgid ""
"Evaluate the fitness (given by the internal workflow's monitor) of the batch"
" of hyper parameters by running the internal workflow."
msgstr "评估一批超参数的适应度（由内部工作流的监控器提供），通过运行内部工作流。"

#: ../../../src/evox/problems/hpo_wrapper.py:113
msgid "The hyper parameters to evaluate."
msgstr "需要评估的超参数。"

#: ../../../src/evox/problems/hpo_wrapper.py:115
msgid "The final fitness of the hyper parameters."
msgstr "最终的超参数适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:119
msgid ""
"Return the initial hyper-parameters dictionary of the underlying workflow."
msgstr "返回底层工作流的初始超参数字典。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:1
msgid "{py:mod}`evox.problems.neuroevolution`"
msgstr "{py:mod}`evox.problems.neuroevolution`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:1
msgid "{py:mod}`evox.problems.neuroevolution.brax`"
msgstr "{py:mod}`evox.problems.neuroevolution.brax`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:18
msgid "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"
msgstr "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"

#: ../../../src/evox/problems/neuroevolution/brax.py:20
#: ../../../src/evox/problems/neuroevolution/brax.py:100
#, fuzzy
msgid "The Brax problem wrapper."
msgstr "问题。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:30
msgid ""
"{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"
msgstr ""
"{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:34
msgid ""
"{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"
msgstr ""
"{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:46
msgid "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"
msgstr "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:50
msgid ""
"{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"
msgstr ""
"{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:62
#, fuzzy
msgid "['BraxProblem']"
msgstr "['BraxProblem']"

#: ../../../src/evox/problems/neuroevolution/brax.py:106
#, fuzzy
msgid ""
"Construct a Brax-based problem. Firstly, you need to define a policy model. "
"Then you need to set the `environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`, the maximum episode "
"length, the number of episodes to evaluate for each individual. For each "
"individual, it will run the policy with the environment for num_episodes "
"times with different seed, and use the reduce_fn to reduce the rewards "
"(default to average). Different individuals will share the same set of "
"random keys in each iteration."
msgstr ""
"构建一个基于Brax的问题。首先，需要定义一个可编译的策略函数（policy function）。策略函数应该具有以下签名： "
"如果您的策略是无状态的：:code:`fn(weights, obs) -> action`， 如果您的策略是有状态的：:code:`fn(state,"
" weights, obs) -> action, state`。接下来，您需要设置`环境名称 "
"<https://github.com/google/brax/tree/main/brax/envs>`_，最大幕长度，以及每个个体需要评估的幕的个数。对于每个个体，策略会在环境中运行`num_episodes`次，并使用不同的随机种子。然后使用`reduce_fn`来聚合奖励（默认为平均值）。在每次迭代中，不同的个体将共享相同的随机种子集合。"

#: ../../../src/evox/problems/neuroevolution/brax.py:115
msgid ""
"The policy model whose forward function is :code:forward(batched_obs) -> "
"action."
msgstr "该策略模型的前向函数是: `forward(batched_obs) -> action"

#: ../../../src/evox/problems/neuroevolution/brax.py:116
msgid "The environment name."
msgstr "环境名。"

#: ../../../src/evox/problems/neuroevolution/brax.py:117
#, fuzzy
msgid "The maximum number of time steps of each episode."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:118
msgid "The number of episodes to evaluate for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:119
msgid ""
"The size of the population to be evaluated. If None, we expect the input to "
"have a population size of 1."
msgstr "要评估的种群大小。如果为 None，我们期望输入的种群大小为 1。"

#: ../../../src/evox/problems/neuroevolution/brax.py:120
#, fuzzy
msgid ""
"Indicates whether to rotate the random key for each iteration (default is "
"True). <br/> If True, the random key will rotate after each iteration, "
"resulting in non-deterministic and potentially noisy fitness evaluations. "
"This means that identical policy weights may yield different fitness values "
"across iterations. <br/> If False, the random key remains the same for all "
"iterations, ensuring consistent fitness evaluations."
msgstr ""
"是否在每次迭代后轮换随机数种子（默认值为 True）。   如果设置为 "
"True，则在每次迭代后随机数种子会轮换，从而导致非适应度评估带有噪声的。这意味着相同的权重在不同迭代中可能返回不同的适应度值。   如果设置为 "
"False，则随机数种子在所有迭代中保持不变，从而确保适应度评估的一致性。"

#: ../../../src/evox/problems/neuroevolution/brax.py:121
#, fuzzy
msgid ""
"The function to reduce the rewards of multiple episodes. Default to "
"torch.mean."
msgstr "用于聚合多个幕奖励值的函数。默认值为 `jnp.mean`。"

#: ../../../src/evox/problems/neuroevolution/brax.py:122
msgid ""
"Brax's backend. If None, the default backend of the environment will be "
"used. Default to None."
msgstr "Brax 的后端。如果为 None，将使用环境的默认后端。默认为 None。"

#: ../../../src/evox/problems/neuroevolution/brax.py:123
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:82
msgid ""
"The device to run the computations on. Defaults to the current default "
"device."
msgstr "用于运行计算的设备。默认为当前默认设备。"

#: ../../../src/evox/problems/neuroevolution/brax.py:125
#: ../../../src/evox/workflows/std_workflow.py:75
#, fuzzy
msgid "Notice"
msgstr "Notes"

#: ../../../src/evox/problems/neuroevolution/brax.py:126
msgid "The initial key is obtained from `torch.random.get_rng_state()`."
msgstr "初始密钥是从 `torch.random.get_rng_state()` 获得的。"

#: ../../../src/evox/problems/neuroevolution/brax.py:129
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:87
msgid ""
"This problem does NOT support HPO wrapper "
"(`problems.hpo_wrapper.HPOProblemWrapper`), i.e., the workflow containing "
"this problem CANNOT be vmapped."
msgstr ""
"此问题不支持 HPO 包装器 (`problems.hpo_wrapper.HPOProblemWrapper`)，即包含此问题的工作流不能被 "
"vmapped。"

#: ../../../src/evox/problems/neuroevolution/brax.py:131
#: ../../source/guide/developer/1-modulebase.md:126 ../../source/index.md:22
msgid "Examples"
msgstr "示例"

#: ../../../src/evox/problems/neuroevolution/brax.py:132
msgid ""
"from evox import problems problem = problems.neuroevolution.Brax( ...    "
"env_name=\"swimmer\", ...    policy=model, ...    max_episode_length=1000, "
"...    num_episodes=3, ...    pop_size=100, ...    rotate_key=False, ...)"
msgstr ""
"from evox import problems\n"
"problem = problems.neuroevolution.Brax(\n"
"    ...    env_name=\"swimmer\",\n"
"    ...    policy=model,\n"
"    ...    max_episode_length=1000,\n"
"    ...    num_episodes=3,\n"
"    ...    pop_size=100,\n"
"    ...    rotate_key=False,\n"
"...)"

#: ../../../src/evox/problems/neuroevolution/brax.py:113
msgid ""
"Evaluate the final rewards of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批量）的最终奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:115
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:125
msgid ""
"A dictionary of parameters where each key is a parameter name and each value"
" is a tensor of shape (batch_size, *param_shape) representing the batched "
"parameters of batched models."
msgstr "参数字典，其中每个键是参数名称，每个值是形状为 (batch_size, *param_shape) 的张量，表示批量模型的批量参数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:117
msgid ""
"A tensor of shape (batch_size,) containing the reward of each sample in the "
"population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:137
#, fuzzy
msgid "Visualize the brax environment with the given policy and weights."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/problems/neuroevolution/brax.py:139
msgid "The weights of the policy model. Which is a dictionary of parameters."
msgstr "策略模型的权重。这是一个参数字典。"

#: ../../../src/evox/problems/neuroevolution/brax.py:140
msgid ""
"The output type of the visualization, \"HTML\" or \"rgb_array\". Default to "
"\"HTML\"."
msgstr "可视化的输出类型，“HTML”或“rgb_array”。默认为“HTML”。"

#: ../../../src/evox/problems/neuroevolution/brax.py:142
#, fuzzy
msgid "The visualization output."
msgstr "种群。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:1
msgid "{py:mod}`evox.problems.neuroevolution.supervised_learning`"
msgstr "{py:mod}`evox.problems.neuroevolution.supervised_learning`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:18
msgid ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"
msgstr ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:20
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:70
msgid ""
"The supervised learning problem to test a model's parameters or a batch of "
"parameters with given data and criterion."
msgstr "监督学习问题是使用给定的数据和标准来测试模型参数或一批参数。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:30
msgid ""
"{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"
msgstr ""
"{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:34
msgid ""
"{py:obj}`__supervised_data__ "
"<evox.problems.neuroevolution.supervised_learning.__supervised_data__>`"
msgstr ""
"{py:obj}`__supervised_data__ "
"<evox.problems.neuroevolution.supervised_learning.__supervised_data__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:46
#, fuzzy
msgid "['SupervisedLearningProblem']"
msgstr "['SupervisedLearningProblem']"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:76
#, fuzzy
msgid "Initialize the `SupervisedLearningProblem`."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:78
msgid "The neural network model whose parameters need to be evaluated."
msgstr "需要评估参数的神经网络模型。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:79
msgid "The data loader providing the dataset for evaluation."
msgstr "用于评估的数据加载器提供数据集。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:80
msgid "The loss function used to evaluate the parameters' performance."
msgstr "用于评估参数性能的损失函数。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:81
msgid ""
"The size of the population (batch size of the parameters) to be evaluated. "
"Defaults to None for single-run mode."
msgstr "种群的大小（参数的批量大小）需要进行评估。默认为 None，表示单次运行模式。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:84
msgid "If the data loader contains no items."
msgstr "如果数据加载器不包含任何项目。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:123
msgid "Evaluate the fitness of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批次）的适应度。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:127
msgid ""
"A tensor of shape (batch_size,) containing the fitness of each sample in the"
" population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的适应度。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:1
msgid "{py:mod}`evox.problems.neuroevolution.utils`"
msgstr "{py:mod}`evox.problems.neuroevolution.utils`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:18
msgid ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"
msgstr ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:30
msgid ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"
msgstr ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"

#: ../../../src/evox/problems/neuroevolution/utils.py:32
#: ../../../src/evox/problems/neuroevolution/utils.py:107
msgid ""
"Get model state forward function for vmap and non-vmap models. When "
"`get_non_vmap` is False, the function returns only vmap model state forward "
"function. When `get_non_vmap` is True, the function returns both vmap and "
"non-vmap model state forward functions."
msgstr ""
"获取用于 vmap 和非 vmap 模型的模型状态前向函数。当 `get_non_vmap` 为 False 时，该函数仅返回 vmap "
"模型状态前向函数。当 `get_non_vmap` 为 True 时，该函数返回 vmap 和非 vmap 模型状态前向函数。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:42
msgid "Bases: {py:obj}`typing.NamedTuple`"
msgstr "Bases: {py:obj}`typing.NamedTuple`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:1
msgid "{py:mod}`evox.problems.numerical`"
msgstr "{py:mod}`evox.problems.numerical`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:29
msgid "{py:obj}`__all__ <evox.problems.numerical.__all__>`"
msgstr "{py:obj}`__all__ <evox.problems.numerical.__all__>`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:41
msgid ""
"['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
"'CEC2022', 'DTLZ1', 'DTLZ2',..."
msgstr ""
"['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
"'CEC2022', 'DTLZ1', 'DTLZ2',..."

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:1
msgid "{py:mod}`evox.problems.numerical.basic`"
msgstr "{py:mod}`evox.problems.numerical.basic`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:18
msgid ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"
msgstr ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"

#: ../../../src/evox/problems/numerical/basic.py:20
#: ../../../src/evox/problems/numerical/basic.py:89
msgid ""
"A numerical problem with a shift and affine transformations to the input "
"points."
msgstr "一个数值问题，包含对输入点的平移和仿射变换。"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:22
msgid "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"
msgstr "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"

#: ../../../src/evox/problems/numerical/basic.py:24
#: ../../../src/evox/problems/numerical/basic.py:120
#, fuzzy
msgid "The Ackley function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:26
msgid "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"
msgstr "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"

#: ../../../src/evox/problems/numerical/basic.py:28
#: ../../../src/evox/problems/numerical/basic.py:151
#, fuzzy
msgid "The Griewank function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:30
msgid "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"
msgstr "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"

#: ../../../src/evox/problems/numerical/basic.py:32
#: ../../../src/evox/problems/numerical/basic.py:182
#, fuzzy
msgid "The Rastrigin function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:34
msgid "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"
msgstr "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"

#: ../../../src/evox/problems/numerical/basic.py:36
#: ../../../src/evox/problems/numerical/basic.py:213
#, fuzzy
msgid "The Rosenbrock function whose minimum is x = [1, ..., 1]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:38
msgid "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"
msgstr "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"

#: ../../../src/evox/problems/numerical/basic.py:40
#: ../../../src/evox/problems/numerical/basic.py:244
#, fuzzy
msgid "The Schwefel function whose minimum is x = [420.9687, ..., 420.9687]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:42
msgid "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"
msgstr "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"

#: ../../../src/evox/problems/numerical/basic.py:44
#: ../../../src/evox/problems/numerical/basic.py:275
#, fuzzy
msgid "The sphere function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:54
msgid "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"
msgstr "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:58
msgid "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"
msgstr "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:62
msgid ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"
msgstr ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:66
msgid ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"
msgstr ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:70
msgid "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"
msgstr "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:74
msgid "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"
msgstr "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"

#: ../../../src/evox/problems/numerical/basic.py:95
#, fuzzy
msgid "Initialize the ShiftAffineNumericalProblem."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/numerical/basic.py:97
msgid "The shift vector. Defaults to None. None represents no shift."
msgstr "偏移向量。默认为 None。None 表示没有偏移。"

#: ../../../src/evox/problems/numerical/basic.py:98
msgid ""
"The affine transformation matrix. Defaults to None. None represents no "
"affine transformation."
msgstr "仿射变换矩阵。默认为 None。None 表示没有仿射变换。"

#: ../../../src/evox/problems/numerical/basic.py:102
msgid ""
"Evaluate the given population by shifting and applying an affine "
"transformation to the input points first, and then evaluating the points "
"with the actual function."
msgstr "首先对给定的种群进行平移和仿射变换，然后用实际函数评估这些点。"

#: ../../../src/evox/problems/numerical/basic.py:104
#, fuzzy
msgid "The population of points to evaluate."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/problems/numerical/basic.py:106
#, fuzzy
msgid "The evaluated fitness of the population."
msgstr "评估给定候选解的适应度。"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:117
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:148
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:179
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:210
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:241
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:272
msgid ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"
msgstr ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"

#: ../../../src/evox/problems/numerical/basic.py:126
#, fuzzy
msgid "Initialize the Ackley function with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/problems/numerical/basic.py:128
msgid "The parameter a in the equation. Defaults to 20.0."
msgstr "方程中的参数a。默认值为20.0。"

#: ../../../src/evox/problems/numerical/basic.py:129
msgid "The parameter b in the equation. Defaults to 0.2."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:130
msgid "The parameter c in the equation. Defaults to 2 * pi."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:131
#: ../../../src/evox/problems/numerical/basic.py:159
#: ../../../src/evox/problems/numerical/basic.py:190
#: ../../../src/evox/problems/numerical/basic.py:221
#: ../../../src/evox/problems/numerical/basic.py:252
#: ../../../src/evox/problems/numerical/basic.py:283
msgid ""
"The keyword arguments (shift and affine) to pass to the superclass "
"ShiftAffineNumericalProblem."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:157
#: ../../../src/evox/problems/numerical/basic.py:188
#: ../../../src/evox/problems/numerical/basic.py:219
#: ../../../src/evox/problems/numerical/basic.py:250
#: ../../../src/evox/problems/numerical/basic.py:281
#, fuzzy
msgid "Initialize the Griewank function with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:1
msgid "{py:mod}`evox.problems.numerical.cec2022`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:18
msgid "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:20
#: ../../../src/evox/problems/numerical/cec2022.py:33
msgid "The CEC 2022 single-objective test suite Problem"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:39
msgid ""
"Initialize a single test function instance from the CEC2022 test suite."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:41
msgid ""
"Args:     problem_number (`int`): The index for the specific test function "
"to be used. Must be ranged from 1 to 12.     dimension (`int`): The "
"dimensionality of the problem. Must be one of [2, 10, 20].     device "
"(`torch.device`, optional): The device on which tensors will be allocated. "
"Defaults to None."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid ""
"Raises:     AssertionError: If the dimension is not one of the allowed "
"values or if the function is not defined.     FileNotFoundError: If the "
"necessary data files for the problem are not found."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid "Shift the input vector."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:54
msgid "Rotate the input vector."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:70
msgid "Shift and rotate function with rate."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:86
msgid "Zakharov Function"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:94
#, fuzzy
msgid "Rosenbrock Function"
msgstr "Rosenbrock"

#: ../../../src/evox/problems/numerical/cec2022.py:102
msgid "Schaffer F7 Function"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:110
msgid "Step Rastrigin Function (Noncontinuous Rastrigin's)"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:118
#, fuzzy
msgid "Levy Function"
msgstr "测试函数"

#: ../../../src/evox/problems/numerical/cec2022.py:126
msgid "Hybrid Function 2"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:134
msgid "Hybrid Function 10"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:142
msgid "Hybrid Function 6"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:150
msgid "Composition Function 1"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:158
msgid "Composition Function 2"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:166
msgid "Composition Function 6"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:174
msgid "Composition Function 7"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:182
msgid "Problem number = 1."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:190
msgid "Problem number = 4."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:198
msgid "Problem number = 5."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:1
msgid "{py:mod}`evox.problems.numerical.dtlz`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:18
msgid "{py:obj}`DTLZTestSuit <evox.problems.numerical.dtlz.DTLZTestSuit>`"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:20
#: ../../../src/evox/problems/numerical/dtlz.py:51
msgid ""
"Base class for DTLZ test suite problems in multi-objective optimization."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:22
msgid "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:24
msgid "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:26
msgid "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:30
msgid "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:34
msgid "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:36
msgid "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:38
msgid "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:53
msgid "Inherit this class to implement specific DTLZ problem variants."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:55
msgid "Number of decision variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:56
#, fuzzy
msgid "Number of objectives."
msgstr "目标数量"

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Number of reference points used in the problem."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Override the setup method to initialize the parameters"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:65
msgid ""
"Abstract method to evaluate the objective values for given decision "
"variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:67
msgid ""
"A tensor of shape (n, d), where n is the number of solutions and d is the "
"number of decision variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:73
#, fuzzy
msgid "Return the Pareto front for the problem."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/numerical/dtlz.py:75
msgid "A tensor representing the Pareto front."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:81
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:93
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:158
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:175
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:192
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZTestSuit`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:110
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:134
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:1
msgid "{py:mod}`evox.utils`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:29
msgid "{py:obj}`__all__ <evox.utils.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:41
msgid ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."
msgstr ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."

#: ../../source/apidocs/evox/evox.utils.control_flow.md:1
msgid "{py:mod}`evox.utils.control_flow`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.control_flow.md:18
msgid "{py:obj}`__all__ <evox.utils.control_flow.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.control_flow.md:30
msgid "['TracingCond', 'TracingWhile', 'TracingSwitch']"
msgstr "['TracingCond', 'TracingWhile', 'TracingSwitch']"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:1
msgid "{py:mod}`evox.utils.jit_fix_operator`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:18
msgid "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:20
#: ../../../src/evox/utils/jit_fix_operator.py:82
msgid ""
"Element-wise switch select operator that generates a tensor from a list of "
"tensors based on the label tensor."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:22
msgid "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:24
#: ../../../src/evox/utils/jit_fix_operator.py:89
msgid ""
"Clamp the values of the input tensor `a` to be within the given lower (`lb`)"
" and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:26
msgid "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:28
#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"Clamp the float values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:30
msgid "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:32
#: ../../../src/evox/utils/jit_fix_operator.py:103
msgid ""
"Clamp the int values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:34
msgid "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:36
#: ../../../src/evox/utils/jit_fix_operator.py:110
msgid "Clip the values of the input tensor `a` to be within the range [0, 1]."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:38
msgid "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:40
#: ../../../src/evox/utils/jit_fix_operator.py:117
msgid "Element-wise maximum of two input tensors `a` and `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:42
msgid "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:44
#: ../../../src/evox/utils/jit_fix_operator.py:124
msgid "Element-wise minimum of two input tensors `a` and `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:46
msgid "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:48
#: ../../../src/evox/utils/jit_fix_operator.py:131
msgid "Element-wise maximum of input tensor `a` and float `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:50
msgid "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:52
#: ../../../src/evox/utils/jit_fix_operator.py:138
msgid "Element-wise minimum of input tensor `a` and float `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:54
msgid "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:145
msgid "Element-wise maximum of input tensor `a` and int `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:58
msgid "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:60
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "Element-wise minimum of input tensor `a` and int `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:62
msgid "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:64
#: ../../../src/evox/utils/jit_fix_operator.py:159
msgid ""
"Perform lexicographical sorting of multiple tensors, considering each tensor"
" as a key."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:66
msgid "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:68
#: ../../../src/evox/utils/jit_fix_operator.py:166
msgid ""
"Compute the minimum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:70
msgid "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:72
#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"Compute the maximum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:84
msgid ""
"A tensor containing labels used to select from the list of tensors. Must be "
"broadcastable to the shape of rest arguments."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:85
msgid ""
"A list of tensors from which one is selected based on the label. All tensors"
" in the list must be broadcastable to the same shape."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:88
msgid ""
"A tensor where each element is selected from the list of tensors based on "
"the corresponding element in the label tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:91
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"the corresponding element of `lb` and not greater than the corresponding "
"element of `ub`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:95
#: ../../../src/evox/utils/jit_fix_operator.py:101
#: ../../../src/evox/utils/jit_fix_operator.py:108
msgid ""
"This is a fix function for "
"[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html) "
"since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a`, `lb` or `ub` is a"
" float tensor and may suffer from numerical precision losses. Please use "
"`torch.clamp` instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:104
#: ../../../src/evox/utils/jit_fix_operator.py:111
msgid "The input tensor to be clamped."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:99
msgid "The lower bound tensor. Must be broadcastable to the shape of a."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:100
msgid "The upper bound tensor. Must be broadcastable to the shape of a."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:102
#: ../../../src/evox/utils/jit_fix_operator.py:108
#: ../../../src/evox/utils/jit_fix_operator.py:115
msgid ""
"A tensor where each element is clamped to be within the specified bounds."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:105
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"`lb` and not greater than `ub`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:102
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a float tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:105
#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid ""
"The lower bound value. Each element of a will be clamped to be not less than"
" lb."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:106
#: ../../../src/evox/utils/jit_fix_operator.py:113
msgid ""
"The upper bound value. Each element of a will be clamped to be not greater "
"than ub."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:109
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a int tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid "Notice: This function invokes `clamp(a, 0, 1)`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:114
msgid "The input tensor to be clipped."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:116
msgid "A tensor where each element is clipped to be within [0, 1]."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:119
#: ../../../src/evox/utils/jit_fix_operator.py:133
#: ../../../src/evox/utils/jit_fix_operator.py:147
msgid ""
"Notice: This is a fix function for "
"[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:121
#: ../../../src/evox/utils/jit_fix_operator.py:128
#: ../../../src/evox/utils/jit_fix_operator.py:135
#: ../../../src/evox/utils/jit_fix_operator.py:143
#: ../../../src/evox/utils/jit_fix_operator.py:149
#: ../../../src/evox/utils/jit_fix_operator.py:157
msgid "The first input tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:122
#: ../../../src/evox/utils/jit_fix_operator.py:129
msgid "The second input tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:124
#: ../../../src/evox/utils/jit_fix_operator.py:138
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "The element-wise maximum of a and b."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:126
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:131
#: ../../../src/evox/utils/jit_fix_operator.py:146
#: ../../../src/evox/utils/jit_fix_operator.py:160
msgid "The element-wise minimum of a and b."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:136
#: ../../../src/evox/utils/jit_fix_operator.py:144
msgid "The second input float, which is a scalar value."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:140
#: ../../../src/evox/utils/jit_fix_operator.py:154
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:150
#: ../../../src/evox/utils/jit_fix_operator.py:158
msgid "The second input int, which is a scalar value."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:161
msgid ""
"This function sorts the given tensors lexicographically, where sorting is "
"performed by the first key, then by the second key in case of ties in the "
"first key, and so on. It works similarly to NumPy's `lexsort`, but is "
"designed for PyTorch tensors."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:165
msgid ""
"A list of tensors to be sorted, where each tensor represents a sorting key. "
"All tensors must have the same length along the specified dimension (dim)."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"The dimension along which to perform the sorting. Defaults to -1 (the last "
"dimension)."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:170
msgid ""
"A tensor containing indices that will sort the input tensors "
"lexicographically. These indices indicate the order of elements in the "
"sorted tensors."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid "You can use `torch.unbind` to split the tensor into list."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"This function replaces `NaN` values in the input tensor with `infinity` , "
"and then computes the minimum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:171
#: ../../../src/evox/utils/jit_fix_operator.py:178
msgid ""
"The input tensor, which may contain NaN values. It can be of any shape."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"The dimension along which to compute the minimum. Default is -1, which "
"corresponds to the last dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:175
#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"Whether to retain the reduced dimension in the result. Default is False. If "
"True, the output tensor will have the same number of dimensions as the "
"input, with the size of the reduced dimension set to 1."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:179
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" minimum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the minimum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:179
#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid "A named tuple with two fields:"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"`values` (`torch.Tensor`): A tensor containing the minimum values computed "
"along the specified dimension,   ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the minimum "
"values along the specified dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:184
#: ../../../src/evox/utils/jit_fix_operator.py:191
msgid ""
"The returned tensors `values` and `indices` will have the same shape as the "
"input tensor, except for the dimension(s) over which the operation was "
"performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:195
msgid ""
"`NaN` values are ignored by replacing them with `infinity` before computing "
"the minimum."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:196
msgid ""
"If all values along a dimension are `NaN`, the result will be `infinity` for"
" that dimension, and the index will be returned as the first valid index."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:175
msgid ""
"This function replaces `NaN` values in the input tensor with `-infinity`, "
"and then computes the maximum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"The dimension along which to compute the maximum. Default is -1, which "
"corresponds to the last dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" maximum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the maximum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:187
msgid ""
"`values` (`torch.Tensor`): A tensor containing the maximum values computed "
"along the specified dimension,     ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:189
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the maximum "
"values along the specified dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:202
msgid ""
"`NaN` values are ignored by replacing them with `-infinity` before computing"
" the maximum."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:203
msgid ""
"If all values along a dimension are `NaN`, the result will be `-infinity` "
"for that dimension, and the index will be returned as the first valid index."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:1
msgid "{py:mod}`evox.utils.parameters_and_vector`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:18
msgid ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:20
#: ../../../src/evox/utils/parameters_and_vector.py:33
msgid ""
"The class to convert (batched) parameters dictionary to vector(s) and vice "
"versa."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:39
#, fuzzy
msgid "Initialize the ParamsAndVector instance."
msgstr "为问题初始化设置。"

#: ../../../src/evox/utils/parameters_and_vector.py:41
msgid ""
"A PyTorch model whose parameters will be used to initialize the parameter "
"and vector conversion attributes. Must be an initialized PyTorch model."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:46
msgid "Convert the input parameters dictionary to a single vector."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:48
msgid "The input parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:50
msgid "The output vector obtained by concatenating the flattened parameters."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:54
#, fuzzy
msgid "Convert a batched parameters dictionary to a batch of vectors."
msgstr "`batched_to_vector`可以将一批树状结构转换为一批向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:56
msgid ""
"The input dictionary values must be batched parameters, i.e., they must have"
" the same shape at the first dimension."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:58
msgid "The input batched parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:60
msgid ""
"The output vectors obtained by concatenating the flattened batched "
"parameters. The first dimension of the output vector corresponds to the "
"batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:62
#, fuzzy
msgid "Convert a vector back to a parameters dictionary."
msgstr "`to_tree` 可以把向量转化回树的形式。"

#: ../../../src/evox/utils/parameters_and_vector.py:64
msgid "The input vector representing flattened model parameters."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:66
msgid "The reconstructed parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:70
msgid "Convert a batch of vectors back to a batched parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:72
msgid ""
"The input batch of vectors representing flattened model parameters. The "
"first dimension of the tensor corresponds to the batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:74
msgid ""
"The reconstructed batched parameters dictionary whose tensors' first "
"dimensions correspond to the batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:78
msgid ""
"The forward function for the `ParamsAndVector` module is an alias of "
"`batched_to_params` to cope with `StdWorkflow`."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.md:1
msgid "{py:mod}`evox.vis_tools`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:1
msgid "{py:mod}`evox.vis_tools.exv`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:7
msgid "This module helps serialize data to EvoXVision storage format (exv)."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:13
msgid ""
"The numbers are stored in little-endian format. The metadata is a JSON utf-8"
" encoded string, which contains the schema of the binary data. The format of"
" the metadata is as follows:"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:49
msgid ""
"where <type> represents the data type of the field, available types are:"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:50
msgid "\"u8\", \"u16\", \"u32\", \"u64\","
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:51
msgid "\"i16\", \"i32\", \"i64\","
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:52
msgid "\"f16\", \"f32\", \"f64\" The size and offset are in bytes."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:56
msgid ""
"The magic number is used to identify the file format. 0x65787631 is the byte"
" code for \"exv1\". The binary data blob is a sequence of binary data "
"chunks. In EvoX, the algorithm is allowed to have a different behavior in "
"the first iteration (initialization phase), which can have a different chunk"
" size than the rest of the iterations. Therefore it contains two different "
"schemas for the initial iteration and the rest of the iterations."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:18
msgid "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:20 ../../../src/evox/vis_tools/exv.py:61
msgid ""
"EvoXVisionAdapter is a class that streams evolutionary optimization data to "
"an exv file. The exv file format is a binary format that created "
"specifically for the evolutionary optimization data. The format is designed "
"to be efficient for both stream reading and writing data, while being able "
"to randomly access data at any iteration."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:30
msgid "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:34
msgid "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:36 ../../../src/evox/vis_tools/exv.py:53
msgid ""
"Takes the input of the populaton and fitness from the first two iterations, "
"and returns the schema for exv file format."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:67
msgid ""
"Create a new EvoXVisionAdapter instance, which writes data to an exv file. "
"To automatically inference the data schema, the EvoXVisionAdapter requires 2"
" iterations of data, therefore it will only start to write data after the 2 "
"iterations of the optimization loop are completed."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:71
#, fuzzy
msgid "The path to the exv file"
msgstr "到状态保存位置的路径"

#: ../../../src/evox/vis_tools/exv.py:72
msgid ""
"The buffer size to use for file operations, passed directly to the open() "
"function. The default is 0, which disables buffering (unbuffered mode)."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:98
msgid "Write the header of the exv file."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:106
msgid ""
"Stream data to the exv file. Depending on the `buffering` parameter, the "
"data may not be written immediately."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:114
msgid "Flush the internal buffer to the file."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:1
msgid "{py:mod}`evox.vis_tools.plot`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:18
msgid "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:20
#: ../../../src/evox/vis_tools/plot.py:50
msgid ""
"A Built-in plot function for visualizing the population of single-objective "
"algorithm. Use plotly internally, so you need to install plotly to use this "
"function."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:22
msgid "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:24
#: ../../../src/evox/vis_tools/plot.py:57
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:26
msgid ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:28
#: ../../../src/evox/vis_tools/plot.py:64
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. No animation."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:30
msgid ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:32
#: ../../../src/evox/vis_tools/plot.py:71
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. With animation."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:34
msgid "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:36
#: ../../../src/evox/vis_tools/plot.py:78
msgid ""
"Visualize the fitness values of the population in a multi-objective (2 "
"objectives) optimization problem."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:38
msgid "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:40
#: ../../../src/evox/vis_tools/plot.py:85
msgid ""
"Visualize the fitness values of the population in a multi-objective (3 "
"objectives) optimization problem."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:53
msgid ""
"If the problem is provided, we will plot the fitness landscape of the "
"problem."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:55
msgid ""
"A list of arrays, each array represents the population of one generation."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:56
#: ../../../src/evox/vis_tools/plot.py:61
#: ../../../src/evox/vis_tools/plot.py:83
#: ../../../src/evox/vis_tools/plot.py:90
msgid "Additional arguments to be passed to the plotly layout."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:58
#: ../../../src/evox/vis_tools/plot.py:63
#: ../../../src/evox/vis_tools/plot.py:85
#: ../../../src/evox/vis_tools/plot.py:92
msgid "A plotly figure."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:59
#: ../../../src/evox/vis_tools/plot.py:80
#: ../../../src/evox/vis_tools/plot.py:87
msgid ""
"A list of arrays, each array represents the fitness values of the population"
" of one generation."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:60
msgid "Whether to show the animation of the fitness values over generations."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:81
#: ../../../src/evox/vis_tools/plot.py:89
#, fuzzy
msgid "The Pareto front of the problem. Optional."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/vis_tools/plot.py:82
#: ../../../src/evox/vis_tools/plot.py:88
msgid ""
"Whether to sort the points in the plot. This will only affect the animation "
"behavior."
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:1
msgid "{py:mod}`evox.workflows`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:28
msgid "{py:obj}`__all__ <evox.workflows.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:40
msgid "['EvalMonitor', 'StdWorkflow']"
msgstr "['EvalMonitor', 'StdWorkflow']"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:1
msgid "{py:mod}`evox.workflows.eval_monitor`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:18
msgid "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:20
#: ../../../src/evox/workflows/eval_monitor.py:33
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the offspring, "
"their corresponding fitness and keep track of the evaluation count. "
"Moreover, it can also record the best solution or the pareto front on-the-"
"fly."
msgstr ""
"评估监控器被用于单目标和多目标工作流。它与评估流程挂钩，可以监控子代及其相应的适应度并对评估计数进行跟踪。此外，它还能即时记录最优解或帕累托前沿。"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:30
msgid "Bases: {py:obj}`evox.core.Monitor`"
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:39
#, fuzzy
msgid "Initialize the monitor."
msgstr "初始化"

#: ../../../src/evox/workflows/eval_monitor.py:41
#, fuzzy
msgid "Whether the optimization is multi-objective. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/workflows/eval_monitor.py:42
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:43
#, fuzzy
msgid ""
"Whether to record the full history of solutions. Default to False. Setting "
"it to True may increase memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:44
msgid ""
"Only affect Single-objective optimization. The number of elite solutions to "
"record. Default to 1, which will record the best individual."
msgstr "只影响单目标优化。要记录的精英解决方案的数量。默认为 1，将记录最佳个人。"

#: ../../../src/evox/workflows/eval_monitor.py:45
#, fuzzy
msgid "The device of the monitor. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/workflows/eval_monitor.py:61
#, fuzzy
msgid "Get the fitness values from the latest iteration."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/workflows/eval_monitor.py:69
msgid "Get the solution from the latest iteration."
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:77
#, fuzzy
msgid "Get the topk fitness values so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:85
#, fuzzy
msgid "Get the topk solutions so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:93
#, fuzzy
msgid "Get the best solution so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:101
#, fuzzy
msgid "Get the best fitness value so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:109
msgid "Get the full history of fitness values."
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:117
msgid "Get the full history of solutions."
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:1
msgid "{py:mod}`evox.workflows.std_workflow`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:18
msgid "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:20
msgid "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:22
#: ../../../src/evox/workflows/std_workflow.py:50
#, fuzzy
msgid "The standard workflow."
msgstr "标准工作流"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:47
msgid "Bases: {py:obj}`evox.core.Workflow`"
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:56
msgid "Initialize the standard workflow with static arguments."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:58
msgid ""
"The optimization direction, can only be \"min\" or \"max\". Defaults to "
"\"min\". If \"max\", the fitness will be negated prior to fitness_transform "
"and monitor."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:63
msgid ""
"Setup the module with submodule initialization. Since all of these arguments"
" are mutable modules to be added as submodules, they are placed here instead"
" of `__init__` and thus `setup` MUST be invoked after `__init__`."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:65
#, fuzzy
msgid "The algorithm to be used in the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../../src/evox/workflows/std_workflow.py:66
#, fuzzy
msgid "The problem to be used in the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../../src/evox/workflows/std_workflow.py:67
msgid ""
"The monitors to be used in the workflow. Defaults to None. Notice: usually, "
"monitors can only be used when using JIT script mode."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:68
msgid ""
"The solution transformation function. MUST be JIT-compatible module/function"
" for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:69
msgid ""
"The fitness transformation function. MUST be JIT-compatible module/function "
"for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:70
msgid "The device of the workflow. Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:71
msgid ""
"The arguments to be passed to algorithm.setup(**kwargs). If not provided, "
"the algorithm.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:72
msgid ""
"The arguments to be passed to problem.setup(**kwargs). If not provided, the "
"problem.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:73
msgid ""
"The arguments to be passed to monitor.setup(**kwargs). If not provided, the "
"monitor.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:76
msgid ""
"The algorithm, problem and monitor will be IN-PLACE transformed to the "
"target device."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:113
msgid ""
"Perform a single optimization step using the algorithm and the problem."
msgstr ""

#: ../../source/apidocs/index.rst:2 ../../source/index.md:15
msgid "API Reference"
msgstr "API文档"

#: ../../source/apidocs/index.rst:4
msgid "This page contains auto-generated API reference documentation [#f1]_."
msgstr ""

#: ../../source/apidocs/index.rst:11
msgid ""
"Created with `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-"
"autodoc2>`_"
msgstr ""

#: ../../source/example/brax.ipynb:10002
#, fuzzy
msgid "Solving Brax Problem in EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/example/brax.ipynb:10004
msgid ""
"EvoX deeply dives into neuroevolution with Brax. Here we will show an "
"example of solving Brax problem in EvoX."
msgstr ""

#: ../../source/example/brax.ipynb:40002
#: ../../source/guide/user/2-problems.ipynb:50002
msgid "What is Brax"
msgstr ""

#: ../../source/example/brax.ipynb:40004
#: ../../source/guide/user/2-problems.ipynb:50004
msgid ""
"Brax is a fast and fully differentiable physics engine used for research and"
" development of robotics, human perception, materials science, reinforcement"
" learning, and other simulation-heavy applications."
msgstr ""

#: ../../source/example/brax.ipynb:40006
#, fuzzy
msgid "Here we will demonstrate a \"hopper\" environment of Brax."
msgstr "我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/example/brax.ipynb:40008
msgid ""
"For more information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr ""

#: ../../source/example/brax.ipynb:50002
#: ../../source/guide/user/2-problems.ipynb:60002
msgid "Design a neural network class"
msgstr ""

#: ../../source/example/brax.ipynb:50004
#: ../../source/guide/user/2-problems.ipynb:60004
msgid ""
"To start with, we need to decide which neural network we are about to "
"construct."
msgstr ""

#: ../../source/example/brax.ipynb:50006
#: ../../source/guide/user/2-problems.ipynb:60006
msgid "Here we will give a simple Multilayer Perceptron (MLP) class."
msgstr ""

#: ../../source/example/brax.ipynb:70002
#: ../../source/guide/user/2-problems.ipynb:80002
msgid "Initiate a model"
msgstr ""

#: ../../source/example/brax.ipynb:70004
msgid "Through the ``SimpleMLP`` class, we can initiate a MLP model."
msgstr ""

#: ../../source/example/brax.ipynb:90002
#: ../../source/guide/user/2-problems.ipynb:160004
msgid "Initiate an adapter"
msgstr ""

#: ../../source/example/brax.ipynb:90004
#: ../../source/guide/user/2-problems.ipynb:160006
#, fuzzy
msgid "An adapter can help us convert the data back-and-forth."
msgstr "现在`adapter`可以帮助我们来回转换数据格式。"

#: ../../source/example/brax.ipynb:110002
#: ../../source/guide/user/2-problems.ipynb:180002
msgid "With an adapter, we can set out to do this Neuroevolution Task."
msgstr ""

#: ../../source/example/brax.ipynb:110004
#: ../../source/guide/user/2-problems.ipynb:180008
msgid "Set up the running process"
msgstr ""

#: ../../source/example/brax.ipynb:110006
#: ../../source/guide/user/1-start.ipynb:40011
#: ../../source/guide/user/2-problems.ipynb:180010
#, fuzzy
msgid "Initiate an algorithm and a problem"
msgstr "创建一个算法和一个问题"

#: ../../source/example/brax.ipynb:110008
msgid ""
"We initiate a [PSO algorithm](#evox.algorithms.pso_variants.pso.PSO), and "
"the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"hopper\" "
"environment."
msgstr ""

#: ../../source/example/brax.ipynb:130002
#: ../../source/guide/user/2-problems.ipynb:200008
#, fuzzy
msgid ""
"In this case, we will be using 1000 steps for each episode, and the average "
"reward of 3 episodes will be returned as the fitness value."
msgstr ""
"现在创建基于 Brax 的问题，其中 `max_episode_length` 是每个回合的最大步数，`num_episodes` "
"是每次评估要运行的回合数。在此情况下，我们将每个回合设置为 1000 步，3 个回合的平均奖励将作为适应度值返回。"

#: ../../source/example/brax.ipynb:130004
#: ../../source/guide/user/1-start.ipynb:60004
#: ../../source/guide/user/2-problems.ipynb:200010
#, fuzzy
msgid "Set an monitor"
msgstr "评估监控器"

#: ../../source/example/brax.ipynb:150002
#: ../../source/guide/user/1-start.ipynb:80002
#: ../../source/guide/user/2-problems.ipynb:220002
#, fuzzy
msgid "Initiate an workflow"
msgstr "分布式工作流程"

#: ../../source/example/brax.ipynb:170002
#: ../../source/guide/user/1-start.ipynb:100002
#: ../../source/guide/user/2-problems.ipynb:240002
#, fuzzy
msgid "Run the workflow"
msgstr "分布式工作流程"

#: ../../source/example/brax.ipynb:170004
#: ../../source/guide/user/2-problems.ipynb:240004
msgid "Run the workflow and see the magic!"
msgstr "运行工作流并见证魔法！"

#: ../../source/example/brax.ipynb:170007
#, fuzzy
msgid ""
"The following block will take around 20 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#: ../../source/example/brax.ipynb:220003
msgid ""
"Normally, you only need `HTML(problem.visualize(best_params))` to render. "
"The code above is a workaround to ensure the result is displayed correctly "
"on our website."
msgstr ""

#: ../../source/example/brax.ipynb:220004
msgid ""
"The PSO algorithm is not specifically optimized for this type of task, so "
"performance limitations are expected. This example is for demonstration "
"purposes."
msgstr ""

#: ../../source/example/brax.ipynb:220007
msgid "We hope you enjoy solving Brax problems with EvoX and have fun!"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:10002
#, fuzzy
msgid "Custom Algorithm and Problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algo_prob.ipynb:10003
msgid ""
"In this notebook, we will show how to use the "
"[`Algorithm`](#evox.core.components.Algorithm) and "
"[`Problem`](#evox.core.components.Problem) to create a custom algorithm and "
"problem. Here we will give an example of **implementing a PSO algorithm that"
" solves the Sphere problem**."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30002
#: ../../source/guide/developer/3-custom-alg-pro.md:99
msgid "Algorithm example: PSO algorithm"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30004
msgid ""
"Particle Swarm Optimization (PSO) is a population-based metaheuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30006
#: ../../source/guide/developer/3-custom-alg-pro.md:103
msgid "**Here is an implementation example of PSO algorithm in EvoX:**"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50002
#: ../../source/guide/developer/3-custom-alg-pro.md:188
msgid "Problem example: Sphere problem"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50004
#: ../../source/guide/developer/3-custom-alg-pro.md:190
msgid ""
"The Sphere problem is a simple, yet fundamental benchmark optimization "
"problem used to test optimization algorithms."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50006
#: ../../source/guide/developer/3-custom-alg-pro.md:192
msgid "The Sphere function is defined as:"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50008
#: ../../source/guide/developer/3-custom-alg-pro.md:194
msgid ""
"\n"
"\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}\n"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50011
#: ../../source/guide/developer/3-custom-alg-pro.md:197
msgid "**Here is an implementation example of Sphere problem in EvoX:**"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:70002
#, fuzzy
msgid "Use the algorithm to solve the problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algo_prob.ipynb:70004
#, fuzzy
msgid "Initiate the algorithm, problem and monitor"
msgstr "接下来创建algorithm，problem，monitor对象。"

#: ../../source/example/custom_algo_prob.ipynb:90002
#, fuzzy
msgid "Initiate the workflow and run it"
msgstr "现在，重新初始化工作流，并再次执行它。"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/moalg.ipynb:10002
#, fuzzy
msgid "Multi-Objective Algorithm"
msgstr "多目标"

#: ../../source/example/moalg.ipynb:20002
#, fuzzy
msgid ""
"In this notebook, we will use the Reference Vector Guided Evolutionary "
"Algorithm (**RVEA**) to find the optimal solutions of the **DTLZ2** problem."
msgstr "在这个文档里，我们会使用粒子群算法来寻找Ackley测试问题的最小值。"

#: ../../source/example/moalg.ipynb:40002
msgid "(Optional) Use GPU to run the code"
msgstr ""

#: ../../source/example/moalg.ipynb:40003
msgid ""
"We often prefer to run our code on a GPU for faster execution. However, if a"
" GPU is unavailable, running on a CPU is also acceptable."
msgstr ""

#: ../../source/example/moalg.ipynb:60002
msgid "Running example: RVEA on DTLZ2 problem"
msgstr ""

#: ../../source/example/moalg.ipynb:60003
msgid ""
"The following code is used to set up the "
"[`DTLZ2`](#evox.problems.numerical.dtlz) problem and the "
"[`RVEA`](#evox.algorithms.mo.rvea) algorithm. More information about the "
"problem and algorithm can be found in the corresponding section of the "
"documentation."
msgstr ""

#: ../../source/example/moalg.ipynb:80002
msgid ""
"With this setup in place, we can now start to optimize. We set to let the "
"multi-objective algorithm optimize for 100 steps on this problem"
msgstr ""

#: ../../source/example/moalg.ipynb:100002
msgid ""
"(Optional) You can uncomment and execute the following code to print a table"
" to view the hotspot functions."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/so-algorithm.ipynb:20002
msgid ""
"This notebook offers a step-by-step tutorial on utilizing EvoX to optimize "
"the Ackley function through the Particle Swarm Optimization (PSO) algorithm."
" Both the PSO algorithm and the Ackley optimization problem are integrated "
"as built-in components within the EvoX framework."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:20004
msgid ""
"First, we should import all necessary modules including `PSO` (algorithm), "
"`Ackley` (problem) and `StdWorkflow` & `EvalMonitor` (workflow)."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40002
msgid ""
"Here, we instantiate the [`PSO`](#evox.algorithms.pso_variants.pso) "
"algorithm. We specify the following settings:"
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40004
msgid "`pop_size`: The size of the particle swarm (population)."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40005
msgid ""
"`lb` and `ub`: The lower and upper bounds for each dimension in the search "
"space."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40006
msgid "Other parameters are all default. Please refer to the detailed API."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:60002
msgid ""
"Next, we choose the [`Ackley`](#evox.problems.numerical.basic.Ackley) "
"function in EvoX' s numerical problem."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:80002
msgid ""
"We creat an [`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor) "
"instance to track necessary information during the optimization procedure."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:100002
msgid ""
"The [`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) class provides"
" a standardized process to integrate the algorithm, problem, and monitor."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:120002
msgid ""
"Calling `setup()` initializes the components so that the workflow is ready "
"to perform optimization steps."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:140002
msgid ""
"We run the optimization for a certain number of iterations (100 in this "
"example). In each iteration, the `step()` method updates the PSO algorithm, "
"evaluates new candidate solutions on the Ackley function, and tracks their "
"fitness via the monitor."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:160002
msgid ""
"Finally, we retrieve the [`monitor`](#StdWorkflow.get_submodule) submodule "
"from the workflow to access the top solutions found so far "
"(`topk_solutions`) and their corresponding objective values "
"(`topk_fitness`). We then print the best result and the associated solution."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:10002
msgid "Solving Supervised Learning Tasks with Neuroevolution in EvoX"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:20002
msgid ""
"EvoX provides solutions for supervised learning tasks based on "
"neuroevolution, with key modules including "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" and [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)."
" Taking the MNIST classification task as an example, this section "
"illustrates the neuroevolution process for supervised learning by adopting "
"the modules of EvoX."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:30002
msgid "Basic Setup"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:40002
msgid ""
"Basic component imports and device configuration serve as the essential "
"starting steps for the neuroevolution process."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:40004
msgid ""
"Here, to ensure the reproducibility of results, a random seed can be "
"optionally set."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:60002
msgid ""
"In this step, a sample convolutional neural network (CNN) model is directly "
"defined upon the PyTorch framework and then loaded onto the device."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:80002
msgid ""
"Setting dataset implies the selection of the task. The data loader now needs"
" to be initialized based on PyTorch's built-in support. Here, the package "
"`torchvision` must be installed in advance depending on your PyTorch "
"version, if it is not already available."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:80005
msgid ""
"In case the MNIST dataset is not already present in the `data_root` "
"directory, the `download=True` flag is set to ensure that the dataset will "
"be automatically downloaded. Therefore, the setup may take some time during "
"the first run."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:100002
msgid ""
"To accelerate subsequent processes, all MNIST data are pre-loaded for faster"
" execution. Below, three datasets are pre-loaded for different stages "
"&ndash; gradient descent training, neuroevolution fine-tuning, and model "
"testing."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:100004
msgid ""
"It should be noted that this is an optional operation that trades space for "
"time. Its adoption depends on your GPU capacity, and it will always take "
"some time to prepare."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:120002
msgid ""
"Here, a `model_test` function is pre-defined to simplify the evaluation of "
"the model's prediction accuracy on the test dataset during subsequent "
"stages."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:140002
msgid "Gradient Descent Training (Optional)"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:150002
msgid ""
"The gradient descent based model training is performed first. In this "
"example, this training is adopted to initialize the model, preparing it for "
"subsequent neuroevolution processes."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:150004
msgid ""
"The model training process in PyTorch is compatible with neuroevolution in "
"EvoX, making it convenient to reuse the same model implementation for "
"further steps."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:180002
msgid "Neuroevolution Fine-Tuning"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:190002
msgid ""
"Based on the pre-trained model from the previous gradient descent process, "
"neuroevolution is progressively applied to fine-tune the model."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:190004
msgid ""
"First, the "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"component is used to flatten the weights of the pre-trained model into a "
"vector, which serves as the initial center individual for the subsequent "
"neuroevolution process."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:210002
msgid ""
"In case of algorithms specifically designed for neuroevolution, which can "
"directly accept a dictionary of batched parameters as input, the usage of "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) can "
"be unnecessary."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:220002
msgid ""
"Additionally, a sample criterion is defined. Here, both the loss and "
"accuracy of the individual model are selected and weighted to serve as the "
"fitness function in the neuroevolution process. This step is customizable to"
" suit the optimization direction."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:240002
msgid ""
"At the same time, similar to the gradient descent training and model testing"
" processes, the neuroevolution fine-tuning process is also encapsulated into"
" a function for convenient use in subsequent stages."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:260002
msgid "Population-Based Neuroevolution Test"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:270002
msgid ""
"In this example, the population-based algorithm for neuroevolution is tested"
" first, using Particle Swarm Optimization "
"([PSO](#evox.algorithms.pso_variants.PSO)) as a representation. The "
"configuration for neuroevolution is similar to that of other optimization "
"tasks &ndash; we need to define the problem, algorithm, monitor, and "
"workflow, along with their respective `setup()` functions to complete the "
"initialization."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:270004
msgid ""
"A key point to note here is that the population size (`POP_SIZE` in this "
"case) needs to be initialized in **both the problem and the algorithm** to "
"avoid potential errors."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:300002
msgid "Single-Individual Neuroveolution Test"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:310002
msgid ""
"Next, the single-individual algorithm based neuroevolution is tested. "
"Similar to the population-based case, we need to define the problem, "
"algorithm, monitor, and workflow, and call their respective `setup()` "
"functions during initialization. In this case, a random search strategy is "
"selected as the algorithm."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:310004
msgid ""
"A key point to note here is that "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" should be set with `pop_size=None`, and "
"[`EvalMonitor`](#evox.workflows.EvalMonitor) should have `topk=1`, as only a"
" single individual is being searched. A careful hyper-parameter setup helps "
"avoid unnecessary issues."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:1
#, fuzzy
msgid "Working with Module in EvoX"
msgstr "在EvoX中使用State"

#: ../../source/guide/developer/1-modulebase.md:3
msgid ""
"A **module** is a fundamental concept in programming that refers to a self-"
"contained unit of code designed to perform a specific task or a set of "
"related tasks."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:5
msgid ""
"This notebook will introduce the basic module in EvoX: "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:7
msgid "Introduction to Module"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:9
msgid ""
"In the [Quick Start Documentation](#/guide/user/1-start) of the [User "
"Guide](#/guide/user/index), we have mentioned the basic running process in "
"EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:13
msgid "This process requires four basic class in EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:15
msgid "[`Algorithm`](#evox.core.components.Algorithm)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:16
msgid "[`Problem`](#evox.core.components.Problem)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:17
msgid "[`Monitor`](evox.core.components.Monitor)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:18
msgid "[`Workflow`](#evox.core.components.Workflow)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:21
msgid ""
"It is necessary to provide a unified module for them. In EvoX, the four "
"classes are all inherited from the base module — "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "Module base"
msgstr "模块类"

#: ../../source/guide/developer/1-modulebase.md:28
#, fuzzy
msgid "ModuleBase class"
msgstr "模块类"

#: ../../source/guide/developer/1-modulebase.md:30
msgid ""
"The [`ModuleBase`](#evox.core.module.ModuleBase) class is inherited from "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:32
msgid ""
"There are many methods in this class, and some important methods are here:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Method"
msgstr "方法"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Signature"
msgstr "签名"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`__init__`"
msgstr "__init__"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`(self, ...)`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "Initialize the module."
msgstr "初始化这个模块和所有的子模块"

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "`setup`"
msgstr "设置"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`(self, ...) -> self`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Module initialization lines should be written in the overwritten method of "
"`setup` rather than `__init__`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`load_state_dict`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Copy parameters and buffers from `state_dict` into this module and its "
"descendants. It overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`add_mutable`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:41
msgid "Role of Module"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:43
msgid ""
"In EvoX, the [`ModuleBase`](#evox.core.module.ModuleBase) could help to:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:45
msgid "**Contain mutable values**"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:47
msgid ""
"​\tThis module is an object-oriented one that can contain mutable values."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:49
msgid "**Support functional programming**"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:51
msgid ""
"​\tFunctional programming model is supported via `self.state_dict()` and "
"`self.load_state_dict(...)`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:53
msgid "**Standardize the initialization**:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:55
msgid ""
"​\tBasically, predefined submodule(s) which will be ADDED to this module and"
" accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:57
msgid ""
"​\tThe module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:59
#, fuzzy
msgid "Usage of Module"
msgstr "这个模块的状态。"

#: ../../source/guide/developer/1-modulebase.md:61
msgid ""
"Specifically, there are some rules for using "
"[`ModuleBase`](#evox.core.module.ModuleBase) in EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:63
#, fuzzy
msgid "Static methods"
msgstr "方法"

#: ../../source/guide/developer/1-modulebase.md:65
msgid "Static methods to be JIT shall be defined like:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:74
msgid "Non-static Methods"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:76
msgid ""
"If a method with python dynamic control flows like `if` were to be JIT, a "
"separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:102
msgid "Supporting for JIT and non-JIT functions"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:104
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase) is usually used with "
"`jit_class` to automatically JIT all non-magic member methods:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:128
msgid ""
"An example of one module inherited from the "
"[`ModuleBase`](#evox.core.module.ModuleBase) is like:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:150
msgid ""
"For more details, please look through [the Module in "
"EvoX](#evox.core.module)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:10002
msgid "Optimizing Development for EvoX via PyTorch Advanced Techniques"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20002
msgid "Basic Optimization Support for Functions in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20004
msgid ""
"PyTorch provides fundamental optimization support for functions, primarily "
"through vectorizing map (vmap) operations and Just-In-Time (JIT) "
"compilation. These techniques enable efficient batch processing and enhance "
"execution performance, respectively. Introductions of these optimizations "
"are provided in the following sections."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30002
msgid "Batch Processing Support through Vectorizing Map in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30004
msgid ""
"Vectorizing map, implemented in PyTorch as "
"[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html), "
"is a powerful tool that takes a callable function and returns a batched "
"version of it. According to specified strategy, this new function vectorizes"
" the operations of the original one, which facilitates efficient batch "
"processing. In EvoX, for example, this feature plays a crucial role in "
"hyperparameter optimization (HPO)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50002
msgid "Just-In-Time (JIT) Support in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50004
msgid ""
"In PyTorch, "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" and "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" provide two distinct types of JIT tools, supporting function performance "
"optimization through tracing and scripting, respectively."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50006
msgid ""
"Based on the tracing strategy, the `torch.jit.trace` method offers higher "
"parsing speed and broader compatibility, such as with `torch.vmap` "
"operations. Although it provides excellent support for simple functions, it "
"is not suitable for complex tasks involving dynamic if-else branches and "
"loop control flows."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:70002
msgid ""
"In the example below, the traced `vmap` function successfully returns the "
"correct code representation:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:90002
msgid ""
"However, dynamic python control-flow cannot be traced correctly and a "
"warning will be raised:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:110002
msgid ""
"Alternatively, the `torch.jit.script` method, which adopts a scripting "
"strategy, is better suited for complex tasks that involve dynamic control "
"flows but has limited compatibility."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:120002
msgid ""
"In this example, the same `vmap_sample_func` function, after being scripted,"
" returns an **incorrect** code representation:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:140002
msgid "Yet, it can correctly deal with complex dynamic python control flow:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:160003
msgid ""
"`torch.jit.script` relies on type hint to work properly. For example, any "
"unannotated input argument is treated as a `torch.Tensor` while you can "
"annotate some input arguments to be python types to make `torch.jit.script` "
"work as intended."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170002
msgid "Combined Usage of JIT and Vectorizing Map in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170004
msgid ""
"Based on the introductions above, when `torch.jit.trace` and "
"`torch.jit.script` are used in combination with `torch.vmap`, coordination "
"is required due to compatibility considerations."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170006
msgid ""
"The figure below illustrates the relationship between `torch.jit.script`, "
"`torch.jit.trace`, and `torch.vmap`, highlighting their mutual invocation "
"paths. If module A invokes module B, it implies that B can be called by A."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170008
msgid "JIT introduction"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170013
msgid ""
"For detailed usage of JIT and vectorizing map on PyTorch, please refer to "
"the official PyTorch documentation for "
"[TorchScript](#https://pytorch.org/docs/stable/jit.html) and "
"[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180002
msgid "Specific Optimization Support in EvoX"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180004
msgid ""
"Within EvoX, most functions are defined inside classes, particularly "
"subclasses of [`ModuleBase`](#evox.core.module.ModuleBase). To provide more "
"comprehensive optimization supports, EvoX offers specific enhancements."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:190002
msgid ""
"Using JIT to Subclasses of [`ModuleBase`](#evox.core.module.ModuleBase)"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:200002
msgid ""
"For better understanding of this part, we need to explain three important "
"functions in EvoX: [`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](l#evox.core.jit_util.jit)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:210002
msgid "[`jit_class`](#evox.core.module.jit_class) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220002
msgid ""
"[`jit_class`](#evox.core.module.jit_class) is a helper function used to "
"Just-In-Time (JIT) script of "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" or trace "
"([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
"jit-trace-module)) all member methods of the input class."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220004
msgid "[`jit_class`](#evox.core.module.jit_class) has two parameters:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220006
msgid "`cls`: the original class whose member methods are to be lazy JIT."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220007
#, fuzzy
msgid ""
"`trace`: whether to trace the module or to script the module. Default to "
"`False`."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220010
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with [`jit_class`](#evox.core.module.jit_class), the workflow(s) "
"will do the trick for you."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220011
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional "
"(the `use_state` function will be explained in the next part)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:230003
msgid "[`vmap`](#evox.core.jit_util.vmap) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:240002
msgid ""
"[`vmap`](#evox.core.jit_util.vmap) function vectorized map the given "
"function to its mapped version. Based on "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html), we "
"made many improvements, and you can see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:250002
msgid "[`jit`](#evox.core.jit_util.jit) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260002
msgid ""
"[`jit`](#evox.core.jit_util.jit) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260007
msgid ""
"With `trace=True`, `torch.jit.trace` cannot use SAME example input arguments"
" for function of DIFFERENT parameters,e.g., you cannot pass `tensor_a, "
"tensor_a` to `torch.jit.trace`d version of `f(x: torch.Tensor, y: "
"torch.Tensor)`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260008
msgid ""
"With `trace=False`, `torch.jit.script` cannot contain `vmap` expressions "
"directly, please wrap them with `jit(..., trace=True)` or `torch.jit.trace`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260011
msgid ""
"In the [Working with Module in EvoX](#/guide/developer/1-modulebase), we "
"have briefly introduced some rules about the methods inside a subclass of "
"the [`ModuleBase`](#evox.core.module.ModuleBase) . Now that "
"[`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](#evox.core.jit_util.jit) have"
" been explained, we will explain more rules and provide some specific hints."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:270002
msgid "Definition of Static Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:280002
msgid "Inside the subclass, static methods to be JIT shall be defined like:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:290002
msgid "Definition of Non-static Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300002
msgid ""
"If a method with **Python dynamic control flows** like `if` were to be JIT, "
"a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300035
msgid ""
"Dynamic control flow in Python refers to control structures that change "
"dynamically based on conditions at runtime. `if...elif...else` Conditional "
"Statements, `for`loop and `while` loop are all dynamic control flows. If you"
" have to use them when defining non-static Methods inside the subclass of "
"[`ModuleBase`](#evox.core.module.ModuleBase), please follow the above rule."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:310002
msgid "Invocation of External Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:320002
msgid ""
"Inside the subclass, external JIT methods can be invocated by the class "
"methods to be JIT:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:330002
msgid "Automatically JIT for the Subclass Used with `jit_class`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:340002
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase)  and its subclasses are usually"
" used with [`jit_class`](#evox.core.module.jit_class) to automatically JIT "
"all non-magic member methods:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:350002
msgid "Invocation of External Vmap-wrapped Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360002
msgid ""
"Inside the subclass, external vmap-wrapped methods can be invocated by the "
"class methods to be JIT:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360034
msgid ""
"If method A invokes vmap-wrapped method B, then A and all methods invoke "
"method A can not be vmap-wrapped again."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:370002
msgid "Internal Vmap-wrapped Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380002
msgid ""
"Inside the subclass, internal vmap-wrapped methods can be  JIT by using the "
"[`trace_impl`](#evox.core.module.trace_impl):"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380040
msgid ""
"If a class method use [`trace_impl`](#evox.core.module.trace_impl), it will "
"be only available in the trace mode. More details about `trace_impl` will be"
" shown in the next part."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390002
msgid "Using `@trace_impl` and `@vmap_impl`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390004
msgid ""
"When designing a function or method, you may not always consider whether it "
"is `JIT`-compatible. However, this property becomes crucial in specific "
"scenarios, such as solving Hyperparameter Optimization (HPO) problems. For "
"more details on deploying HPO with EvoX, refer to [Efficient HPO with "
"EvoX](#/guide/user/3-hpo)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390006
msgid ""
"A typical characteristic of such problems is that only certain parts of the "
"algorithm need modification—for instance, the `step` method of an algorithm."
" This allows you to avoid rewriting the entire algorithm. In such cases, you"
" can use the `@trace_impl` or `@vmap_impl` decorator to rewrite the function"
" as a trace-JIT-time or vmap-JIT-time proxy for the specified `target` "
"method."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390008
msgid ""
"The decorators [`@trace_impl`](#trace_impl) and [`@vmap_impl`](#vmap_impl) "
"accept a single input parameter: the target method invoked when not "
"tracing/vmapping JIT. These decorators are applicable **only** to member "
"methods within a `jit_class`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390010
msgid ""
"Since the annotated function serves as a rewritten version of the target "
"function, it must maintain identical input/output signatures (e.g., number "
"and types of arguments). Otherwise, the resulting behavior is undefined."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390012
msgid ""
"If the annotated function is intended for use with `vmap`, it must satisfy "
"three additional constraints:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390014
msgid ""
"**No In-Place Operations on Attributes:** The algorithm must not include "
"methods that perform in-place operations on its attributes."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390029
msgid ""
"**Avoid Python Control Flow:** The code logic must not rely on Python "
"control flow structures. To handle Python control flow, use "
"[`TracingCond`](#TracingCond), [`TracingWhile`](#TracingWhile), and "
"[`TracingSwitch`](#TracingSwitch)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390079
msgid ""
"**Avoid In-Place Operations on `self`:** Vectorized map in-place operations "
"on `self` are not well-defined and cannot be compiled. Even if it is "
"compiled successfully, you can still silently get incorrect results."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390082
#, fuzzy
msgid "Using `use_state`"
msgstr "状态。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390084
msgid ""
"[`use_state`](#use_state) transforms a given stateful function (which "
"performs in-place alterations on `nn.Module`s) into a pure-functional "
"version that receives an additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and returns the altered state."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390086
msgid ""
"The input `func` is the stateful function to be transformed or its generator"
" function, and `is_generator` specifies whether `func` is a function or a "
"function generator (e.g., a lambda that returns the stateful function). It "
"defaults to `True`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390088
#, fuzzy
msgid "Here is a simple example:"
msgstr "代码样例"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390129
msgid "Using `core._vmap_fix`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390131
msgid ""
"The module [`_vmap_fix`](#_vmap_fix) provides useful functions. After the "
"automatic import, `_vmap_fix` enables `torch.vmap` to be correctly traced by"
" `torch.jit.trace`, while resolving issues such as random number handling "
"that couldn't be properly traced during the `vmap` process. It also provides"
" the `debug_print` function, which allows dynamic printing of Tensor values "
"during both `vmap` and tracing."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390133
msgid ""
"Detailed information can be found in the [`_vmap_fix`](#_vmap_fix) "
"documentation."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:1
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:3
#, fuzzy
msgid ""
"In this chapter, we will introduce how to implement your own algorithms and "
"problems in EvoX."
msgstr "在本章中，我们将介绍如何在 EvoX 中实现您自己的算法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:5
#, fuzzy
msgid "Layout of the algorithms and problems"
msgstr "自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:7
#, fuzzy
msgid ""
"In most traditional EC libraries, algorithms usually call the objective "
"function internally, which gives the following layout:"
msgstr "在传统的EC库中，算法通常在内部调用目标函数，其布局如下"

#: ../../source/guide/developer/3-custom-alg-pro.md:15
#, fuzzy
msgid "**But in EvoX, we have a flat layout:**"
msgstr "但在 EvoX 中，我们采用了扁平布局"

#: ../../source/guide/developer/3-custom-alg-pro.md:21
msgid ""
"This layout makes both algorithms and problems more universal: an algorithm "
"can optimize different problems, while a problem can also be suitable for "
"many algorithms."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:25
#, fuzzy
msgid "Algorithm class"
msgstr "算法类"

#: ../../source/guide/developer/3-custom-alg-pro.md:27
msgid ""
"The [`Algorithm`](#evox.core.components.Algorithm) class is inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:29
msgid ""
"**In total,** **there are 5 methods (2 methods are optional) that we need to"
" implement:**"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the algorithm instance, for example, the population size (keeps "
"constant during iteration), hyper-parameters (can only be set by HPO problem"
" wrapper or initialized here), and / or mutable tensors (can be modified on "
"the fly)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`setup` (optional)"
msgstr "init_ask (可选的)"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the mutable submodule(s) of the algorithm. See "
"[`ModuleBase`](#evox.core.module.ModuleBase). Usually, it is not necessary "
"to overwrite this method."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`step`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`(self)`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "Perform a normal optimization iteration step of the algorithm."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`init_step` (optional)"
msgstr "init_tell (可选的 )"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Perform the first step of the optimization of the algorithm. If this method "
"were not overwritten, the `step` method would be invoked instead."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:39
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable submodule(s) initialization cannot. Therefore, multiple calls of "
"`setup` for repeated initializations are possible if the overwritten `setup`"
" method invokes the `setup()` of "
"[`ModuleBase`](#evox.core.module.ModuleBase) first."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:41
msgid ""
"If such `setup` method in [`ModuleBase`](#evox.core.module.ModuleBase) is "
"not suitable for your algorithm, you can override the `setup` method when "
"you create your own algorithm class."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:45
#, fuzzy
msgid "Problem class"
msgstr "问题类"

#: ../../source/guide/developer/3-custom-alg-pro.md:47
msgid ""
"The [`Problem`](#evox.core.components.Problem) class is also inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:49
#, fuzzy
msgid ""
"However, the Problem class is quite simple. **Beside the `__init__` method, "
"the only necessary method is the `evaluate` method.**"
msgstr "`Problem` 类相当简单，除了 `__init__` 和 `setup`，唯一必需的方法是 `evaluate`。"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`evaluate`"
msgstr "评估"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`(self, pop: torch.Tensor) -> torch.Tensor`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "Evaluate the fitness of the given population."
msgstr "评估给定候选解的适应度。"

#: ../../source/guide/developer/3-custom-alg-pro.md:56
msgid ""
"However, the type of `pop` argument in `evaluate` can be changed to other "
"JIT-compatible types in the overwritten method."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:59
msgid "Example"
msgstr "样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:61
msgid ""
"Here we give an example of **implementing a PSO algorithm that solves the "
"Sphere problem**."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:63
#, fuzzy
msgid "Pseudo-code of the example"
msgstr "代码样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:65
#, fuzzy
msgid "Here is a pseudo-code:"
msgstr "这是一个遗传算法的伪代码。"

#: ../../source/guide/developer/3-custom-alg-pro.md:81
#, fuzzy
msgid ""
"And here is what each part of the algorithm and the problem corresponds to "
"in EvoX."
msgstr "这里是算法的每个部分在 EvoX 中对应的内容。"

#: ../../source/guide/developer/3-custom-alg-pro.md:101
msgid ""
"Particle Swarm Optimization (PSO) is a population-based meta-heuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:212
#, fuzzy
msgid "Now, you can initiate a workflow and run it."
msgstr "现在你可以组合出一个workflow并运行。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:1
msgid "Transformation from MATLAB to PyTorch and EvoX"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:3
msgid ""
"This document aims to guide MATLAB users in transitioning to PyTorch and "
"EvoX for evolutionary computation. We will highlight the core differences "
"between MATLAB and PyTorch in terms of syntax, data structures, and "
"workflow. We will then illustrate these differences using a Particle Swarm "
"Optimization (PSO) example in both MATLAB and PyTorch."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:5
msgid "Syntax Differences"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:7
msgid "Array Creation and Indexing"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:9
#: ../../source/guide/developer/4-transfer-from-matlab.md:23
#: ../../source/guide/developer/4-transfer-from-matlab.md:43
#: ../../source/guide/developer/4-transfer-from-matlab.md:57
#: ../../source/guide/developer/4-transfer-from-matlab.md:69
#: ../../source/guide/developer/4-transfer-from-matlab.md:81
#: ../../source/guide/developer/4-transfer-from-matlab.md:91
msgid "MATLAB"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:11
msgid "Uses 1-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:12
msgid ""
"Vectors and matrices are declared using square brackets and semicolons "
"(e.g., `[1 2 3; 4 5 6]`). Random initialization with `rand()` returns values"
" in the interval $[0, 1)$."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:13
msgid ""
"Slicing is performed using the `(start:end)` syntax and utilizes 1-based "
"indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:15
#: ../../source/guide/developer/4-transfer-from-matlab.md:32
#: ../../source/guide/developer/4-transfer-from-matlab.md:49
#: ../../source/guide/developer/4-transfer-from-matlab.md:62
#: ../../source/guide/developer/4-transfer-from-matlab.md:74
#, fuzzy
msgid "PyTorch"
msgstr "安装ROCm"

#: ../../source/guide/developer/4-transfer-from-matlab.md:17
msgid "Uses 0-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:18
msgid ""
"Arrays (tensors) are typically created using constructors like "
"`torch.rand()`, `torch.zeros()`, or Python lists converted to tensors with "
"`torch.tensor()`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:19
msgid "Slicing is done using `[start:end]` with 0-based indices."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:21
#, fuzzy
msgid "Matrix Computation"
msgstr "种群。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:25
msgid "Performs linear algebraic matrix multiplication by `*`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:26
msgid ""
"Uses `.*` to multiply corresponding elements of matrices of the same size."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:27
msgid "`/` represents the matrix right division."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:28
msgid "`.^` represents the element-wise power."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:29
msgid ""
"Trailing and leading dimension(s) of tensors with length 1 is/are "
"**ignored**."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:30
msgid ""
"Automatically find broadcastable dimensions for element-wise operations and "
"perform **implicit** dimension extension."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:34
msgid ""
"Performs linear algebraic matrix multiplication by `@` or `torch.matmul()`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:35
msgid ""
"Directly uses `*` to multiply corresponding elements of tensors of the same "
"shape or broadcastable shapes."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:36
msgid "`/` represents the element-wise division."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:37
msgid "`**` represents the element-wise power."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:38
msgid ""
"Dimension(s) of tensors with length 1 is/are **preserved** and treated as "
"**broadcast dimension**."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:39
msgid ""
"**Prevent** most implicit dimension extension, broadcast dimension(s) are "
"usually required."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:41
msgid "Functions and Definitions"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:45
msgid "A function is defined by the `function` keyword."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:46
msgid ""
"A file can contain multiple functions, but typically the primary function "
"shares the file name."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:47
msgid ""
"Anonymous functions (e.g., `@(x) sum(x.^2)`) are used for short inline "
"calculations."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:51
msgid ""
"Functions are defined using the def keyword, typically within a single `.py`"
" file or module."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:52
msgid ""
"Classes are used to encapsulate data and methods in an object-oriented "
"manner."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:53
msgid ""
"Lambdas serve as short anonymous functions (`lambda x: x.sum()`), but multi-"
"line lambdas are not allowed."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:55
msgid "Control Flow"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:59
msgid "Uses for `i = 1:N` ... `end` loops with 1-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:60
msgid "Conditional statements like `if`, `elseif`, and `else`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:64
msgid "Uses `for i in range(N):` with 0-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:65
msgid ""
"Indentation is significant for scoping in loops and conditionals (no `end` "
"keyword)."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:67
msgid "Printing and Comments"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:71
msgid "Uses `fprintf()` functions for formatted output."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:72
msgid "Uses `%` for single-line comments."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:76
msgid "Uses `print` with f-strings for formatted output."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:77
msgid "Uses `#` for single-line comments."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:79
msgid "Multi-line Coding"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:83
msgid ""
"Uses `...` at the trailing of a line to indicate that the next line shall be"
" treated as the same line as."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:84
msgid "Python"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:86
msgid ""
"Uses `\\` at the trailing of a line to indicate that the next line shall be "
"treated as the same line as."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:87
msgid ""
"If multiple lines are inside parentheses, no specific trailing symbol is "
"required."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:89
msgid "How to Write Evolutionary Computation Algorithm via EvoX?"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:93
msgid "A MATLAB code example for PSO algorithm is as follows:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:154
msgid ""
"In MATLAB, function `init_pso()` initializes the algorithm, and a separate "
"function `step_pso()` performs an iteration step and the main function "
"`example_pso()` orchestrates the loop."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:156
msgid "EvoX"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:157
msgid "In EvoX, you can construct the PSO algorithm in following way:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:159
msgid ""
"First, it is recommended to import necessary modules and functions from EvoX"
" and PyTorch."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:169
msgid ""
"Then, you can transform the MATLAB code to the python code correspondingly "
"according to the \"Syntax Differences\" section."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:238
msgid ""
"It is worth noting that we use `[]` with `;` and `,` in MATLAB to "
"concatenate matrices and vectors along specific dimension; however, in EvoX,"
" the `torch.cat` must be invoked with argument `dim` to indicate the "
"concatenation dimension. Moreover, in PyTorch, tensors to be concatenated "
"must have the same number of dimensions; therefore, additional "
"`XXX.unsqueeze(0)` is applied to add a new dimension of length 1 before the "
"first dimension."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:242
msgid ""
"In EvoX, the PSO logic is encapsulated within a class that inherits from "
"`Algorithm`. This object-oriented design simplifies state management and "
"iteration, and introduces following advantages:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:243
msgid ""
"Inherited `evaluate()` method   You can simply call "
"`self.evaluate(self.population)` to compute fitness values, rather than "
"manually passing your objective function each iteration."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:245
msgid ""
"Built-In Workflow Integration   When you register your PSO class with a "
"workflow `StdWorkflow`, it handles iterative calls to "
"[`step()`](#StdWorkflow.step) on your behalf."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:248
msgid ""
"By extending `Algorithm`, `__init__()` sets up all major PSO components "
"(population, velocity, local/global best, etc.) in a standard Python class "
"constructor."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10002
#, fuzzy
msgid "Deploy HPO with Custom Algorithms"
msgstr "2个CSO算法协同演化。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10004
msgid ""
"In this chapter, we will focus on deploying HPO with custom algorithms, "
"emphasizing the details rather than the overall workflow. A brief "
"introduction to HPO deployment is provided in the previous chapter, "
"[Efficient HPO with EvoX](#/guide/user/3-hpo), and prior reading is highly "
"recommended."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20002
msgid "Making Algorithms Parallelizable"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20004
msgid ""
"Since we need to transform the inner algorithm into the problem, it's "
"crucial that the inner algorithm is parallelizable. Therefore, some "
"modifications to the algorithm may be necessary."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20006
msgid ""
"To ensure the function is JIT-compilable, it must meet the conditions "
"outlined in [JIT components](#/guide/developer/2-jit-able). In addition to "
"these requirements, the algorithm must also satisfy the following two "
"constraints:"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20008
msgid ""
"The algorithm should have no methods with in-place operations on the "
"attributes of the algorithm itself."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20025
msgid "The code logic does not rely on python control flow."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20058
msgid ""
"In EvoX, we can easily make the algorithm parallelizable by the "
"[`@trace_impl`](#trace_impl) decorator."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20060
msgid ""
"The parameter of this decorator is a non-parallelizable function, and the "
"decorated function is a rewrite of the original function. Detailed "
"introduction of [`@trace_impl`](#trace_impl) can be found in [JIT "
"Components](#/guide/developer/2-jit-able)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20062
msgid ""
"Under this mechanism, we can retain the original function for use outside "
"HPO tasks while enabling efficient computation within HPO tasks. Moreover, "
"this modification is highly convenient."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30002
msgid "Utilizing the HPOMonitor"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30004
msgid ""
"In the HPO task, we should use the [`HPOMonitor`](#HPOMonitor) to track the "
"metrics of each inner algorithm. The [`HPOMonitor`](#HPOMonitor) adds only "
"one method, `tell_fitness`, compared to the standard [`monitor`](#Monitor). "
"This addition is designed to offer greater flexibility in evaluating "
"metrics, as HPO tasks often involve multi-dimensional and complex metrics."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30006
msgid ""
"Users only need to create a subclass of [`HPOMonitor`](#HPOMonitor) and "
"override the `tell_fitness` method to define custom evaluation metrics."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30008
msgid ""
"We also provide a simple [`HPOFitnessMonitor`](#HPOFitnessMonitor), which "
"supports calculating the 'IGD' and 'HV' metrics for multi-objective "
"problems, and the minimum value for single-objective problems."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40002
#: ../../source/guide/user/3-hpo.ipynb:50002
#, fuzzy
msgid "A simple example"
msgstr "代码样例"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40004
msgid ""
"Here, we'll demonstrate a simple example of how to use HPO with EvoX. We "
"will use the [`PSO`](#PSO) algorithm to search for the optimal hyper-"
"parameters of a basic algorithm to solve the sphere problem."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40006
msgid "First, let's import the necessary modules."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:60002
msgid ""
"Next, we define an simple sphere problem. Note that this has no difference "
"from the common [`problems`](#evox.problems)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:80002
msgid ""
"Next, we define the algorithm. The original `step` function is non-"
"parallelizable, so we rewrite it using the [`@trace_impl`](#trace_impl) "
"decorator to make it parallelizable. Specifically, we modify in-place "
"operations and adjust the Python control flow."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100002
msgid ""
"To handle the Python control flow, we use [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch). "
"Since, in tracing mode, variables outside the method may be incorrectly "
"interpreted as static variables, we need to use state to track them. A "
"detailed introduction to [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch) can be"
" found in [JIT Components](#/guide/developer/2-jit-able). Below, we provide "
"two equivalent implementations for the `trace_step` method."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100043
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to HPO problem."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:120002
msgid ""
"We can test whether the [`HPOProblemWrapper`](#HPOProblemWrapper) correctly "
"recognizes the hyper-parameters we defined. Since we have made no "
"modifications to the hyper-parameters for the 7 instances, they should be "
"identical across all instances."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:140002
msgid ""
"We can also specify our own set of hyperparameter values. Note that the "
"number of hyperparameter sets must match the number of instances in the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). The custom hyper-parameters "
"should be provided as a dictionary whose values are wrapped in the "
"[`Parameter`](#Parameter)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:160002
msgid ""
"Now, we use the [`PSO`](#PSO) algorithm to optimize the hyper-parameters of "
"`ExampleAlgorithm`. Note that the population size of the [`PSO`](#PSO) must "
"match the number of instances; otherwise, unexpected errors may occur. In "
"this case, we need to transform the solution in the outer workflow, as the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) requires a dictionary as input."
msgstr ""

#: ../../source/guide/developer/environment.md:1
#, fuzzy
msgid "Develop environment"
msgstr "环境名。"

#: ../../source/guide/developer/environment.md:3
msgid "Clone the repository and install it in editable mode (recommended)"
msgstr ""

#: ../../source/guide/developer/environment.md:11
msgid "Nix"
msgstr ""

#: ../../source/guide/developer/environment.md:13
msgid "Enable the Nix environment by running the following command:"
msgstr ""

#: ../../source/guide/developer/environment.md:17
msgid ""
"This will create a shell with all the necessary dependencies and a `.venv` "
"directory with the Python environment."
msgstr ""

#: ../../source/guide/developer/environment.md:19
#, fuzzy
msgid "Style guide"
msgstr "用户指引"

#: ../../source/guide/developer/environment.md:21
msgid "EvoX's has the following style guide:"
msgstr ""

#: ../../source/guide/developer/environment.md:22
msgid ""
"Make sure to use [ruff](https://docs.astral.sh/ruff/) to lint your code."
msgstr ""

#: ../../source/guide/developer/environment.md:23
msgid "Make sure there are no trailing whitespaces."
msgstr ""

#: ../../source/guide/developer/environment.md:25
msgid "Pre-commit"
msgstr ""

#: ../../source/guide/developer/environment.md:27
msgid ""
"We recommend using [pre-commit](https://pre-commit.com/) to enforce the "
"style guide. After installing pre-commit, run the following command to "
"install the hooks in your local repository:"
msgstr ""

#: ../../source/guide/developer/environment.md:33
msgid "Run Unit Test"
msgstr ""

#: ../../source/guide/developer/environment.md:35
msgid ""
"prepare the test environment by installing the required packages (e.g., "
"`torch`) in your Python environment"
msgstr ""

#: ../../source/guide/developer/environment.md:36
msgid "run unittest:"
msgstr ""

#: ../../source/guide/developer/index.md:1
msgid "Developer Guide"
msgstr "开发者指引"

#: ../../source/guide/experimental/index.md:1
#, fuzzy
msgid "Experimental Features"
msgstr "关键特征"

#: ../../source/guide/install/index.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install/install.md:1
msgid "EvoX Installation Guide"
msgstr "EvoX安装教程"

#: ../../source/guide/install/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install/install.md:5
#, fuzzy
msgid "EvoX is available at PyPI and can be installed via:"
msgstr "EvoX 可以在 PyPI 上找到，可以通过以下方式安装："

#: ../../source/guide/install/install.md:16
#, fuzzy
msgid ""
"You can also assign extra options during the installation, currently "
"available extras are `gymnasium`, `neuroevolution`, `envpool`, "
"`distributed`, and `full`. For example, to install EvoX with all features, "
"run the following command:"
msgstr ""
"EvoX 提供多种可选特性，包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed`和`full`（包含所有特性）。例如，要安装包含所有特性的"
" EvoX，您可以使用以下命令："

#: ../../source/guide/install/install.md:22
#, fuzzy
msgid "Install PyTorch with accelerator support"
msgstr "安装支持GPU加速的JAX"

#: ../../source/guide/install/install.md:24
#, fuzzy
msgid ""
"`evox` relies on `torch` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`EvoX`依赖于`JAX`来提供硬件加速的能力。这些Python包的整体架构如下："

#: ../../source/guide/install/install.md:42
msgid ""
"To summarize, whether `evox` has CPU support or Nvidia GPU support (CUDA) or"
" AMD GPU support (ROCm) depends on the installed PyTorch version. Please "
"refer to the PyTorch official website for more installation help: "
"[`torch`](https://pytorch.org/)"
msgstr ""

#: ../../source/guide/install/install.md:45
msgid "Nvidia GPU support on Windows"
msgstr ""

#: ../../source/guide/install/install.md:47
msgid ""
"EvoX support GPU acceleration through PyTorch. There are two ways to use "
"PyTorch with GPU acceleration on Windows:"
msgstr ""

#: ../../source/guide/install/install.md:50
msgid ""
"Using WSL 2 (Windows Subsystem for Linux) and install PyTorch on the Linux "
"side."
msgstr ""

#: ../../source/guide/install/install.md:51
msgid "Directly install PyTorch on Windows."
msgstr ""

#: ../../source/guide/install/install.md:53
msgid ""
"We also provide a [one-click script](https://github.com/EMI-"
"Group/evox/blob/main/win-install.bat) for fast deployment on fresh installed"
" windows 10/11 64bit with Nvidia GPUs. The script will not use WSL 2 and "
"will install the native Pytorch version on Windows. It will automatically "
"install related applications like VSCode, Git and MiniForge3."
msgstr ""

#: ../../source/guide/install/install.md:55
#, fuzzy
msgid "Windows WSL 2 (optional)"
msgstr "Windows WSL 2"

#: ../../source/guide/install/install.md:56
#, fuzzy
msgid ""
"Ensure the [Nvidia "
"driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) is properly "
"installed first. Otherwise the script will fall back to cpu mode."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install/install.md:57
msgid ""
"When running the script, ensure a stable network (accessible to `github.com`"
" etc.)."
msgstr ""

#: ../../source/guide/install/install.md:58
msgid ""
"If the script is failed due to network failure, close and reopen it to "
"continue the installation."
msgstr ""

#: ../../source/guide/install/install.md:61
#, fuzzy
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us), and install "
"it. Then your WSL 2 will support Nvidia GPUs in its Linux environments."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install/install.md:64
#, fuzzy
msgid ""
"Do **NOT** install any NVIDIA GPU Linux driver within WSL 2. Install the "
"driver on the Windows side."
msgstr ""
"请**不要**在 WSL 2 内部安装任何 NVIDIA GPU Linux 驱动程序。GPU 驱动程序属于内核空间程序，应安装在 Windows "
"主机系统上。"

#: ../../source/guide/install/install.md:68
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda/wsl-"
"user-guide/index.html)"

#: ../../source/guide/install/install.md:71
msgid "AMD GPU (ROCm) support"
msgstr ""

#: ../../source/guide/install/install.md:73
msgid ""
"We recommend using a Docker container from "
"[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)."
msgstr ""

#: ../../source/guide/install/install.md:79
#, fuzzy
msgid "Verify the installation"
msgstr "验证安装是否正确"

#: ../../source/guide/install/install.md:81
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install/python.md:1
msgid "Python Installation Guide"
msgstr "Python安装教程"

#: ../../source/guide/install/python.md:3
msgid ""
"EvoX is written in Python, so you will need to have Python installed on your"
" system. EvoX support Python 3.9 and above, and we recommend using the "
"latest version of Python."
msgstr ""
"EvoX是用Python写的，所以你需要先在你的系统上安装Python。EvoX支持Python 3.9及以上，同时我们推荐使用最新版的Python。"

#: ../../source/guide/install/python.md:6
msgid "Windows Version"
msgstr "Windows 版本"

#: ../../source/guide/install/python.md:8
msgid ""
"Go to [Download Python](https://www.python.org/downloads/) and download the "
"latest version of Python."
msgstr "访问[Download Python](https://www.python.org/downloads/) 来下载最新版的Python。"

#: ../../source/guide/install/python.md:11
msgid ""
"Make sure to check the box that says \"Add Python to PATH\" during the "
"installation process."
msgstr "请确保在安装的过程中勾选\"Add Python to PATH\"这个选项。"

#: ../../source/guide/install/python.md:14
msgid "Linux Version"
msgstr "Linux 版本"

#: ../../source/guide/install/python.md:16
msgid ""
"Different Linux distributions have different ways to install Python. It "
"depends on the package manager of your distribution. Here are some examples:"
msgstr "不同的Linux发行版有不同的安装Python的方式。这取决于发行版所用的包管理器。这里有些例子："

#: ../../source/guide/install/python.md:19
msgid "Debian/Ubuntu: `apt`"
msgstr ""

#: ../../source/guide/install/python.md:20
msgid "Archlinux: `pacman`"
msgstr ""

#: ../../source/guide/install/python.md:21
msgid "Fedora: `dnf`"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/user/1-start.ipynb:10004
msgid ""
"In this notebook, we will help you be familiar with EvoX through an simple "
"example."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:10006
msgid "To start with, make sure you have already installed the EvoX."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40002
msgid "The basic running process in EvoX"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40004
msgid ""
"As a distributed GPU-accelerated framework for scalable evolutionary "
"computation, EvoX can be used to do many kinds computations, so we say "
"\"EvoX is all you need\". Though many kinds of computations are different "
"more or less, in EvoX we standardize the basic running process:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40013
msgid ""
"EvoX offers a comprehensive suite of 50+ Evolutionary Algorithms (EAs) and a"
" wide range of 100+ Benchmark Problems/Environments, all benefiting from "
"distributed GPU-acceleration."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40015
#, fuzzy
msgid ""
"For more details, please refer to our API documentation: [List of "
"Algorithms](#evox.algorithms) and [List of Problems](#evox.problems)."
msgstr ""
"有关更详细的列表，请参阅我们的 API "
"文档。[算法列表](https://evox.readthedocs.io/en/latest/api/algorithms/index.html) 和"
" [问题列表](https://evox.readthedocs.io/en/latest/api/problems/index.html)。"

#: ../../source/guide/user/1-start.ipynb:40017
msgid ""
"Here we will create a [PSO](#evox.algorithms.pso_variants.pso) algorithm and"
" an [Ackley](#evox.problems.numerical.basic.Ackley) function problem."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:60002
msgid ""
"Notice the algorithm and problem themselves do not contain the monitoring of"
" the steps, so we will not get any feed back only depending on them. It "
"turns out that we need a **monitor**."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:60006
#, fuzzy
msgid ""
"[`Monitor`](#evox.workflows.eval_monitor.EvalMonitor) is a standard class in"
" EvoX to monitor the intermediate values inside a optimization process. "
"Information like fitness or population can be easily obtained by the "
"monitor."
msgstr "监视器是监控优化过程中中间值的标准方法。像适应度或种群这样的信息可以通过监视器轻松获得。"

#: ../../source/guide/user/1-start.ipynb:60008
msgid "Doing is better than saying, so let us create a “Evaluation monitor”:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:80004
msgid ""
"A **workflow** outlines the series of steps required to accomplish a task or"
" project. In EvoX, a workflow represents the overall process of evolutionary"
" computation, putting the algorithm, problem and monitor together."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:80006
msgid ""
"If we want to run the algorithm to solve the problem with a monitor, we need"
" to create a workflow of the [`Workflow`](#evox.core.components.Workflow) "
"class."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:100004
msgid "Now, we can run the workflow:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:120002
msgid ""
"Congretulations if you can reproduce the Quick Start demo! Hope you enjoy "
"the EvoX!"
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:10002
#, fuzzy
msgid "Extended Applications"
msgstr "处理扩展应用"

#: ../../source/guide/user/2-problems.ipynb:10004
msgid ""
"EvoX facilitates efficient exploration of complex optimization landscapes, "
"effective tackling of black-box optimization challenges, and deep dives into"
" neuroevolution with Brax. Thus, it is talented in extended applications.  "
"Here we will show an example of Neuroevolution Tasks using EvoX and Brax."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:40002
#, fuzzy
msgid "Use EvoX to solve Neuroevolution Tasks"
msgstr "神经演化任务"

#: ../../source/guide/user/2-problems.ipynb:40003
msgid ""
"Neuroevolution is an optimization method that combines neural networks with "
"evolutionary algorithms to evolve the structure and parameters of neural "
"networks. By simulating natural selection and genetic mechanisms, "
"Neuroevolution aims to optimize neural network architectures and weights, "
"addressing complex problems such as game AI, robotic control, and more."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:40005
msgid ""
"In our example of neuroevolution tasks, Brax is needed. So it is recommended"
" to install Brax if you want to replicate this example."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:50006
msgid ""
"Here we will demonstrate a \"hopper\" environment of Brax. For more "
"information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:80004
msgid "Through the `SimpleMLP` class, we can initiate a MLP model."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:100002
msgid ""
"We can compute the total number of the model parameters, and check if the "
"model id initialized correctly. If everything goes well, we will see the "
"total number is 63."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:120002
msgid ""
"We can also test the dimoension of the inputs and outputs. If everything "
"goes well, 11 inputs will obtain 3 outputs."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:140002
#, fuzzy
msgid ""
"If we check the weights data of this network, we will see the data is in the"
" dictionary form, and many EC algorithms cannot directly work with such a "
"format:"
msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）算法无法直接处理这种格式的数据。"

#: ../../source/guide/user/2-problems.ipynb:160002
#, fuzzy
msgid ""
"Fortunately, EvoX provides some useful utilities to help us bridge the gap, "
"and in this case, we have "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) class"
" to help us convert a tree-like struct into a vector and back."
msgstr ""
"幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#: ../../source/guide/user/2-problems.ipynb:160008
msgid ""
"[`to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.to_vector) "
"can convert a parameters dictionary to a vector."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160009
msgid ""
"[`to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.to_params) "
"can convert a vector back to a parameters dictionary."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160011
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/user/2-problems.ipynb:160013
msgid ""
"[`batched_to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_vector)"
" can convert a batched parameters dictionary to a batch of vectors."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160014
msgid ""
"[`batched_to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_params)"
" can convert a batch of vectors back to a batched parameters dictionary."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:180005
msgid ""
"For some algorithms designed for neuroevolution, that is, algorithms that "
"directly accept the batched parameters dictionary, adapter is not necessary "
"and should be removed to improve performance."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:180012
msgid ""
"We still initiate a [PSO](#evox.algorithms.pso_variants.pso.PSO) algorithm, "
"and the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"hopper\" "
"environment."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:200003
#, fuzzy
msgid "`max_episode_length` is the maximum number of steps for each episode."
msgstr "运行的最大的时间步的数量。"

#: ../../source/guide/user/2-problems.ipynb:200005
#, fuzzy
msgid "`num_episodes` is the number of episodes to run for each evaluation."
msgstr "用于评估每个个体的幕数量。"

#: ../../source/guide/user/2-problems.ipynb:240007
#, fuzzy
msgid ""
"The following block will take around 1 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#: ../../source/guide/user/2-problems.ipynb:260003
msgid ""
"The PSO wasn’t specialized for this type of tasks, so its performance "
"limitations here are expected. Here we just show an example."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:260006
msgid ""
"Hope you can use a quantity of more effective algorithms in EvoX and enjoy "
"your time!"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10002
#, fuzzy
msgid "Efficient HPO with EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/guide/user/3-hpo.ipynb:10004
msgid ""
"In this chapter, we will explore how to use EvoX for hyperparameter "
"optimization (HPO)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10006
msgid ""
"HPO plays a crucial role in many machine learning tasks but is often "
"overlooked due to its high computational cost, which can sometimes take days"
" to process, as well as the challenges involved in deployment."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10008
msgid ""
"With EvoX, we can simplify HPO deployment using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) and achieve efficient computation "
"by leveraging the `vmap` method and GPU acceleration."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:20002
msgid "Transforming Workflow into Problem"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:20004
#, fuzzy
msgid "HPO structure"
msgstr "文档的结构"

#: ../../source/guide/user/3-hpo.ipynb:20010
msgid ""
"The key to deploying HPO with EvoX is to transform the "
"[`workflows`](#evox.workflows) into [`problems`](#evox.problems) using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). Once transformed, we can treat "
"the [`workflows`](#evox.workflows) as standard [`problems`](#evox.problems)."
" The input to the 'HPO problem' consists of the hyper-parameters, and the "
"output is the evaluation metrics."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:30002
msgid "The Key Component -- `HPOProblemWrapper`"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:30004
msgid ""
"To ensure the [`HPOProblemWrapper`](#HPOProblemWrapper) recognizes the "
"hyper-parameters, we need to wrap them using [`Parameter`](#Parameter). With"
" this straightforward step, the hyper-parameters will be automatically "
"identified."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40002
msgid "Utilizing the `HPOFitnessMonitor`"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40004
msgid ""
"We provide an [`HPOFitnessMonitor`](#HPOFitnessMonitor) that supports "
"calculating 'IGD' and 'HV' metrics for multi-objective problems, as well as "
"the minimum value for single-objective problems."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40006
msgid ""
"It is important to note that the [`HPOFitnessMonitor`](#HPOFitnessMonitor) "
"is a basic monitor designed for HPO problems. You can also create your own "
"customized monitor flexibly using the approach outlined in [Deploy HPO with "
"Custom Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50004
msgid ""
"Here, we'll demonstrate a simple example of using EvoX for HPO. "
"Specifically, we will use the [PSO](#PSO) algorithm to optimize the hyper-"
"parameters of the [PSO](#PSO) algorithm for solving the sphere problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50006
msgid ""
"Please note that this chapter provides only a brief overview of HPO "
"deployment. For a more detailed guide, refer to [Deploy HPO with Custom "
"Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50008
msgid "To start, let's import the necessary modules."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:70002
msgid "Next, we define a simple Sphere problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:90002
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to an HPO problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110002
msgid "The [`HPOProblemWrapper`](#HPOProblemWrapper) takes 4 arguments:"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110003
#, fuzzy
msgid ""
"`iterations`: The number of iterations to be executed in the optimization "
"process."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: ../../source/guide/user/3-hpo.ipynb:110004
#, fuzzy
msgid ""
"`num_instances`: The number of instances to be executed in parallel in the "
"optimization process."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: ../../source/guide/user/3-hpo.ipynb:110005
msgid ""
"`workflow`: The workflow to be used in the optimization process. Must be "
"wrapped by [`jit_class`](#jit_class)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110006
msgid ""
"`copy_init_state`: Whether to copy the initial state of the workflow for "
"each evaluation. Defaults to `True`. If your workflow contains operations "
"that IN-PLACE modify the tensor(s) in initial state, this should be set to "
"`True`. Otherwise, you can set it to `False` to save memory."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110008
msgid ""
"We can verify whether the [`HPOProblemWrapper`](#HPOProblemWrapper) "
"correctly recognizes the hyper-parameters we define. Since no modifications "
"are made to the hyper-parameters across the 5 instances, they should remain "
"identical for all instances."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:130002
msgid ""
"We can also define a custom set of hyperparameter values. It is important to"
" ensure that the number of hyperparameter sets matches the number of "
"instances in the [`HPOProblemWrapper`](#HPOProblemWrapper). Additionally, "
"custom hyper-parameters must be provided as a dictionary whose values are "
"wrapped using the [`Parameter`](#Parameter)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150002
msgid ""
"Now, we use the [PSO](#PSO) algorithm to optimize the hyperparameters of the"
" [PSO](#PSO) algorithm."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150004
msgid ""
"It is important to ensure that the population size of the [PSO](#PSO) "
"matches the number of instances; otherwise, unexpected errors may occur."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150006
msgid ""
"Additionally, the solution needs to be transformed in the outer workflow, as"
" the [`HPOProblemWrapper`](#HPOProblemWrapper) requires the input to be in "
"the form of a dictionary."
msgstr ""

#: ../../source/guide/user/index.md:1 ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:22 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr "杂项"

#: ../../source/index.md:22
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:31
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"

#: ../../source/index.md:33
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary "
"computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/index.md:37
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:39
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:40
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:41
#, fuzzy
msgid ""
"Leverage the power of Distributed Workflows for even more rapid "
"optimization."
msgstr ""
"利用 {class}`分布式工作流 <evox.workflows.RayDistributedWorkflow>` 的强大功能，实现更快速的优化。"

#: ../../source/index.md:43
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:44
#, fuzzy
msgid ""
"Cater to all your needs with both [Single-objective and Multi-"
"objectiv](#algorithms) optimization capabilities."
msgstr ""
"满足您所有需求，包括 {doc}`单目标 <api/algorithms/so/index>` 和 {doc}`多目标 "
"<api/algorithms/mo/index>`优化功能。"

#: ../../source/index.md:45
#, fuzzy
msgid ""
"Dive into a comprehensive library of [Benchmark Problems](#problems), "
"ensuring robust testing and evaluation."
msgstr "深入了解全面的{doc}`基准测试问题库 <api/problems/numerical/index>`，确保进行稳健的测试和评估。"

#: ../../source/index.md:46
#, fuzzy
msgid ""
"Explore the frontier of AI with extensive tools for "
"[Neuroevolution](#neuroevolution) tasks."
msgstr ""
"探索人工智能前沿领域，利用广泛的工具进行 {doc}`神经演化 <api/problems/neuroevolution/index>` 任务。"

#: ../../source/index.md:48
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:49
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:50
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and clean "
"programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:53
msgid "<br></br>"
msgstr "<br></br>"

#: ../../source/index.md:60
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> Installation "
"Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> 安装教程"

#: ../../source/index.md:66
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> User Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> 用户教程"

#: ../../source/index.md:72
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> Developer Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> 开发者教程"

#: ../../source/index.md:82
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 算法"

#: ../../source/index.md:88
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 问题"

#: ../../source/index.md:95
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 指标"

#: ../../source/miscellaneous/selecting_gpu.md:1
msgid "Selecting GPU / CPU"
msgstr "选择 GPU / CPU"

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""
"要在特定的 GPU 上运行程序，您可以使用 `CUDA_VISIBLE_DEVICES` 环境变量。例如，要在第二个 GPU 上运行程序，您可以使用："

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr "要在多个GPU上跑你的程序，你可以用："

#: ../../source/miscellaneous/selecting_gpu.md:15
msgid "To disable GPU usage (use CPU), you can use:"
msgstr "如果要禁用GPU（即使用CPU），你可以用："
