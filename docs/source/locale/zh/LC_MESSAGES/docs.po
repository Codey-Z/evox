# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-25 21:47+0800\n"
"PO-Revision-Date: 2025-01-17 13:53+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/"
"projects/evox/evox/zh_Hans/>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.10-dev\n"
"Generated-By: Babel 2.16.0\n"

#: ../../source/apidocs/evox/evox.md:1
msgid "{py:mod}`evox`"
msgstr "{py:mod}`evox`"

#: ../../source/apidocs/evox/evox.algorithms.md:10
#: ../../source/apidocs/evox/evox.md:10
#: ../../source/apidocs/evox/evox.operators.md:10
#: ../../source/apidocs/evox/evox.problems.md:10
msgid "Subpackages"
msgstr "子包"

#: ../../source/apidocs/evox/evox.algorithms.md:1
msgid "{py:mod}`evox.algorithms`"
msgstr "{py:mod}`evox.algorithms`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:31
#: ../../source/apidocs/evox/evox.algorithms.md:22
#: ../../source/apidocs/evox/evox.algorithms.mo.md:21
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:26
#: ../../source/apidocs/evox/evox.core.md:22
#: ../../source/apidocs/evox/evox.metrics.md:21
#: ../../source/apidocs/evox/evox.operators.crossover.md:21
#: ../../source/apidocs/evox/evox.operators.md:22
#: ../../source/apidocs/evox/evox.operators.mutation.md:19
#: ../../source/apidocs/evox/evox.operators.sampling.md:21
#: ../../source/apidocs/evox/evox.operators.selection.md:22
#: ../../source/apidocs/evox/evox.problems.numerical.md:21
#: ../../source/apidocs/evox/evox.utils.md:21
#: ../../source/apidocs/evox/evox.workflows.md:20
msgid "Package Contents"
msgstr "软件包内容"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:26
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:33
#: ../../source/apidocs/evox/evox.algorithms.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.md:23
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:112
#: ../../source/apidocs/evox/evox.core.jit_util.md:46
#: ../../source/apidocs/evox/evox.core.md:24
#: ../../source/apidocs/evox/evox.core.module.md:98
#: ../../source/apidocs/evox/evox.metrics.md:23
#: ../../source/apidocs/evox/evox.operators.crossover.md:23
#: ../../source/apidocs/evox/evox.operators.md:24
#: ../../source/apidocs/evox/evox.operators.mutation.md:21
#: ../../source/apidocs/evox/evox.operators.sampling.md:23
#: ../../source/apidocs/evox/evox.operators.selection.md:24
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.md:23
#: ../../source/apidocs/evox/evox.utils.control_flow.md:12
#: ../../source/apidocs/evox/evox.utils.md:23
#: ../../source/apidocs/evox/evox.workflows.md:22
msgid "Data"
msgstr "数据"

#: ../../source/apidocs/evox/evox.algorithms.md:30
msgid "{py:obj}`__all__ <evox.algorithms.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:52
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:38
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:48
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:45
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:28
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:24
#: ../../source/apidocs/evox/evox.algorithms.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:40
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:168
#: ../../source/apidocs/evox/evox.core.components.md:36
#: ../../source/apidocs/evox/evox.core.jit_util.md:58
#: ../../source/apidocs/evox/evox.core.md:36
#: ../../source/apidocs/evox/evox.core.module.md:162
#: ../../source/apidocs/evox/evox.metrics.gd.md:24
#: ../../source/apidocs/evox/evox.metrics.hv.md:24
#: ../../source/apidocs/evox/evox.metrics.igd.md:24
#: ../../source/apidocs/evox/evox.metrics.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:36
#: ../../source/apidocs/evox/evox.operators.crossover.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:24
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:24
#: ../../source/apidocs/evox/evox.operators.md:36
#: ../../source/apidocs/evox/evox.operators.mutation.md:33
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:28
#: ../../source/apidocs/evox/evox.operators.sampling.md:35
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:24
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:24
#: ../../source/apidocs/evox/evox.operators.selection.md:36
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:68
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:28
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:28
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:32
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:36
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:80
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:42
#: ../../source/apidocs/evox/evox.problems.numerical.md:35
#: ../../source/apidocs/evox/evox.utils.control_flow.md:24
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:76
#: ../../source/apidocs/evox/evox.utils.md:35
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:24
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:40
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:44
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:24
#: ../../source/apidocs/evox/evox.workflows.md:34
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:26
msgid "API"
msgstr "API"

#: ../../source/apidocs/evox/evox.algorithms.md:42
msgid ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."
msgstr ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:1
msgid "{py:mod}`evox.algorithms.de_variants`"
msgstr "{py:mod}`evox.algorithms.de_variants`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:10
#: ../../source/apidocs/evox/evox.core.md:10
#: ../../source/apidocs/evox/evox.metrics.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.md:10
#: ../../source/apidocs/evox/evox.operators.selection.md:10
#: ../../source/apidocs/evox/evox.problems.md:20
#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.md:10
#: ../../source/apidocs/evox/evox.utils.md:10
#: ../../source/apidocs/evox/evox.vis_tools.md:10
#: ../../source/apidocs/evox/evox.workflows.md:10
msgid "Submodules"
msgstr "子模块"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:32
msgid "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:44
msgid "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"
msgstr "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:1
msgid "{py:mod}`evox.algorithms.de_variants.code`"
msgstr "{py:mod}`evox.algorithms.de_variants.code`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:10
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:10
#: ../../source/apidocs/evox/evox.core.components.md:10
#: ../../source/apidocs/evox/evox.core.jit_util.md:10
#: ../../source/apidocs/evox/evox.core.module.md:10
#: ../../source/apidocs/evox/evox.metrics.gd.md:10
#: ../../source/apidocs/evox/evox.metrics.hv.md:10
#: ../../source/apidocs/evox/evox.metrics.igd.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:10
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:10
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:10
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:10
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:10
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:10
#: ../../source/apidocs/evox/evox.utils.control_flow.md:10
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:10
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:10
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:10
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:10
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:10
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:10
msgid "Module Contents"
msgstr "模块内容"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:12
#: ../../source/apidocs/evox/evox.core.components.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:12
#: ../../source/apidocs/evox/evox.core.module.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:12
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:12
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:12
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:12
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:12
msgid "Classes"
msgstr "类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:18
msgid "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"
msgstr "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"

#: ../../../src/evox/algorithms/de_variants/code.py:20
#: ../../../src/evox/algorithms/de_variants/code.py:111
msgid "The implementation of CoDE algorithm."
msgstr "CoDE算法实现"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:38
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.code.current2rand_1>`"
msgstr ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.code.current2rand_1>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:42
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.code.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.code.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:46
msgid ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.de_variants.code.current2pbest_1_bin>`"
msgstr ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.de_variants.code.current2pbest_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:58
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:54
msgid "[0, 0, 1, 0]"
msgstr "[0, 0, 1, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:68
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:64
msgid "[0, 0, 2, 0]"
msgstr "[0, 0, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:78
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:84
msgid "[0, 0, 1, 2]"
msgstr "[0, 0, 1, 2]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:88
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:74
msgid "[0, 1, 2, 0]"
msgstr "[0, 1, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:98
msgid "[3, 2, 1, 0]"
msgstr "[3, 2, 1, 0]"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:108
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:94
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:34
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:58
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:49
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:30
msgid "Bases: {py:obj}`evox.core.Algorithm`"
msgstr "基础: {py:obj}`evox.core.Algorithm`"

#: ../../../src/evox/algorithms/de_variants/code.py:113
msgid ""
"Reference: Wang Y, Cai Z, Zhang Q. Differential evolution with composite "
"trial vector generation strategies and control parameters[J]. IEEE "
"transactions on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"参考文献: Wang Y, Cai Z, Zhang Q. 使用复合试验向量生成策略和控制参数的差分进化[J]. IEEE 进化计算交易, 2011, "
"15(1): 55-66."

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:113
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:99
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:39
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:63
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:54
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:35
#: ../../source/apidocs/evox/evox.core.components.md:47
#: ../../source/apidocs/evox/evox.core.components.md:88
#: ../../source/apidocs/evox/evox.core.components.md:112
#: ../../source/apidocs/evox/evox.core.components.md:144
#: ../../source/apidocs/evox/evox.core.module.md:228
#: ../../source/apidocs/evox/evox.core.module.md:430
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:110
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:43
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:68
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:100
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:102
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:72
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:91
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:122
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:153
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:184
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:215
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:246
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:277
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:35
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:53
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:115
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:139
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:35
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:63
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:35
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:52
msgid "Initialization"
msgstr "初始化"

#: ../../../src/evox/algorithms/de_variants/code.py:117
msgid "Initialize the CoDE algorithm with the given parameters."
msgstr "使用给定的参数初始化 CoDE 算法。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.exv.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md
msgid "Parameters"
msgstr "参数"

#: ../../../src/evox/algorithms/de_variants/code.py:119
#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
#: ../../../src/evox/algorithms/de_variants/sade.py:105
#: ../../../src/evox/algorithms/de_variants/shade.py:41
#: ../../../src/evox/algorithms/es_variants/ars.py:41
#: ../../../src/evox/algorithms/es_variants/asebo.py:41
#: ../../../src/evox/algorithms/es_variants/des.py:41
#: ../../../src/evox/algorithms/es_variants/esmc.py:41
#: ../../../src/evox/algorithms/es_variants/guided_es.py:41
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:41
#: ../../../src/evox/algorithms/es_variants/open_es.py:41
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:41
#: ../../../src/evox/algorithms/es_variants/snes.py:41
#: ../../../src/evox/algorithms/mo/moead.py:60
#: ../../../src/evox/algorithms/mo/nsga2.py:41
#: ../../../src/evox/algorithms/mo/rvea.py:41
#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:41
#: ../../../src/evox/algorithms/pso_variants/pso.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
msgid "The size of the population."
msgstr "种群大小。"

#: ../../../src/evox/algorithms/de_variants/code.py:120
#: ../../../src/evox/algorithms/de_variants/de.py:42
#: ../../../src/evox/algorithms/de_variants/jade.py:42
#: ../../../src/evox/algorithms/de_variants/sade.py:106
#: ../../../src/evox/algorithms/de_variants/shade.py:42
msgid "The lower bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:121
#: ../../../src/evox/algorithms/de_variants/de.py:43
#: ../../../src/evox/algorithms/de_variants/jade.py:43
#: ../../../src/evox/algorithms/de_variants/sade.py:107
#: ../../../src/evox/algorithms/de_variants/shade.py:43
msgid "The upper bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:122
msgid "The number of differential padding vectors to use. Defaults to 5."
msgstr "使用的差分填充向量数量。默认值为 5。"

#: ../../../src/evox/algorithms/de_variants/code.py:123
msgid ""
"A tensor of control parameter pairs for the algorithm. Defaults to a "
"predefined tensor."
msgstr "算法的控制参数对的张量。默认为预定义的张量。"

#: ../../../src/evox/algorithms/de_variants/code.py:124
msgid ""
"A boolean indicating whether to replace individuals in the population. "
"Defaults to False."
msgstr "一个布尔值，指示是否替换种群中的个体。默认为 False。"

#: ../../../src/evox/algorithms/de_variants/code.py:125
#: ../../../src/evox/algorithms/de_variants/de.py:50
#: ../../../src/evox/algorithms/de_variants/ode.py:50
msgid "The device to use for tensor computations. Defaults to None."
msgstr "用于张量计算的设备。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/code.py:124
msgid "Perform one iteration of the CoDE algorithm."
msgstr "执行CoDE算法的一次迭代。"

#: ../../../src/evox/algorithms/de_variants/code.py:126
msgid "This step is composed of the following steps:"
msgstr "此步骤由以下步骤组成："

#: ../../../src/evox/algorithms/de_variants/code.py:127
msgid "Generate trial vectors using the differential sum."
msgstr "使用微分和生成试验向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:128
msgid "Apply crossover to generate a new vector."
msgstr "应用交叉生成一个新向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:129
msgid "Apply mutation to generate a new vector."
msgstr "应用变异以生成新向量。"

#: ../../../src/evox/algorithms/de_variants/code.py:130
msgid "Update the population and fitness values."
msgstr "更新种群和适应度。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:1
msgid "{py:mod}`evox.algorithms.de_variants.de`"
msgstr "{py:mod}`evox.algorithms.de_variants.de`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:18
msgid "{py:obj}`DE <evox.algorithms.de_variants.de.DE>`"
msgstr "{py:obj}`DE <evox.algorithms.de_variants.de.DE>`"

#: ../../../src/evox/algorithms/de_variants/de.py:20
#: ../../../src/evox/algorithms/de_variants/de.py:33
msgid "Differential Evolution (DE) algorithm for optimization."
msgstr "差分进化（DE）算法用于优化。"

#: ../../../src/evox/algorithms/de_variants/de.py:37
msgid ""
"`__init__`: Initializes the DE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`: 使用给定的参数初始化 DE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/de.py:38
#: ../../../src/evox/algorithms/de_variants/jade.py:38
#: ../../../src/evox/algorithms/de_variants/ode.py:38
msgid ""
"`init_step`: Performs the initial evaluation of the population's fitness and"
" proceeds to the first optimization step."
msgstr "`init_step`: 执行种群适应度的初始评估，并进入第一次优化步骤。"

#: ../../../src/evox/algorithms/de_variants/de.py:39
msgid ""
"`step`: Executes a single optimization step of the DE algorithm, involving "
"mutation, crossover, and selection processes."
msgstr "`step`：执行DE算法的单个优化步骤，包括变异、交叉和选择过程。"

#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class. It is expected"
" to be provided by the `Problem` class or another external component."
msgstr "请注意，`evaluate` 方法在这个类中未定义。它预计由 `Problem` 类或其他外部组件提供。"

#: ../../../src/evox/algorithms/de_variants/de.py:39
msgid "Initialize the DE algorithm with the given parameters."
msgstr "使用给定的参数初始化 DE 算法。"

#: ../../../src/evox/algorithms/de_variants/de.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:44
msgid ""
"The base vector type used in mutation. Either \"best\" or \"rand\". Defaults"
" to \"rand\"."
msgstr "用于变异的基础向量类型。可以是 \"best\" 或 \"rand\"。默认值为 \"rand\"。"

#: ../../../src/evox/algorithms/de_variants/de.py:45
#: ../../../src/evox/algorithms/de_variants/jade.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:45
msgid ""
"The number of difference vectors used in mutation. Must be at least 1 and "
"less than half of the population size. Defaults to 1."
msgstr "在变异中使用的差异向量的数量。必须至少为 1 且小于种群大小的一半。默认为 1。"

#: ../../../src/evox/algorithms/de_variants/de.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor. Defaults to 0.5."
msgstr "施加于差异向量的差异权重 (F)。可以是浮点数或张量。默认为 0.5。"

#: ../../../src/evox/algorithms/de_variants/de.py:47
msgid "The crossover probability (CR). Defaults to 0.9."
msgstr "交叉概率（CR）。默认为 0.9。"

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:45
msgid ""
"The mean for initializing the population with a normal distribution. "
"Defaults to None."
msgstr "用于使用正态分布初始化种群的均值。默认值为 None。"

#: ../../../src/evox/algorithms/de_variants/de.py:49
#: ../../../src/evox/algorithms/de_variants/jade.py:46
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Defaults to None."
msgstr "用于用正态分布初始化种群的标准差。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/de.py:46
#: ../../../src/evox/algorithms/de_variants/jade.py:46
#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"Perform the initial evaluation of the population's fitness and proceed to "
"the first optimization step."
msgstr "执行种群适应度的初步评估，并进入第一个优化步骤。"

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:48
#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"This method evaluates the fitness of the initial population and then calls "
"the `step` method to perform the first optimization iteration."
msgstr "此方法评估初始种群的适应度，然后调用 `step` 方法进行第一次优化迭代。"

#: ../../../src/evox/algorithms/de_variants/de.py:54
msgid "Execute a single optimization step of the DE algorithm."
msgstr "执行 DE 算法的单步优化。"

#: ../../../src/evox/algorithms/de_variants/de.py:56
#: ../../../src/evox/algorithms/de_variants/jade.py:56
#: ../../../src/evox/algorithms/de_variants/ode.py:56
#: ../../../src/evox/algorithms/de_variants/sade.py:128
#: ../../../src/evox/algorithms/de_variants/shade.py:48
msgid "This involves the following sub-steps:"
msgstr "这涉及以下子步骤："

#: ../../../src/evox/algorithms/de_variants/de.py:57
#: ../../../src/evox/algorithms/de_variants/ode.py:57
msgid ""
"Mutation: Generate mutant vectors based on the specified base vector "
"strategy (`best` or `rand`) and the number of difference vectors."
msgstr "Mutation: 生成基准向量策略 (`best` 或 `rand`) 和差异向量数量的基础上，根据这些信息生成变异向量"

#: ../../../src/evox/algorithms/de_variants/de.py:58
#: ../../../src/evox/algorithms/de_variants/ode.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability."
msgstr "交叉：根据交叉概率，在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/de_variants/de.py:59
#: ../../../src/evox/algorithms/de_variants/jade.py:59
#: ../../../src/evox/algorithms/de_variants/ode.py:59
msgid ""
"Selection: Evaluate the fitness of the new population and select the better "
"individuals between the current and new populations."
msgstr "选择：评估新种群的适应度，并在当前种群和新种群之间选择更优的个体。"

#: ../../../src/evox/algorithms/de_variants/de.py:61
#: ../../../src/evox/algorithms/de_variants/ode.py:62
msgid ""
"The method ensures that all new population vectors are clamped within the "
"specified bounds."
msgstr "这个方法确保新种群向量都会被截断在指定范围内。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.jade`"
msgstr "{py:mod}`evox.algorithms.de_variants.jade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:18
msgid "{py:obj}`JaDE <evox.algorithms.de_variants.jade.JaDE>`"
msgstr "{py:obj}`JaDE <evox.algorithms.de_variants.jade.JaDE>`"

#: ../../../src/evox/algorithms/de_variants/jade.py:20
#: ../../../src/evox/algorithms/de_variants/jade.py:33
msgid "Adaptive Differential Evolution (JaDE) algorithm for optimization."
msgstr "自适应差分进化算法 JaDE，用于优化任务。"

#: ../../../src/evox/algorithms/de_variants/jade.py:37
msgid ""
"`__init__`: Initializes the JaDE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：用给定的参数初始化 JaDE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid ""
"`step`: Executes a single optimization step of the JaDE algorithm, involving"
" mutation, crossover, selection, and adaptation of strategy parameters."
msgstr "`step`: 执行 JaDE 算法的单个优化步骤，涉及突变、交叉、选择和策略参数的适应性。"

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid "Initialize the JaDE algorithm with the given parameters."
msgstr "根据给定的参数初始化 JaDE 算法。"

#: ../../../src/evox/algorithms/de_variants/jade.py:47
#: ../../../src/evox/algorithms/de_variants/sade.py:110
#: ../../../src/evox/algorithms/de_variants/shade.py:45
msgid ""
"The device to use for tensor computations (e.g., \"cpu\" or \"cuda\"). "
"Defaults to None."
msgstr "用于张量计算的设备（例如，“cpu”或“cuda”）。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/jade.py:48
msgid ""
"The learning rate for updating the adaptive parameters F_u and CR_u. "
"Defaults to 0.1."
msgstr "自适应参数 F_u 和 CR_u 更新的学习率。默认值为 0.1。"

#: ../../../src/evox/algorithms/de_variants/jade.py:54
msgid "Execute a single optimization step of the JaDE algorithm."
msgstr "执行JaDE算法的单次优化步骤。"

#: ../../../src/evox/algorithms/de_variants/jade.py:57
msgid ""
"Mutation: Generate mutant vectors by combining difference vectors and "
"adapting the mutation factor F."
msgstr "变异：通过结合差异向量并调整变异因子 F 来生成突变向量。"

#: ../../../src/evox/algorithms/de_variants/jade.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability CR."
msgstr "交叉：根据交叉概率 CR 在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/de_variants/jade.py:60
msgid ""
"Adaptation: Update the adaptive parameters F_u and CR_u based on the "
"successful mutations."
msgstr "自适应参数的更新：根据成功的突变来更新参数F_u和CR_u。"

#: ../../../src/evox/algorithms/de_variants/jade.py:62
msgid "Select p-best vectors from the population for mutation."
msgstr "从种群中选择 p-best 向量进行变异。"

#: ../../../src/evox/algorithms/de_variants/jade.py:64
msgid ""
"Fraction of the population to consider as top-p best. Must be between 0 and "
"1."
msgstr "考虑为 top-p 最佳的群体比例。必须在 0 和 1 之间。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
msgid "Returns"
msgstr "返回值"

#: ../../../src/evox/algorithms/de_variants/jade.py:65
msgid "A tensor containing selected p-best vectors."
msgstr "包含选定的 p-best 向量的张量。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:1
msgid "{py:mod}`evox.algorithms.de_variants.ode`"
msgstr "{py:mod}`evox.algorithms.de_variants.ode`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:18
msgid "{py:obj}`ODE <evox.algorithms.de_variants.ode.ODE>`"
msgstr "{py:obj}`ODE <evox.algorithms.de_variants.ode.ODE>`"

#: ../../../src/evox/algorithms/de_variants/ode.py:20
#: ../../../src/evox/algorithms/de_variants/ode.py:33
msgid ""
"Opposition-based Differential Evolution (ODE) algorithm for optimization."
msgstr "反对基差差分进化 (ODE) 算法用于优化。"

#: ../../../src/evox/algorithms/de_variants/ode.py:37
msgid ""
"`__init__`: Initializes the ODE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：使用给定的参数初始化 ODE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"`step`: Executes a single optimization step of the ODE algorithm, involving "
"mutation, crossover, selection, and opposition-based mechanisms."
msgstr "`step`: 执行ODE算法的单个优化步骤，包括变异、交叉、选择和基于对抗的机制。"

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"Initialize the Opposition-based Differential Evolution (ODE) algorithm with "
"the given parameters."
msgstr "使用给定的参数初始化基于对抗的差分进化（ODE）算法。"

#: ../../../src/evox/algorithms/de_variants/ode.py:42
#: ../../../src/evox/algorithms/pso_variants/clpso.py:42
#: ../../../src/evox/algorithms/pso_variants/cso.py:42
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:42
msgid "The lower bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/ode.py:43
#: ../../../src/evox/algorithms/pso_variants/clpso.py:43
#: ../../../src/evox/algorithms/pso_variants/cso.py:43
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:43
#: ../../../src/evox/algorithms/pso_variants/pso.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:43
msgid "The upper bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor of shape [num_difference_vectors]. Defaults to 0.5."
msgstr "应用于差异向量的差异权重 (F)。可以是一个浮点数或形状为 [num_difference_vectors] 的张量。默认值为 0.5。"

#: ../../../src/evox/algorithms/de_variants/ode.py:47
msgid "The crossover probability (CR). Must be in (0, 1]. Defaults to 0.9."
msgstr "交叉概率（CR）。必须在（0，1]之间。默认值为0.9。"

#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"The mean for initializing the population with a normal distribution. Must be"
" provided with stdev if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的均值。如果使用，则必须提供标准差（stdev）。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/ode.py:49
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Must be provided with mean if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的标准差。若使用，则必须提供均值。默认为 None。"

#: ../../../src/evox/algorithms/de_variants/ode.py:54
msgid "Execute a single optimization step of the ODE algorithm."
msgstr "执行 ODE 算法的单次优化步骤。"

#: ../../../src/evox/algorithms/de_variants/ode.py:60
msgid ""
"Opposition-Based Mechanism: Generate opposition-based population, evaluate "
"their fitness, and perform selection to potentially replace current "
"individuals with their opposites if they are better."
msgstr "对立机制：生成对立种群，评估它们的适应度，并进行选择，以便在它们更好的情况下，潜在地用它们的对立个体替换当前个体。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.sade`"
msgstr "{py:mod}`evox.algorithms.de_variants.sade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:18
msgid "{py:obj}`SaDE <evox.algorithms.de_variants.sade.SaDE>`"
msgstr "{py:obj}`SaDE <evox.algorithms.de_variants.sade.SaDE>`"

#: ../../../src/evox/algorithms/de_variants/sade.py:20
#: ../../../src/evox/algorithms/de_variants/sade.py:97
msgid "The implementation of SaDE algorithm."
msgstr "SaDE算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.sade.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.de_variants.sade.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.sade.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.de_variants.sade.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:38
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.sade.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.sade.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:42
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.sade.current2rand_1>`"
msgstr "**当前随机1 <evox.algorithms.de_variants.sade.current2rand_1>**"

#: ../../../src/evox/algorithms/de_variants/sade.py:99
msgid ""
"Reference: Qin A K, Huang V L, Suganthan P N. Differential evolution "
"algorithm with strategy adaptation for global numerical optimization[J]. "
"IEEE transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"参考：Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm with "
"strategy adaptation for global numerical optimization[J]. IEEE transactions "
"on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../../src/evox/algorithms/de_variants/sade.py:103
msgid "Initialize the SaDE algorithm with the given parameters."
msgstr "用给定的参数初始化SaDE算法。"

#: ../../../src/evox/algorithms/de_variants/sade.py:108
#: ../../../src/evox/algorithms/de_variants/shade.py:44
msgid "The number of differential padding vectors to use. Defaults to 9."
msgstr "差分填充向量的数量。默认值为 9。"

#: ../../../src/evox/algorithms/de_variants/sade.py:109
msgid "The size of memory. Defaults to 50."
msgstr "内存大小。默认为 50。"

#: ../../../src/evox/algorithms/de_variants/sade.py:126
msgid "Execute a single optimization step of the SaDE algorithm."
msgstr "执行 SaDE 算法的单次优化步骤。"

#: ../../../src/evox/algorithms/de_variants/sade.py:129
msgid "Generate new population using differential evolution."
msgstr "使用差分进化生成新种群。"

#: ../../../src/evox/algorithms/de_variants/sade.py:130
msgid "Evaluate the fitness of the new population."
msgstr "评估新种群的适应度。"

#: ../../../src/evox/algorithms/de_variants/sade.py:131
msgid "Update the best individual and best fitness."
msgstr "更新最佳个体和最佳适应度。"

#: ../../../src/evox/algorithms/de_variants/sade.py:132
msgid "Update the success and failure memory."
msgstr "更新成功和失败的记忆。"

#: ../../../src/evox/algorithms/de_variants/sade.py:133
msgid "Update the CR memory."
msgstr "更新 CR 内存。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.shade`"
msgstr "{py:mod}`evox.algorithms.de_variants.shade`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:18
msgid "{py:obj}`SHADE <evox.algorithms.de_variants.shade.SHADE>`"
msgstr "{py:obj}`SHADE <evox.algorithms.de_variants.shade.SHADE>`"

#: ../../../src/evox/algorithms/de_variants/shade.py:20
#: ../../../src/evox/algorithms/de_variants/shade.py:33
msgid "The implementation of SHADE algorithm."
msgstr "SHADE 算法的实现。"

#: ../../../src/evox/algorithms/de_variants/shade.py:35
msgid ""
"Reference: Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"参考文献: Tanabe R, Fukunaga A. Success-history based parameter adaptation for "
"differential evolution[C]//2013 IEEE congress on evolutionary computation. "
"IEEE, 2013: 71-78."

#: ../../../src/evox/algorithms/de_variants/shade.py:39
msgid "Initialize the SHADE algorithm with the given parameters."
msgstr "用给定的参数初始化SHADE算法。"

#: ../../../src/evox/algorithms/de_variants/shade.py:46
msgid "Perform a single step of the SHADE algorithm."
msgstr "执行 SHADE 算法的单步操作。"

#: ../../../src/evox/algorithms/de_variants/shade.py:49
msgid "Generate trial vectors using the SHADE algorithm."
msgstr "使用SHADE算法生成试验向量。"

#: ../../../src/evox/algorithms/de_variants/shade.py:50
msgid "Evaluate the fitness of the trial vectors."
msgstr "评估试验向量的适应度。"

#: ../../../src/evox/algorithms/de_variants/shade.py:51
msgid "Update the population."
msgstr "更新种群。"

#: ../../../src/evox/algorithms/de_variants/shade.py:52
msgid "Update the memory."
msgstr "更新记忆。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:1
msgid "{py:mod}`evox.algorithms.es_variants`"
msgstr "{py:mod}`evox.algorithms.es_variants`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:39
msgid "{py:obj}`__all__ <evox.algorithms.es_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.es_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:51
msgid ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."
msgstr ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:1
msgid "{py:mod}`evox.algorithms.es_variants.adam_step`"
msgstr "{py:mod}`evox.algorithms.es_variants.adam_step`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:12
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:22
#: ../../source/apidocs/evox/evox.core.module.md:30
#: ../../source/apidocs/evox/evox.metrics.gd.md:12
#: ../../source/apidocs/evox/evox.metrics.hv.md:12
#: ../../source/apidocs/evox/evox.metrics.igd.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:12
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:12
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:24
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:12
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:48
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:24
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:12
msgid "Functions"
msgstr "函数"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:18
msgid ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.es_variants.adam_step.adam_single_tensor>`"
msgstr ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.es_variants.adam_step.adam_single_tensor>`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:1
msgid "{py:mod}`evox.algorithms.es_variants.ars`"
msgstr "{py:mod}`evox.algorithms.es_variants.ars`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:18
msgid "{py:obj}`ARS <evox.algorithms.es_variants.ars.ARS>`"
msgstr "{py:obj}`ARS <evox.algorithms.es_variants.ars.ARS>`"

#: ../../../src/evox/algorithms/es_variants/ars.py:20
#: ../../../src/evox/algorithms/es_variants/ars.py:33
msgid "The implementation of the ARS algorithm."
msgstr "ARS算法的实现。"

#: ../../../src/evox/algorithms/es_variants/ars.py:35
msgid ""
"Reference: Simple random search provides a competitive approach to "
"reinforcement learning (https://arxiv.org/pdf/1803.07055.pdf)"
msgstr ""
"参考文献：Simple random search provides a competitive approach to reinforcement "
"learning (https://arxiv.org/pdf/1803.07055.pdf)"

#: ../../../src/evox/algorithms/es_variants/ars.py:38
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
#: ../../../src/evox/algorithms/es_variants/des.py:39
#: ../../../src/evox/algorithms/es_variants/esmc.py:39
#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
#: ../../../src/evox/algorithms/es_variants/snes.py:39
msgid ""
"This code has been inspired by or utilizes the algorithmic implementation "
"from evosax. More information about evosax can be found at the following "
"URL: GitHub Link: https://github.com/RobertTLange/evosax"
msgstr ""
"这段代码受到了 evosax 中算法实现的启发或使用了其实现。有关 evosax 的更多信息，请访问以下网址：GitHub "
"链接：https://github.com/RobertTLange/evosax"

#: ../../../src/evox/algorithms/es_variants/ars.py:39
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
msgid "Initialize the ARS algorithm with the given parameters."
msgstr "使用给定参数初始化ARS算法。"

#: ../../../src/evox/algorithms/es_variants/ars.py:42
#: ../../../src/evox/algorithms/es_variants/asebo.py:42
#: ../../../src/evox/algorithms/es_variants/des.py:42
#: ../../../src/evox/algorithms/es_variants/esmc.py:42
#: ../../../src/evox/algorithms/es_variants/guided_es.py:42
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:42
#: ../../../src/evox/algorithms/es_variants/open_es.py:42
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:42
#: ../../../src/evox/algorithms/es_variants/snes.py:42
msgid "The initial center of the population. Must be a 1D tensor."
msgstr "种群的初始中心。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/ars.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:43
msgid "The ratio of elite population. Defaults to 0.1."
msgstr "精英种群的比例。默认为 0.1。"

#: ../../../src/evox/algorithms/es_variants/ars.py:44
#: ../../../src/evox/algorithms/es_variants/asebo.py:44
#: ../../../src/evox/algorithms/es_variants/esmc.py:44
#: ../../../src/evox/algorithms/es_variants/guided_es.py:44
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:44
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:44
msgid "The learning rate for the optimizer. Defaults to 0.05."
msgstr "优化器的学习率。默认值为 0.05。"

#: ../../../src/evox/algorithms/es_variants/ars.py:45
#: ../../../src/evox/algorithms/es_variants/asebo.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:45
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:45
msgid "The standard deviation of the noise. Defaults to 0.03."
msgstr "噪声的标准差。默认为 0.03。"

#: ../../../src/evox/algorithms/es_variants/ars.py:46
#: ../../../src/evox/algorithms/es_variants/asebo.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:43
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:43
#: ../../../src/evox/algorithms/es_variants/open_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:43
#: ../../../src/evox/algorithms/es_variants/snes.py:43
msgid ""
"The optimizer to use. Defaults to None. Currently, only \"adam\" or None is "
"supported."
msgstr "使用的优化器（optimizer）。 默认情况下为 None。 仅 support \"adam\" 或 None。\n"

#: ../../../src/evox/algorithms/es_variants/ars.py:47
#: ../../../src/evox/algorithms/es_variants/asebo.py:51
#: ../../../src/evox/algorithms/es_variants/cma_es.py:45
#: ../../../src/evox/algorithms/es_variants/des.py:45
#: ../../../src/evox/algorithms/es_variants/esmc.py:48
#: ../../../src/evox/algorithms/es_variants/guided_es.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:53
#: ../../../src/evox/algorithms/es_variants/nes.py:75
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:50
#: ../../../src/evox/algorithms/es_variants/open_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:50
#: ../../../src/evox/algorithms/es_variants/snes.py:48
#: ../../../src/evox/algorithms/pso_variants/clpso.py:47
#: ../../../src/evox/algorithms/pso_variants/cso.py:47
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:53
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:50
#: ../../../src/evox/algorithms/pso_variants/pso.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:47
msgid "The device to use for the tensors. Defaults to None."
msgstr "设备的使用者（设备用于存放张量的硬件）。默认为 None。"

#: ../../../src/evox/algorithms/es_variants/ars.py:46
msgid "Perform a single step of the ARS algorithm."
msgstr "执行 ARS 算法的单步操作。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:1
msgid "{py:mod}`evox.algorithms.es_variants.asebo`"
msgstr "{py:mod}`evox.algorithms.es_variants.asebo`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:18
msgid "{py:obj}`ASEBO <evox.algorithms.es_variants.asebo.ASEBO>`"
msgstr "{py:obj}`ASEBO <evox.algorithms.es_variants.asebo.ASEBO>`"

#: ../../../src/evox/algorithms/es_variants/asebo.py:20
#: ../../../src/evox/algorithms/es_variants/asebo.py:33
msgid "The implementation of the ASEBO algorithm."
msgstr "ASEBO 算法的实现。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:35
msgid ""
"Reference: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"
msgstr ""
"参考文献: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"

#: ../../../src/evox/algorithms/es_variants/asebo.py:45
msgid "The decay factor for the learning rate. Defaults to 1.0."
msgstr "学习率的衰减因子。默认为 1.0。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
msgid "The minimum value for the learning rate. Defaults to 0.001."
msgstr "学习率的最小值。默认为 0.001。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
#: ../../../src/evox/algorithms/es_variants/esmc.py:45
#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:46
msgid "The decay factor for the standard deviation. Defaults to 1.0."
msgstr "标准差的衰减因子。默认为 1.0。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:49
#: ../../../src/evox/algorithms/es_variants/esmc.py:46
#: ../../../src/evox/algorithms/es_variants/guided_es.py:47
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:47
msgid "The minimum value for the standard deviation. Defaults to 0.01."
msgstr "标准差的最小值。默认值为 0.01。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:50
#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
msgid "The dimension of the subspace. Defaults to None."
msgstr "子空间的维度。默认为 None。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
msgid "The main step of the ASEBO algorithm."
msgstr "ASEBO 算法的主要步骤。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
msgid ""
"This function first computes the subspace spanned by the gradient of the "
"fitness function and then projects the gradient onto the subspace. It then "
"computes the step direction using the projected gradient and updates the "
"center and standard deviation of the search distribution."
msgstr ""
"此函数首先计算由适应度函数的梯度所张成的子空间，然后将梯度投影到该子空间。接着，它使用投影后的梯度计算步长方向，并更新搜索分布的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.cma_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.cma_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:18
msgid "{py:obj}`CMAES <evox.algorithms.es_variants.cma_es.CMAES>`"
msgstr "{py:obj}`CMAES <evox.algorithms.es_variants.cma_es.CMAES>`"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:20
#: ../../../src/evox/algorithms/es_variants/cma_es.py:33
msgid ""
"The CMA-ES algorithm as described in \"The CMA Evolution Strategy: A "
"Tutorial\" from https://arxiv.org/abs/1604.00772."
msgstr ""
"CMA-ES 算法，详见 \"The CMA Evolution Strategy: A Tutorial\" "
"(https://arxiv.org/abs/1604.00772)。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:39
msgid "Initialize the CMA-ES algorithm with the given parameters."
msgstr "使用给定的参数初始化 CMA-ES 算法。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:41
msgid "The size of the population with the notation \\lambda."
msgstr "种群的规模使用符号 \\lambda 表示。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:42
msgid "The initial mean of the population. Must be a 1D tensor."
msgstr "种群的初始均值。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:43
msgid "The overall standard deviation, i.e., the step size of the algorithm."
msgstr "整体标准差，即算法的步长。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:44
msgid ""
"The recombination weights of the population. Defaults to None and is "
"calculated automatically with recommended values."
msgstr "种群的重组权重。默认为 None，并根据推荐值自动计算。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:46
msgid "The main step of the CMA-ES algorithm."
msgstr "CMA-ES算法的主要步骤。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:48
msgid ""
"In this step, the algorithm generates a new population, evaluates it, and "
"updates the mean, covariance matrix, and step size correspondingly."
msgstr "在这一步，算法生成一个新种群，评估它，并相应地更新均值、协方差矩阵和步长。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:1
msgid "{py:mod}`evox.algorithms.es_variants.des`"
msgstr "{py:mod}`evox.algorithms.es_variants.des`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:18
msgid "{py:obj}`DES <evox.algorithms.es_variants.des.DES>`"
msgstr "{py:obj}`DES <evox.algorithms.es_variants.des.DES>`"

#: ../../../src/evox/algorithms/es_variants/des.py:20
#: ../../../src/evox/algorithms/es_variants/des.py:33
#: ../../../src/evox/algorithms/es_variants/esmc.py:20
#: ../../../src/evox/algorithms/es_variants/esmc.py:33
msgid "The implementation of the DES algorithm."
msgstr "DES算法的实现。"

#: ../../../src/evox/algorithms/es_variants/des.py:35
msgid ""
"Reference: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"
msgstr ""
"参考文献: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"

#: ../../../src/evox/algorithms/es_variants/des.py:39
msgid "Initialize the DES algorithm with the given parameters."
msgstr "用给定的参数初始化DES算法。"

#: ../../../src/evox/algorithms/es_variants/des.py:43
msgid "The temperature parameter for the softmax. Defaults to 12.5."
msgstr "软max的温度参数。默认为12.5。"

#: ../../../src/evox/algorithms/es_variants/des.py:44
msgid "The initial standard deviation of the noise. Defaults to 0.1."
msgstr "噪声的初始标准差。默认为 0.1。"

#: ../../../src/evox/algorithms/es_variants/des.py:46
msgid ""
"Step the DES algorithm by sampling the population, evaluating the fitness, "
"and updating the center."
msgstr "通过对种群进行采样、评估适应度和更新中心，逐步执行DES算法。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:1
msgid "{py:mod}`evox.algorithms.es_variants.esmc`"
msgstr "{py:mod}`evox.algorithms.es_variants.esmc`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:18
msgid "{py:obj}`ESMC <evox.algorithms.es_variants.esmc.ESMC>`"
msgstr "{py:obj}`ESMC <evox.algorithms.es_variants.esmc.ESMC>`"

#: ../../../src/evox/algorithms/es_variants/esmc.py:35
msgid ""
"Reference: Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"
msgstr ""
"参考文献：Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"

#: ../../../src/evox/algorithms/es_variants/esmc.py:39
msgid "Initialize the ESMC algorithm with the given parameters."
msgstr "用给定的参数初始化ESMC算法。"

#: ../../../src/evox/algorithms/es_variants/esmc.py:46
msgid "One iteration of the ESMC algorithm."
msgstr "ESMC算法的一次迭代。"

#: ../../../src/evox/algorithms/es_variants/esmc.py:48
msgid ""
"This function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "此函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.guided_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.guided_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:18
msgid "{py:obj}`GuidedES <evox.algorithms.es_variants.guided_es.GuidedES>`"
msgstr "{py:obj}`GuidedES <evox.algorithms.es_variants.guided_es.GuidedES>`"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:20
#: ../../../src/evox/algorithms/es_variants/guided_es.py:33
msgid "The implementation of the Guided-ES algorithm."
msgstr "Guided-ES 算法的实现。"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:35
msgid ""
"Reference: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"
msgstr ""
"参考文献: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
msgid "Initialize the Guided-ES algorithm with the given parameters."
msgstr "用给定的参数初始化 Guided-ES 算法。"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
msgid "Run one step of the Guided-ES algorithm."
msgstr "运行 Guided-ES 算法的一步。"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
#: ../../../src/evox/algorithms/es_variants/snes.py:48
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估他们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.nes`"
msgstr "{py:mod}`evox.algorithms.es_variants.nes`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:18
msgid "{py:obj}`XNES <evox.algorithms.es_variants.nes.XNES>`"
msgstr "{py:obj}`XNES <evox.algorithms.es_variants.nes.XNES>`"

#: ../../../src/evox/algorithms/es_variants/nes.py:20
#: ../../../src/evox/algorithms/es_variants/nes.py:37
msgid "The implementation of the xNES algorithm."
msgstr "xNES 算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:22
msgid "{py:obj}`SeparableNES <evox.algorithms.es_variants.nes.SeparableNES>`"
msgstr "{py:obj}`SeparableNES <evox.algorithms.es_variants.nes.SeparableNES>`"

#: ../../../src/evox/algorithms/es_variants/nes.py:24
#: ../../../src/evox/algorithms/es_variants/nes.py:61
msgid "The implementation of the Separable NES algorithm."
msgstr "可分 NES 算法的实现。"

#: ../../../src/evox/algorithms/es_variants/nes.py:39
msgid ""
"Reference: Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"
msgstr ""
"参考文献：Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"

#: ../../../src/evox/algorithms/es_variants/nes.py:43
msgid "Initialize the xNES algorithm with the given parameters."
msgstr "使用给定的参数初始化 xNES 算法。"

#: ../../../src/evox/algorithms/es_variants/nes.py:45
#: ../../../src/evox/algorithms/es_variants/nes.py:69
msgid "The initial mean vector of the population. Must be a 1D tensor."
msgstr "种群的初始均值向量。必须是一个一维张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:46
msgid "The initial covariance matrix of the population. Must be a 2D tensor."
msgstr "种群的初始协方差矩阵。必须是一个二维张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:47
#: ../../../src/evox/algorithms/es_variants/nes.py:71
msgid "The size of the population. Defaults to None."
msgstr "种群的大小。默认值为 None。"

#: ../../../src/evox/algorithms/es_variants/nes.py:48
#: ../../../src/evox/algorithms/es_variants/nes.py:72
msgid "The recombination weights of the population. Defaults to None."
msgstr "种群的重组权重。默认为 None。"

#: ../../../src/evox/algorithms/es_variants/nes.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:73
msgid "The learning rate for the mean vector. Defaults to None."
msgstr "均值向量的学习率。默认值为 None。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
#: ../../../src/evox/algorithms/es_variants/nes.py:74
msgid "The learning rate for the variance vector. Defaults to None."
msgstr "方差向量的学习率。默认为 None。"

#: ../../../src/evox/algorithms/es_variants/nes.py:51
msgid "The learning rate for the B matrix. Defaults to None."
msgstr "B 矩阵的学习率。默认值为 None。"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
msgid ""
"Whether to use the covariance matrix as a Cholesky factorization result. "
"Defaults to False."
msgstr "是否将协方差矩阵用作 Cholesky 分解的结果。默认为 False。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
msgid "Run one step of the xNES algorithm."
msgstr "运行 xNES 算法的一步。"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
#: ../../../src/evox/algorithms/es_variants/nes.py:76
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and covariance of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和协方差。"

#: ../../../src/evox/algorithms/es_variants/nes.py:63
#: ../../../src/evox/algorithms/es_variants/snes.py:35
msgid ""
"Reference: Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"
msgstr ""
"参考文献：Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"

#: ../../../src/evox/algorithms/es_variants/nes.py:67
msgid "Initialize the Separable NES algorithm with the given parameters."
msgstr "使用给定参数初始化 Separable NES 算法。"

#: ../../../src/evox/algorithms/es_variants/nes.py:70
msgid ""
"The initial standard deviation for each dimension. Must be a 1D tensor."
msgstr "每个维度的初始标准差。必须是一个 1D 张量。"

#: ../../../src/evox/algorithms/es_variants/nes.py:74
msgid "Run one step of the Separable NES algorithm."
msgstr "运行 Separable NES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.noise_reuse_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.noise_reuse_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:18
msgid ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.es_variants.noise_reuse_es.NoiseReuseES>`"
msgstr ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.es_variants.noise_reuse_es.NoiseReuseES>`"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:20
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:33
msgid "The implementation of the Noise-Reuse-ES algorithm."
msgstr "噪声重用ES算法的实现。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:35
msgid ""
"Reference: Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"
msgstr ""
"参考文献：Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:48
msgid "The inner problem length. Defaults to 100."
msgstr "内部问题长度。默认为 100。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:49
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:49
msgid "The number of inner problems. Defaults to 10."
msgstr "内部问题的数量。默认值为 10。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
msgid "Take a single step of the NoiseReuseES algorithm."
msgstr "执行 NoiseReuseES 算法的一步操作。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
msgid ""
"This function follows the algorithm described in the reference paper. It "
"first generates a set of perturbations for the current population. Then, it "
"evaluates the fitness of the population with the perturbations. Afterwards, "
"it calculates the gradient of the policy parameters using the perturbations "
"and the fitness. Finally, it updates the policy parameters using the "
"gradient and the learning rate."
msgstr ""
"此函数遵循参考论文中描述的算法。它首先为当前族群生成一组扰动。然后，它评估带有扰动的族群的适应度。之后，它使用扰动和适应度计算策略参数的梯度。最后，它使用梯度和学习率更新策略参数。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.open_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.open_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:18
msgid "{py:obj}`OpenES <evox.algorithms.es_variants.open_es.OpenES>`"
msgstr "{py:obj}`OpenES <evox.algorithms.es_variants.open_es.OpenES>`"

#: ../../../src/evox/algorithms/es_variants/open_es.py:20
#: ../../../src/evox/algorithms/es_variants/open_es.py:33
msgid ""
"The OpenES algorithm as described in \"Evolution Strategies as a Scalable "
"Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864."
msgstr ""
"OpenES算法，如文章“Evolution Strategies as a Scalable Alternative to Reinforcement"
" Learning”中所描述：https://arxiv.org/abs/1703.03864。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:39
msgid "Initialize the OpenES algorithm with the given parameters."
msgstr "用给定的参数初始化 OpenES 算法。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:43
msgid "The learning rate for the optimizer."
msgstr "优化器的学习率。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:44
msgid "The standard deviation of the noise."
msgstr "噪声的标准差。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
msgid "Whether to use mirrored sampling. Defaults to True."
msgstr "是否使用镜像采样。默认值为 True。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
msgid ""
"Step the OpenES algorithm by evaluating the fitness of the current "
"population and updating the center."
msgstr "通过评估当前种群的适应度并更新中心，执行 OpenES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.persistent_es`"
msgstr "{py:mod}`evox.algorithms.es_variants.persistent_es`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:18
msgid ""
"{py:obj}`PersistentES "
"<evox.algorithms.es_variants.persistent_es.PersistentES>`"
msgstr ""
"{py:obj}`PersistentES "
"<evox.algorithms.es_variants.persistent_es.PersistentES>`"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:20
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:33
msgid "The implementation of the Persistent ES algorithm."
msgstr "持续ES算法的实现。"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:35
msgid ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"
msgstr ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
msgid "Initialize the Persistent-ES algorithm with the given parameters."
msgstr "用给定的参数初始化 Persistent-ES 算法。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.snes`"
msgstr "{py:mod}`evox.algorithms.es_variants.snes`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:18
msgid "{py:obj}`SNES <evox.algorithms.es_variants.snes.SNES>`"
msgstr "{py:obj}`SNES <evox.algorithms.es_variants.snes.SNES>`"

#: ../../../src/evox/algorithms/es_variants/snes.py:20
#: ../../../src/evox/algorithms/es_variants/snes.py:33
msgid "The implementation of the SNES algorithm."
msgstr "SNES算法的实现。"

#: ../../../src/evox/algorithms/es_variants/snes.py:39
msgid "Initialize the SNES algorithm with the given parameters."
msgstr "用给定的参数初始化SNES算法。"

#: ../../../src/evox/algorithms/es_variants/snes.py:44
msgid "The learning rate for the mean. Defaults to 1.0."
msgstr "均值的学习率。默认值为 1.0。"

#: ../../../src/evox/algorithms/es_variants/snes.py:45
msgid "The standard deviation of the noise. Defaults to 1.0."
msgstr "噪声的标准差。默认为 1.0。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
msgid "The temperature of the softmax in computing weights. Defaults to 12.5."
msgstr "计算权重时 softmax 的温度。默认值为 12.5。"

#: ../../../src/evox/algorithms/es_variants/snes.py:47
msgid "The type of weights to use. Defaults to \"temp\"."
msgstr "权重的类型。默认为 \"temp\"。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
msgid "Run one step of the SNES algorithm."
msgstr "运行 SNES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:1
msgid "{py:mod}`evox.algorithms.es_variants.sort_utils`"
msgstr "{py:mod}`evox.algorithms.es_variants.sort_utils`"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:18
msgid ""
"{py:obj}`sort_by_key <evox.algorithms.es_variants.sort_utils.sort_by_key>`"
msgstr ""
"{py:obj}`sort_by_key <evox.algorithms.es_variants.sort_utils.sort_by_key>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:1
msgid "{py:mod}`evox.algorithms.mo`"
msgstr "{py:mod}`evox.algorithms.mo`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:29
msgid "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:41
msgid "['RVEA', 'NSGA2', 'MOEAD']"
msgstr "['RVEA', 'NSGA2', 'MOEAD']"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:1
msgid "{py:mod}`evox.algorithms.mo.moead`"
msgstr "{py:mod}`evox.algorithms.mo.moead`"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:18
msgid "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"
msgstr "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"

#: ../../../src/evox/algorithms/mo/moead.py:20
#: ../../../src/evox/algorithms/mo/moead.py:52
msgid "Implementation of the Original MOEA/D algorithm."
msgstr "原始 MOEA/D 算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:30
msgid "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"
msgstr "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"

#: ../../../src/evox/algorithms/mo/moead.py:54
#: ../../../src/evox/algorithms/mo/nsga2.py:38
#: ../../../src/evox/algorithms/mo/rvea.py:37
msgid "References"
msgstr "参考文献"

#: ../../../src/evox/algorithms/mo/moead.py:55
msgid ""
"\"MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition,\" "
"IEEE Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/4358754>`_"
msgstr ""
"\"MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition,\" "
"IEEE Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/4358754>`_"

#: ../../../src/evox/algorithms/mo/moead.py:59
#: ../../../src/evox/metrics/gd.py:39 ../../../src/evox/metrics/igd.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:113
#: ../../../src/evox/operators/selection/rvea_selection.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid "Note"
msgstr "注意"

#: ../../../src/evox/algorithms/mo/moead.py:59
msgid ""
"This implementation is based on the original paper and may not be the most "
"efficient implementation. It can not be traced by JIT."
msgstr "本实现基于原始论文，可能不是最有效的实现。它无法通过 JIT 进行跟踪。"

#: ../../../src/evox/algorithms/mo/moead.py:58
msgid "Initializes the MOEA/D algorithm."
msgstr "初始化 MOEA/D 算法。"

#: ../../../src/evox/algorithms/mo/moead.py:61
#: ../../../src/evox/algorithms/mo/nsga2.py:42
#: ../../../src/evox/algorithms/mo/rvea.py:42
msgid "The number of objective functions in the optimization problem."
msgstr "优化问题中的目标函数数量。"

#: ../../../src/evox/algorithms/mo/moead.py:62
#: ../../../src/evox/algorithms/mo/nsga2.py:43
msgid "The lower bounds for the decision variables (1D tensor)."
msgstr "决策变量的下界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/moead.py:63
#: ../../../src/evox/algorithms/mo/nsga2.py:44
msgid "The upper bounds for the decision variables (1D tensor)."
msgstr "决策变量的上界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/moead.py:64
#: ../../../src/evox/algorithms/mo/nsga2.py:45
#: ../../../src/evox/algorithms/mo/rvea.py:48
msgid "The selection operation for evolutionary strategy (optional)."
msgstr "进化策略的选择操作（可选）。"

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
msgid ""
"The mutation operation, defaults to polynomial_mutation if not provided "
"(optional)."
msgstr "基因突变操作，该选项的缺省值是 `polynomial_mutation`，如果未提供，则使用默认值 (可选)。"

#: ../../../src/evox/algorithms/mo/moead.py:66
msgid ""
"The crossover operation, defaults to simulated_binary_half if not provided "
"(optional)."
msgstr "交叉操作，如果未提供，则默认为 simulated_binary_half（可选）。"

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
msgid ""
"The device on which computations should run (optional). Defaults to "
"PyTorch's default device."
msgstr "计算应该运行的设备（可选）。默认为 PyTorch 的默认设备。"

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "Perform the initialization step of the workflow."
msgstr "执行工作流的初始化步骤。"

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
#: ../../../src/evox/algorithms/mo/rvea.py:48
#: ../../../src/evox/workflows/std_workflow.py:107
msgid ""
"Calls the `init_step` of the algorithm if overwritten; otherwise, its `step`"
" method will be invoked."
msgstr "调用算法的 `init_step` 如果被重写；否则，将调用其 `step` 方法。"

#: ../../../src/evox/algorithms/mo/moead.py:73
msgid "Perform a single optimization step of the workflow."
msgstr "执行工作流程的单个优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:1
msgid "{py:mod}`evox.algorithms.mo.nsga2`"
msgstr "{py:mod}`evox.algorithms.mo.nsga2`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:18
msgid "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"
msgstr "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"

#: ../../../src/evox/algorithms/mo/nsga2.py:20
#: ../../../src/evox/algorithms/mo/nsga2.py:33
msgid ""
"An implementation of the Non-dominated Sorting Genetic Algorithm II (NSGA-"
"II) for multi-objective optimization problems."
msgstr "非支配排序遗传算法 II (NSGA-II) 的实现，用于多目标优化问题。"

#: ../../../src/evox/algorithms/mo/nsga2.py:35
msgid ""
"This class provides a framework for solving multi-objective optimization "
"problems using a non-dominated sorting genetic algorithm, which is widely "
"used for Pareto-based optimization."
msgstr "此类提供了一个框架，用于通过非支配排序遗传算法解决多目标优化问题，该算法广泛用于基于帕累托的优化。"

#: ../../../src/evox/algorithms/mo/nsga2.py:39
msgid ""
"\"A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II,\" IEEE "
"Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/996017>`_"
msgstr ""
"\"A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II,\" IEEE "
"Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/996017>`_"

#: ../../../src/evox/algorithms/mo/nsga2.py:39
msgid "Initializes the NSGA-II algorithm."
msgstr "初始化 NSGA-II 算法。"

#: ../../../src/evox/algorithms/mo/nsga2.py:47
msgid ""
"The crossover operation, defaults to simulated_binary if not provided "
"(optional)."
msgstr "交叉操作，如果未提供（可选），默认为 simulated_binary。"

#: ../../../src/evox/algorithms/mo/nsga2.py:54
msgid "Perform the optimization step of the workflow."
msgstr "执行工作流的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:1
msgid "{py:mod}`evox.algorithms.mo.rvea`"
msgstr "{py:mod}`evox.algorithms.mo.rvea`"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:18
msgid "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"
msgstr "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"

#: ../../../src/evox/algorithms/mo/rvea.py:20
#: ../../../src/evox/algorithms/mo/rvea.py:33
msgid ""
"An implementation of the Reference Vector Guided Evolutionary Algorithm "
"(RVEA) for multi-objective optimization problems."
msgstr ""
"Reference Vector Guided Evolutionary Algorithm (RVEA) "
"多目标优化问题的参考向量引导进化算法(RVEA) 的实现"

#: ../../../src/evox/algorithms/mo/rvea.py:35
msgid ""
"This class is designed to solve multi-objective optimization problems using "
"a reference vector guided evolutionary algorithm."
msgstr "这类是设计用来使用参考向量引导的进化算法来解决多目标优化问题的。"

#: ../../../src/evox/algorithms/mo/rvea.py:38
msgid ""
"\"A Reference Vector Guided Evolutionary Algorithm for Many-Objective "
"Optimization,\" IEEE. `Link <https://ieeexplore.ieee.org/document/7386636>`"
msgstr ""
"面向多目标优化的参考向量引导的演化算法, IEEE. `Link "
"<https://ieeexplore.ieee.org/document/7386636>`"

#: ../../../src/evox/algorithms/mo/rvea.py:40
msgid ""
"\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
"RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"
msgstr ""
"\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
"RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"

#: ../../../src/evox/algorithms/mo/rvea.py:39
msgid "Initialize the RVEA algorithm with the given parameters."
msgstr "使用给定参数初始化RVEA算法。"

#: ../../../src/evox/algorithms/mo/rvea.py:43
#: ../../../src/evox/operators/mutation/pm_mutation.py:34
msgid "The lower bounds for the decision variables."
msgstr "**决策变量的下限值**"

#: ../../../src/evox/algorithms/mo/rvea.py:44
#: ../../../src/evox/operators/mutation/pm_mutation.py:35
msgid "The upper bounds for the decision variables."
msgstr "决策变量的上限界值。"

#: ../../../src/evox/algorithms/mo/rvea.py:45
msgid ""
"A parameter for controlling the rate of change of penalty. Defaults to 2."
msgstr "一个参数，用于控制惩罚的变化速率。默认值为 2。"

#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "The frequency of reference vector adaptation. Defaults to 0.1."
msgstr "引用向量适应的频率。默认为 0.1。"

#: ../../../src/evox/algorithms/mo/rvea.py:47
msgid "The maximum number of generations. Defaults to 100."
msgstr "最大世代数。默认为 100。"

#: ../../../src/evox/algorithms/mo/rvea.py:49
msgid "The mutation operation (optional)."
msgstr "变异操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:50
msgid "The crossover operation (optional)."
msgstr "交叉操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:51
msgid "The device on which computations should run (optional)."
msgstr "运行计算的设备（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:102
msgid "Perform a single optimization step."
msgstr "执行单次优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:1
msgid "{py:mod}`evox.algorithms.pso_variants`"
msgstr "{py:mod}`evox.algorithms.pso_variants`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:34
msgid "{py:obj}`__all__ <evox.algorithms.pso_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.pso_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:46
msgid "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"
msgstr "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.clpso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.clpso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:18
msgid "{py:obj}`CLPSO <evox.algorithms.pso_variants.clpso.CLPSO>`"
msgstr "{py:obj}`CLPSO <evox.algorithms.pso_variants.clpso.CLPSO>`"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:20
#: ../../../src/evox/algorithms/pso_variants/clpso.py:33
#: ../../../src/evox/algorithms/pso_variants/cso.py:20
#: ../../../src/evox/algorithms/pso_variants/cso.py:33
msgid "The basic CSO algorithm."
msgstr "基本的CSO算法。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:37
msgid ""
"`__init__`: Initializes the CLPSO algorithm with given static parameters "
"including lower and upper bounds for particle positions."
msgstr "`__init__`: 初始化 CLPSO 算法，使用给定的静态参数，包括粒子位置的下限和上限。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:38
msgid ""
"`setup`: Initializes the CLPSO algorithm and sets up initial population, "
"velocity, and buffers for tracking best local and global positions and "
"fitness values."
msgstr "`setup`: 初始化 CLPSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid ""
"`step`: Performs a single optimization step using CLPSO, updating local best"
" positions and fitness values, and adjusting velocity and positions based on"
" inertia, cognitive, and social components."
msgstr ""
"**单步优化** (`step`): \n"
"使用CLPSO执行单步优化，更新个人最佳位置和适应值，根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:40
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class, it is a proxy "
"function of `Problem.evaluate` set by workflow; therefore, it cannot be used"
" in class methods other than `step`."
msgstr ""
"请注意，`evaluate`方法在此类中未定义，它是由工作流设置的`Problem.evaluate`的代理函数；因此，它无法在除`step`之外的类方法中使用。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid "Initialize the CLPSO algorithm with the given static parameters."
msgstr "用给定的静态参数初始化 CLPSO 算法。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:44
msgid "The inertia weight (w). Defaults to 0.5."
msgstr "惯性权重 (w)。默认值为 0.5。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:45
msgid "The cognitive weight (c). Defaults to 1.5."
msgstr "认知权重（c）。默认为1.5。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "The social weight (P_c). Defaults to 0.05."
msgstr "社会权重 (P_c)。默认为 0.05。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "Perform a single optimization step using CLPSO."
msgstr "使用 CLPSO 执行单次优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:48
#: ../../../src/evox/algorithms/pso_variants/pso.py:48
msgid ""
"This function evaluates the fitness of the current population, updates the "
"local best positions and fitness values, and adjusts the velocity and "
"positions of particles based on inertia, cognitive, and social components. "
"It ensures that the updated positions and velocities are clamped within the "
"specified bounds."
msgstr ""
"该函数用于评估当前种群的适应度，更新局部最优位置和适应度值并根据惯性、认知和社会组件调整粒子的速度和位置该函数确保在更新位置和速度后，粒子的位置和速度都在指定的范围内。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:54
#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid ""
"The local best positions and fitness values are updated if the current "
"fitness is better than the recorded local best. The global best position and"
" fitness are determined using helper functions."
msgstr "如果当前的适应度比记录的局部最佳更好，则更新局部最佳位置和适应度值。全局最佳位置和适应度通过辅助函数确定。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:58
#: ../../../src/evox/algorithms/pso_variants/pso.py:58
msgid ""
"The velocity is updated based on the weighted sum of the previous velocity, "
"the cognitive component (personal best), and the social component (global "
"best). The population positions are then updated using the new velocities."
msgstr "速度是基于以前速度的加权总和、认知成分（个人最好）和社会成分（全局最好）进行更新的。然后，使用新的速度更新种群位置。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.cso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.cso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:18
msgid "{py:obj}`CSO <evox.algorithms.pso_variants.cso.CSO>`"
msgstr "{py:obj}`CSO <evox.algorithms.pso_variants.cso.CSO>`"

#: ../../../src/evox/algorithms/pso_variants/cso.py:37
msgid "`__init__`: Initializes the CSO algorithm with given parameters."
msgstr "`__init__`: 使用给定参数初始化 CSO 算法。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:38
msgid ""
"`setup`: Initializes the CSO algorithm with given lower and upper bounds for"
" particle positions, and sets up initial population, velocity, and buffers "
"for tracking best local and global positions and fitness values."
msgstr "`setup`: 使用给定的粒子位置下限和上限初始化 CSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
msgid ""
"`step`: Performs a single optimization step using CSO, updating local best "
"positions and fitness values, and adjusting velocity and positions based on "
"inertia, cognitive, and social components."
msgstr "`step`：使用 CSO 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
msgid "Initialize the CSO algorithm with the given parameters."
msgstr "使用给定的参数初始化CSO算法。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:44
msgid "The inertia weight. Defaults to 0.0."
msgstr "惯性权重。默认值为 0.0。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:45
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:47
msgid "The mean of the normal distribution. Defaults to None."
msgstr "正态分布的均值。默认为 None。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:48
msgid "The standard deviation of the normal distribution. Defaults to None."
msgstr "正态分布的标准差。默认为 None。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
msgid "Perform a single optimization step using CSO."
msgstr "使用 CSO 进行单次优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:48
msgid ""
"This function updates the position and velocity of each particle in the "
"population using the CSO algorithm. The CSO algorithm is an optimization "
"algorithm that uses a combination of both the PSO and the DE algorithms to "
"search for the optimal solution."
msgstr "该函数使用CSO算法更新种群中每个粒子的位置和速度。CSO算法是一种优化算法，它结合了PSO和DE算法来搜索最佳解决方案。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.dms_pso_el`"
msgstr "{py:mod}`evox.algorithms.pso_variants.dms_pso_el`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:18
msgid "{py:obj}`DMSPSOEL <evox.algorithms.pso_variants.dms_pso_el.DMSPSOEL>`"
msgstr "{py:obj}`DMSPSOEL <evox.algorithms.pso_variants.dms_pso_el.DMSPSOEL>`"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:20
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:33
msgid "The DMSPSOEL algorithm."
msgstr "DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:37
msgid "`__init__`: Initializes the DMSPSOEL algorithm with given parameters."
msgstr "`__init__`: 通过给定的参数来初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:38
msgid ""
"`setup`: Initializes the DMSPSOEL algorithm with given lower and upper "
"bounds for particle positions, and sets up initial population, velocity, and"
" buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`: 初始化 DMSPSOEL 算法，设置粒子位置的下限和上限，并配置初始种群、速度，以及用于跟踪最佳局部和全局位置与适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid ""
"`step`: Performs a single optimization step using DMSPSOEL, updating local "
"best positions and fitness values, and adjusting velocity and positions "
"based on inertia, cognitive, and social components."
msgstr "`step`: 使用 DMSPSOEL 执行单次优化步骤，更新本地最佳位置和适应度值，并根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid "Initialize the DMSPSOEL algorithm with the given parameters."
msgstr "使用给定参数初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:43
msgid "The size of the dynamic sub-swarm. Defaults to 10."
msgstr "动态子种群的大小。默认值：10。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:44
msgid "The number of dynamic sub-swarms. Defaults to 5."
msgstr "动态子种群的数量。默认为5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:45
msgid "The size of the following sub-swarm. Defaults to 10."
msgstr "以下子群体的大小。默认为10。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
msgid "The number of iterations for regrouping. Defaults to 50."
msgstr "重组的迭代次数。默认为50。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:47
msgid "The maximum number of iterations. Defaults to 100."
msgstr "最大迭代次数。默认为 100。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid "The inertia weight. Defaults to 0.7."
msgstr "惯性权重。默认值为0.7。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:49
msgid "The cognitive weight. Defaults to 1.5."
msgstr "认知权重。默认为 1.5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:50
msgid "The social weight. Defaults to 1.5."
msgstr "社会权重。默认为 1.5。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:51
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:52
msgid "The social weight. Defaults to 1.0."
msgstr "社交权重。默认为 1.0。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
msgid "Perform a single step of the DMSPSOEL algorithm."
msgstr "执行 DMSPSOEL 算法的单步操作。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid ""
"This function updates the population, velocity, personal best location, and "
"personal best fitness based on the current fitness values. It also updates "
"the local and global best positions and fitness values based on the dynamic "
"sub-swarm and following sub-swarm. Finally, it updates the iteration count."
msgstr ""
"此函数根据当前的适应度值更新种群、速度、个人最佳位置和个人最佳适应度。它还根据动态子群和跟随子群更新局部和全局最佳位置及适应度值。最后，它更新迭代计数。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.fs_pso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.fs_pso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:18
msgid "{py:obj}`FSPSO <evox.algorithms.pso_variants.fs_pso.FSPSO>`"
msgstr "{py:obj}`FSPSO <evox.algorithms.pso_variants.fs_pso.FSPSO>`"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:20
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:33
msgid "The Feature Selection PSO algorithm."
msgstr "特征选择 PSO 算法"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:39
msgid "Initialize the FSPSO algorithm with the given parameters."
msgstr "使用给定参数初始化FSPSO算法。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:44
#: ../../../src/evox/algorithms/pso_variants/pso.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:44
msgid "The inertia weight. Defaults to 0.6."
msgstr "惯性权重。默认值为0.6。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:45
#: ../../../src/evox/algorithms/pso_variants/pso.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:45
msgid "The cognitive weight. Defaults to 2.5."
msgstr "认知权重。默认为 2.5。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
#: ../../../src/evox/algorithms/pso_variants/pso.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "The social weight. Defaults to 0.8."
msgstr "社会权重。默认值为 0.8。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:49
msgid "The mutation rate. Defaults to 0.01."
msgstr "变异率。默认为 0.01。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
msgid "Perform a normal optimization step using FSPSO."
msgstr "使用 FSPSO 执行常规优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.pso`"
msgstr "{py:mod}`evox.algorithms.pso_variants.pso`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:18
msgid "{py:obj}`PSO <evox.algorithms.pso_variants.pso.PSO>`"
msgstr "{py:obj}`PSO <evox.algorithms.pso_variants.pso.PSO>`"

#: ../../../src/evox/algorithms/pso_variants/pso.py:20
#: ../../../src/evox/algorithms/pso_variants/pso.py:33
msgid "The basic Particle Swarm Optimization (PSO) algorithm."
msgstr "基本粒子群优化算法 (PSO)"

#: ../../../src/evox/algorithms/pso_variants/pso.py:37
msgid ""
"`__init__`: Initializes the PSO algorithm with given parameters (population "
"size, lower and upper bounds, inertia weight, cognitive weight, and social "
"weight)."
msgstr ""
"**__init__**\n"
"初始化 PSO 算法（Particle Swarm Optimization）与给定的参数（人口大小、下限和上限、惯性权重、认知权重和社会权重）。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:38
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (PSO), updating local best positions and fitness values, and "
"adjusting velocity and positions based on inertia, cognitive, and social "
"components."
msgstr "`step`: 执行单次粒子群优化（PSO）步骤，更新局部最佳位置和适应度值，并基于惯性、认知和社会组件调整速度和位置。\n"

#: ../../../src/evox/algorithms/pso_variants/pso.py:39
msgid "Initialize the PSO algorithm with the given parameters."
msgstr "使用给定参数初始化PSO算法。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:46
msgid "Perform a normal optimization step using PSO."
msgstr "使用PSO执行常规优化步骤。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid "Perform the first step of the PSO optimization."
msgstr "执行 PSO 优化的第一步。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:56
msgid "See `step` for more details."
msgstr "请查看 `step` 以获取更多详细信息。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_gs`"
msgstr "{py:mod}`evox.algorithms.pso_variants.sl_pso_gs`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:18
msgid "{py:obj}`SLPSOGS <evox.algorithms.pso_variants.sl_pso_gs.SLPSOGS>`"
msgstr "{py:obj}`SLPSOGS <evox.algorithms.pso_variants.sl_pso_gs.SLPSOGS>`"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Gaussian "
"Sampling for Demonstrator Choice (SLPSOGS) algorithm."
msgstr "基本的粒子群优化社交学习 PSO 使用高斯采样进行示范选择 (SLPSOGS) 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:37
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:37
msgid ""
"`__init__`: Initializes the SLPSOGS algorithm with given parameters "
"(population size, inertia weight, cognitive weight, and social weight)."
msgstr "`__init__`: 使用给定的参数（种群大小、惯性权重、认知权重和社会权重）初始化SLPSOGS算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:38
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:38
msgid ""
"`setup`: Initializes the SLPSOGS algorithm with given lower and upper bounds"
" for particle positions, and sets up initial population, velocity, and "
"buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`：初始化 SLPSOGS 算法，设置粒子位置的下界和上界，并建立初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (SLPSOGS), updating local best positions and fitness values, "
"and adjusting velocity and positions based on inertia, cognitive, and social"
" components."
msgstr ""
"`step`: 使用粒子群优化 (SLPSOGS) 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交成分调整速度和位置。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
msgid "Initialize the SLPSOGS algorithm with the given parameters."
msgstr "使用给定参数初始化 SLPSOGS 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
msgid "Perform a normal optimization step using SLPSOGS."
msgstr "使用 SLPSOGS 执行一个正常的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_us`"
msgstr "{py:mod}`evox.algorithms.pso_variants.sl_pso_us`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:18
msgid "{py:obj}`SLPSOUS <evox.algorithms.pso_variants.sl_pso_us.SLPSOUS>`"
msgstr "{py:obj}`SLPSOUS <evox.algorithms.pso_variants.sl_pso_us.SLPSOUS>`"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Uniform "
"Sampling for Demonstrator Choice (SLPSOUS) algorithm."
msgstr "基本的粒子群优化社会学习 PSO 使用均匀采样进行演示选择 (SLPSOUS) 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid "Initialize the SLPSOUS algorithm with the given parameters."
msgstr "用给定的参数初始化 SLPSOUS 算法。"

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "Perform a normal optimization step using SLPSOUS."
msgstr "执行一个使用 SLPSOUS 的正常优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.utils`"
msgstr "{py:mod}`evox.algorithms.pso_variants.utils`"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:18
msgid "{py:obj}`min_by <evox.algorithms.pso_variants.utils.min_by>`"
msgstr "{py:obj}`min_by <evox.algorithms.pso_variants.utils.min_by>`"

#: ../../../src/evox/algorithms/pso_variants/utils.py:20
#: ../../../src/evox/algorithms/pso_variants/utils.py:34
msgid "Find the value with the minimum key."
msgstr "找到具有最小键的值。"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:22
msgid ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.pso_variants.utils.random_select_from_mask>`"
msgstr ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.pso_variants.utils.random_select_from_mask>`"

#: ../../../src/evox/algorithms/pso_variants/utils.py:24
#: ../../../src/evox/algorithms/pso_variants/utils.py:41
msgid "Randomly select `s` elements from a 1D mask using uniform noise."
msgstr "随机从 1D 掩码中使用均匀噪声随机选择 `s` 个元素。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:36
msgid "A tensor or list of tensors."
msgstr "一个张量或一个列表的张量"

#: ../../../src/evox/algorithms/pso_variants/utils.py:37
msgid "A tensor or list of tensors corresponding to the values."
msgstr "一个张量或与值对应的张量列表。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:39
msgid "The value with the minimum key and the corresponding key."
msgstr "具有最小键的值及其对应的键。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:43
msgid "A tensor used as the random seed."
msgstr "用于随机种子的张量。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:44
msgid "A tensor of shape (N,) containing {0, 1}."
msgstr "一个形状为 (N,) 的张量，包含 {0, 1}。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:45
msgid "The number of elements to select."
msgstr "要选择的元素数量。"

#: ../../../src/evox/algorithms/pso_variants/utils.py:47
msgid "A new mask tensor with exactly s elements set to 1."
msgstr "一个新的掩码张量，其中恰好有 s 个元素设置为 1。"

#: ../../source/apidocs/evox/evox.core.md:1
msgid "{py:mod}`evox.core`"
msgstr "{py:mod}`evox.core`"

#: ../../source/apidocs/evox/evox.core.md:30
msgid "{py:obj}`__all__ <evox.core.__all__>`"
msgstr "{py:obj}`__all__ <evox.core.__all__>`"

#: ../../source/apidocs/evox/evox.core.md:42
msgid ""
"['_vmap_fix', 'debug_print', 'Parameter', 'Mutable', 'ModuleBase', "
"'use_state', 'trace_impl', 'vmap_..."
msgstr ""
"['_vmap_fix', 'debug_print', 'Parameter', 'Mutable', 'ModuleBase', "
"'use_state', 'trace_impl', 'vmap_..."

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:1
msgid "{py:mod}`evox.core._vmap_fix`"
msgstr "{py:mod}`evox.core._vmap_fix`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:18
msgid "{py:obj}`_set_func_id <evox.core._vmap_fix._set_func_id>`"
msgstr "{py:obj}`_set_func_id <evox.core._vmap_fix._set_func_id>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:22
msgid ""
"{py:obj}`unwrap_batch_tensor <evox.core._vmap_fix.unwrap_batch_tensor>`"
msgstr ""
"{py:obj}`unwrap_batch_tensor <evox.core._vmap_fix.unwrap_batch_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:24
#: ../../../src/evox/core/_vmap_fix.py:181
msgid ""
"Unwraps a batched tensor into its original tensor and the batch "
"dimensions/sizes."
msgstr "将批量张量展开为其原始张量及批量维度/大小。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:26
msgid "{py:obj}`wrap_batch_tensor <evox.core._vmap_fix.wrap_batch_tensor>`"
msgstr "{py:obj}`wrap_batch_tensor <evox.core._vmap_fix.wrap_batch_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:28
#: ../../../src/evox/core/_vmap_fix.py:188
msgid ""
"Wraps a original tensor into its batched form with given batch dimensions."
msgstr "将原始张量封装到其批量形式中，给定批量维度。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:30
msgid "{py:obj}`_get_batched_size <evox.core._vmap_fix._get_batched_size>`"
msgstr "{py:obj}`_get_batched_size <evox.core._vmap_fix._get_batched_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:34
msgid ""
"{py:obj}`get_vmap_batch_sizes <evox.core._vmap_fix.get_vmap_batch_sizes>`"
msgstr ""
"{py:obj}`get_vmap_batch_sizes <evox.core._vmap_fix.get_vmap_batch_sizes>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:38
msgid ""
"{py:obj}`vmap_increment_nesting "
"<evox.core._vmap_fix.vmap_increment_nesting>`"
msgstr ""
"{py:obj}`vmap_increment_nesting "
"<evox.core._vmap_fix.vmap_increment_nesting>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:42
msgid "{py:obj}`_flat_vmap <evox.core._vmap_fix._flat_vmap>`"
msgstr "{py:obj}`_flat_vmap <evox.core._vmap_fix._flat_vmap>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:46
msgid "{py:obj}`batched_random <evox.core._vmap_fix.batched_random>`"
msgstr "{py:obj}`batched_random <evox.core._vmap_fix.batched_random>`"

#: ../../../src/evox/core/_vmap_fix.py:48
#: ../../../src/evox/core/_vmap_fix.py:234
msgid "Generate a batched tensor of random values."
msgstr "生成一个包含随机值的批量张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:50
msgid ""
"{py:obj}`batched_random_like <evox.core._vmap_fix.batched_random_like>`"
msgstr ""
"{py:obj}`batched_random_like <evox.core._vmap_fix.batched_random_like>`"

#: ../../../src/evox/core/_vmap_fix.py:52
#: ../../../src/evox/core/_vmap_fix.py:241
msgid ""
"Generate a batched tensor of random values with the same shape as the given "
"tensor."
msgstr "生成一个与给定张量形状相同的随机值批处理张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:54
msgid "{py:obj}`_batch_size <evox.core._vmap_fix._batch_size>`"
msgstr "{py:obj}`_batch_size <evox.core._vmap_fix._batch_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:58
msgid "{py:obj}`_batch_rand <evox.core._vmap_fix._batch_rand>`"
msgstr "{py:obj}`_batch_rand <evox.core._vmap_fix._batch_rand>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:62
msgid "{py:obj}`_batch_randn <evox.core._vmap_fix._batch_randn>`"
msgstr "{py:obj}`_batch_randn <evox.core._vmap_fix._batch_randn>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:66
msgid "{py:obj}`_batch_randint <evox.core._vmap_fix._batch_randint>`"
msgstr "{py:obj}`_batch_randint <evox.core._vmap_fix._batch_randint>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:70
msgid "{py:obj}`_batch_randperm <evox.core._vmap_fix._batch_randperm>`"
msgstr "{py:obj}`_batch_randperm <evox.core._vmap_fix._batch_randperm>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:74
msgid "{py:obj}`_batch_rand_like <evox.core._vmap_fix._batch_rand_like>`"
msgstr "{py:obj}`_batch_rand_like <evox.core._vmap_fix._batch_rand_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:78
msgid "{py:obj}`_batch_randn_like <evox.core._vmap_fix._batch_randn_like>`"
msgstr "{py:obj}`_batch_randn_like <evox.core._vmap_fix._batch_randn_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:82
msgid ""
"{py:obj}`_batch_randint_like <evox.core._vmap_fix._batch_randint_like>`"
msgstr ""
"{py:obj}`_batch_randint_like <evox.core._vmap_fix._batch_randint_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:86
msgid "{py:obj}`_batch_getitem <evox.core._vmap_fix._batch_getitem>`"
msgstr "{py:obj}`_batch_getitem <evox.core._vmap_fix._batch_getitem>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:90
msgid "{py:obj}`_batch_setitem <evox.core._vmap_fix._batch_setitem>`"
msgstr "{py:obj}`_batch_setitem <evox.core._vmap_fix._batch_setitem>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:94
msgid "{py:obj}`use_batch_fixing <evox.core._vmap_fix.use_batch_fixing>`"
msgstr "{py:obj}`use_batch_fixing <evox.core._vmap_fix.use_batch_fixing>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:98
msgid "{py:obj}`align_vmap_tensor <evox.core._vmap_fix.align_vmap_tensor>`"
msgstr "{py:obj}`align_vmap_tensor <evox.core._vmap_fix.align_vmap_tensor>`"

#: ../../../src/evox/core/_vmap_fix.py:100
#: ../../../src/evox/core/_vmap_fix.py:436
msgid ""
"Aligns a tensor with the batching dimensions of a current batched tensor."
msgstr "将张量与当前批处理张量的批处理维度对齐。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:102
msgid "{py:obj}`_debug_print <evox.core._vmap_fix._debug_print>`"
msgstr "{py:obj}`_debug_print <evox.core._vmap_fix._debug_print>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:106
msgid "{py:obj}`debug_print <evox.core._vmap_fix.debug_print>`"
msgstr "{py:obj}`debug_print <evox.core._vmap_fix.debug_print>`"

#: ../../../src/evox/core/_vmap_fix.py:108
#: ../../../src/evox/core/_vmap_fix.py:450
msgid ""
"Prints a formatted string with one positional tensor used for debugging "
"inside JIT traced functions on-the-fly."
msgstr "打印一个格式化字符串，包含一个用于调试的定位张量，在 JIT 跟踪的函数中实时使用。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:118
msgid "{py:obj}`_vmap_batch_sizes <evox.core._vmap_fix._vmap_batch_sizes>`"
msgstr "{py:obj}`_vmap_batch_sizes <evox.core._vmap_fix._vmap_batch_sizes>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:122
msgid "{py:obj}`_original_size <evox.core._vmap_fix._original_size>`"
msgstr "{py:obj}`_original_size <evox.core._vmap_fix._original_size>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:126
msgid "{py:obj}`_original_rand <evox.core._vmap_fix._original_rand>`"
msgstr "{py:obj}`_original_rand <evox.core._vmap_fix._original_rand>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:130
msgid "{py:obj}`_original_randn <evox.core._vmap_fix._original_randn>`"
msgstr "{py:obj}`_original_randn <evox.core._vmap_fix._original_randn>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:134
msgid "{py:obj}`_original_randint <evox.core._vmap_fix._original_randint>`"
msgstr "{py:obj}`_original_randint <evox.core._vmap_fix._original_randint>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:138
msgid "{py:obj}`_original_randperm <evox.core._vmap_fix._original_randperm>`"
msgstr "{py:obj}`_original_randperm <evox.core._vmap_fix._original_randperm>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:142
msgid ""
"{py:obj}`_original_rand_like <evox.core._vmap_fix._original_rand_like>`"
msgstr ""
"{py:obj}`_original_rand_like <evox.core._vmap_fix._original_rand_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:146
msgid ""
"{py:obj}`_original_randn_like <evox.core._vmap_fix._original_randn_like>`"
msgstr ""
"{py:obj}`_original_randn_like <evox.core._vmap_fix._original_randn_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:150
msgid ""
"{py:obj}`_original_randint_like "
"<evox.core._vmap_fix._original_randint_like>`"
msgstr ""
"{py:obj}`_original_randint_like "
"<evox.core._vmap_fix._original_randint_like>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:154
msgid "{py:obj}`_original_get_item <evox.core._vmap_fix._original_get_item>`"
msgstr "{py:obj}`_original_get_item <evox.core._vmap_fix._original_get_item>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:158
msgid "{py:obj}`_original_set_item <evox.core._vmap_fix._original_set_item>`"
msgstr "{py:obj}`_original_set_item <evox.core._vmap_fix._original_set_item>`"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:162
msgid "{py:obj}`_batch_fixing <evox.core._vmap_fix._batch_fixing>`"
msgstr "{py:obj}`_batch_fixing <evox.core._vmap_fix._batch_fixing>`"

#: ../../../src/evox/core/_vmap_fix.py:183
msgid "The batched tensor to be unwrapped."
msgstr "要解包的批处理张量。"

#: ../../../src/evox/core/_vmap_fix.py:185
msgid ""
"A tuple of the original tensor, the batch dimensions, and the batch sizes."
msgstr "原始张量、批次维度和批次大小的元组。"

#: ../../../src/evox/core/_vmap_fix.py:190
msgid "The original tensor to be wrapped."
msgstr "要包装的原始张量。"

#: ../../../src/evox/core/_vmap_fix.py:191
msgid "The batch dimension(s)."
msgstr "批量维度(s)。"

#: ../../../src/evox/core/_vmap_fix.py:193
msgid "The batched tensor."
msgstr "批量张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:203
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:419
#: ../../source/apidocs/evox/evox.core.module.md:361
#: ../../source/apidocs/evox/evox.core.module.md:372
msgid "'ContextVar(...)'"
msgstr "'ContextVar(...)'"

#: ../../../src/evox/core/_vmap_fix.py:236
msgid ""
"Given a random function (e.g. "
"[`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html),"
" [`torch.rand`](https://pytorch.org/docs/stable/generated/torch.rand.html), "
"etc.) and its size arguments, this function generates a batched tensor of "
"random values by applying the given function to the size extended with the "
"current vmap batch size."
msgstr ""
"给定一个随机函数（例如 "
"[`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html)、[`torch.rand`](https://pytorch.org/docs/stable/generated/torch.rand.html)"
" 等）及其大小参数，该函数通过将给定函数应用于扩展当前 vmap 批大小的大小，生成一个随机值的批量张量。"

#: ../../../src/evox/core/_vmap_fix.py:241
#: ../../../src/evox/core/_vmap_fix.py:248
msgid "A function that generates a tensor of random values."
msgstr "生成随机值的张量的函数。"

#: ../../../src/evox/core/_vmap_fix.py:242
msgid "The size arguments to the given function."
msgstr "给定函数的大小参数。"

#: ../../../src/evox/core/_vmap_fix.py:243
#: ../../../src/evox/core/_vmap_fix.py:250
msgid "The keyword arguments to the given function."
msgstr "给定函数的关键字参数。"

#: ../../../src/evox/core/_vmap_fix.py:245
#: ../../../src/evox/core/_vmap_fix.py:252
msgid "The batched tensor of random values."
msgstr "随机值的批量张量。"

#: ../../../src/evox/core/_vmap_fix.py:243
msgid ""
"Given a random function (e.g. "
"[`torch.randn_like`](https://pytorch.org/docs/stable/generated/torch.randn_like.html),"
" "
"[`torch.rand_like`](https://pytorch.org/docs/stable/generated/torch.rand_like.html),"
" etc.) and a tensor, this function generates a batched tensor of random "
"values by applying the given function to the tensor extended with the "
"current vmap batch size."
msgstr ""
"给定一个随机函数（例如 "
"[`torch.randn_like`](https://pytorch.org/docs/stable/generated/torch.randn_like.html)、[`torch.rand_like`](https://pytorch.org/docs/stable/generated/torch.rand_like.html)"
" 等）和一个张量， 此函数通过将给定函数应用于当前 vmap 批次大小扩展的张量，生成一个批量的随机值张量。"

#: ../../../src/evox/core/_vmap_fix.py:249
msgid "The tensor to generate random values like."
msgstr "生成随机值的张量。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:248
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:258
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:268
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:278
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:288
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:298
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:308
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:318
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:328
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:338
#: ../../source/apidocs/evox/evox.core.module.md:522
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:87
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:57
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:52
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:63
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:74
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:85
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:96
msgid "None"
msgstr "没有可翻译的文本。"

#: ../../../src/evox/core/_vmap_fix.py:438
msgid ""
"This function adjusts the input tensor `value` to match the batch dimensions"
" of `current_value`, which is assumed to be a batched tensor. If `value` is "
"already a batched tensor or `current_value` is not a batched tensor, it "
"returns `value` unchanged."
msgstr ""
"该函数将输入张量 `value` 调整为匹配 `current_value` 的批次维度，后者被假设为批次张量。如果 `value` 已经是批次张量或者"
" `current_value` 不是批次张量，它会返回 `value` 不变。"

#: ../../../src/evox/core/_vmap_fix.py:443
msgid ""
"The tensor to be aligned. If not a torch.Tensor, it is returned unchanged."
msgstr "要对齐的张量。如果不是一个 torch.Tensor，则保持不变返回。"

#: ../../../src/evox/core/_vmap_fix.py:445
msgid ""
"The reference batched tensor. If None or not a batched tensor, value is "
"returned unchanged."
msgstr "引用批量张量。如果是 None 或者不是批量张量，则返回的值保持不变。"

#: ../../../src/evox/core/_vmap_fix.py:449
msgid ""
"The input value aligned with the batch dimensions of current_value, if "
"applicable."
msgstr "输入值与当前值的批次维度对齐（如果适用）。"

#: ../../../src/evox/core/_vmap_fix.py:452
msgid ""
"When vectorized-mapping, it unwraps the batched tensor to print the "
"underlying values. Otherwise, the function behaves like "
"`format.format(*args, **kwargs)`."
msgstr "在向量化映射时，它会展开批量张量以打印底层值。否则，该函数的行为类似于 `format.format(*args, **kwargs)`。"

#: ../../../src/evox/core/_vmap_fix.py:454
msgid "A string format."
msgstr "字符串格式。"

#: ../../../src/evox/core/_vmap_fix.py:455
msgid "The positional tensor."
msgstr "位置张量。"

#: ../../../src/evox/core/_vmap_fix.py:456
msgid "The unchanged tensor."
msgstr "未改变的张量。"

#: ../../source/apidocs/evox/evox.core.components.md:1
msgid "{py:mod}`evox.core.components`"
msgstr "{py:mod}`evox.core.components`"

#: ../../source/apidocs/evox/evox.core.components.md:18
msgid "{py:obj}`Algorithm <evox.core.components.Algorithm>`"
msgstr "{py:obj}`Algorithm <evox.core.components.Algorithm>`"

#: ../../../src/evox/core/components.py:20
#: ../../../src/evox/core/components.py:45
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:22
msgid "{py:obj}`Problem <evox.core.components.Problem>`"
msgstr "{py:obj}`Problem <evox.core.components.Problem>`"

#: ../../../src/evox/core/components.py:24
#: ../../../src/evox/core/components.py:86
msgid "Base class for all problems"
msgstr "所有问题的基类"

#: ../../source/apidocs/evox/evox.core.components.md:26
msgid "{py:obj}`Workflow <evox.core.components.Workflow>`"
msgstr "{py:obj}`Workflow <evox.core.components.Workflow>`"

#: ../../../src/evox/core/components.py:28
#: ../../../src/evox/core/components.py:110
msgid "The base class for workflow."
msgstr "工作流的基类。"

#: ../../source/apidocs/evox/evox.core.components.md:30
msgid "{py:obj}`Monitor <evox.core.components.Monitor>`"
msgstr "{py:obj}`Monitor <evox.core.components.Monitor>`"

#: ../../../src/evox/core/components.py:32
#: ../../../src/evox/core/components.py:142
msgid "The monitor base class."
msgstr "监视器基类。"

#: ../../source/apidocs/evox/evox.core.components.md:42
#: ../../source/apidocs/evox/evox.core.components.md:83
#: ../../source/apidocs/evox/evox.core.components.md:107
#: ../../source/apidocs/evox/evox.core.components.md:139
msgid "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"

#: ../../../src/evox/core/components.py:48
msgid ""
"If a subclass have defined `trace_impl` of `step`, its corresponding "
"`init_step` must be overwritten even though nothing special is to be "
"included due to Python's object-oriented limitations."
msgstr ""
"如果子类定义了 `step` 的 `trace_impl` 方法，即使不需要添加任何特殊内容，由于 Python 对象模型的限制，其对应的 "
"`init_step` 方法必须被覆盖重写。"

#: ../../../src/evox/core/components.py:116
#: ../../../src/evox/core/components.py:148
#: ../../../src/evox/core/module.py:47 ../../../src/evox/core/module.py:51
#: ../../../src/evox/core/module.py:92 ../../../src/evox/core/module.py:232
msgid "Initialize the ModuleBase."
msgstr "初始化 ModuleBase。"

#: ../../../src/evox/core/components.py:118
#: ../../../src/evox/core/components.py:150
#: ../../../src/evox/core/module.py:49 ../../../src/evox/core/module.py:53
#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:234
msgid "Variable length argument list, passed to the parent class initializer."
msgstr "可变长度参数列表，传递给父类的初始化函数。"

#: ../../../src/evox/core/components.py:119
#: ../../../src/evox/core/components.py:151
#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:54
#: ../../../src/evox/core/module.py:95 ../../../src/evox/core/module.py:235
msgid "Arbitrary keyword arguments, passed to the parent class initializer."
msgstr "任意关键字参数，传递给父类初始化器。"

#: ../../../src/evox/core/components.py:121
#: ../../../src/evox/core/components.py:153
#: ../../../src/evox/core/module.py:52 ../../../src/evox/core/module.py:56
#: ../../../src/evox/core/module.py:97 ../../../src/evox/core/module.py:237
msgid ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."
msgstr ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."

#: ../../../src/evox/core/components.py:58
msgid "Execute the algorithm procedure for one step."
msgstr "执行算法过程的一步。"

#: ../../../src/evox/core/components.py:66
msgid ""
"Initialize the algorithm and execute the algorithm procedure for the first "
"step."
msgstr "初始化算法并执行算法过程的第一步。"

#: ../../../src/evox/core/components.py:75
msgid ""
"Evaluate the fitness at given points. This function is a proxy function of "
"`Problem.evaluate` set by workflow. By default, this functions raises "
"`NotImplementedError`."
msgstr ""
"在给定点评估适应度。这个函数是由工作流设置的 `Problem.evaluate` 的代理函数。默认情况下，这个函数会引发 "
"`NotImplementedError`。"

#: ../../../src/evox/core/components.py:79
#: ../../../src/evox/core/components.py:101
msgid "The population."
msgstr "种群。"

#: ../../../src/evox/core/components.py:81
#: ../../../src/evox/core/components.py:103
msgid "The fitness."
msgstr "适应度。"

#: ../../../src/evox/core/components.py:99
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: ../../../src/evox/core/components.py:106
msgid ""
"If this function contains external evaluations that cannot be JIT by "
"`torch.jit`, please wrap it with `torch.jit.ignore`."
msgstr "如果此函数包含无法通过 `torch.jit` JIT 的外部评估，请使用 `torch.jit.ignore` 对其进行包装。"

#: ../../../src/evox/core/components.py:123
#: ../../../src/evox/workflows/std_workflow.py:105
msgid "Perform the first optimization step of the workflow."
msgstr "用于让工作流执行一步的函数。"

#: ../../../src/evox/core/components.py:131
msgid "The basic function to step a workflow."
msgstr "基本功能以逐步执行工作流。"

#: ../../../src/evox/core/components.py:144
msgid ""
"Monitors are used to monitor the evolutionary process. They contains a set "
"of callbacks, which will be called at specific points during the execution "
"of the workflow. Monitor itself lives outside the main workflow, so jit is "
"not required."
msgstr ""
"监视器用于监控进化过程。它们包含一组回调，这些回调将在工作流执行的特定时刻被调用。Monitor 本身位于主工作流之外，因此不需要 jit。"

#: ../../../src/evox/core/components.py:149
msgid ""
"To implements a monitor, implement your own callbacks and override the hooks"
" method. The hooks method should return a list of strings, which are the "
"names of the callbacks. Currently the supported callbacks are:"
msgstr ""
"要实现一个监视器，您需要实现自己的回调并重写 hooks 方法。hooks 方法应返回一个字符串列表，这些字符串是回调的名称。目前支持的回调有："

#: ../../../src/evox/core/components.py:153
msgid "`post_ask`, `pre_eval`, `post_eval`, and `pre_tell`."
msgstr "`post_ask`、`pre_eval`、`post_eval` 和 `pre_tell`。"

#: ../../../src/evox/core/components.py:155
msgid "Set the static variables according to `config`."
msgstr "根据 `config` 设置静态变量。"

#: ../../../src/evox/core/components.py:157
msgid "The configuration."
msgstr "配置。"

#: ../../../src/evox/core/components.py:159
#: ../../../src/evox/core/module.py:247
msgid "This module."
msgstr "此模块。"

#: ../../../src/evox/core/components.py:163
msgid "The hook function to be executed before the solution transformation."
msgstr "解决方案转换前执行的钩子函数。"

#: ../../../src/evox/core/components.py:165
msgid ""
"The population (candidate solutions) before the solution transformation."
msgstr "种群（候选解）的初始演化状态"

#: ../../../src/evox/core/components.py:171
msgid "The hook function to be executed after the solution transformation."
msgstr "解决方案转换后执行的钩子函数。"

#: ../../../src/evox/core/components.py:173
msgid ""
"The population (candidate solutions) after the solution transformation."
msgstr "经过解的转换后的种群（候选解）。"

#: ../../../src/evox/core/components.py:179
msgid "The hook function to be executed before the fitness transformation."
msgstr "在适应度转换之前执行的钩子函数。"

#: ../../../src/evox/core/components.py:181
msgid "The fitnesses before the fitness transformation."
msgstr "在适应度转换之前的适应度。"

#: ../../../src/evox/core/components.py:187
msgid "The hook function to be executed after the fitness transformation."
msgstr "在适应度转换后要执行的钩子函数。"

#: ../../../src/evox/core/components.py:189
msgid "The fitnesses after the fitness transformation."
msgstr "适应度变换后的适应度值。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:1
msgid "{py:mod}`evox.core.jit_util`"
msgstr "{py:mod}`evox.core.jit_util`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:18
msgid "{py:obj}`MappedUseStateFunc <evox.core.jit_util.MappedUseStateFunc>`"
msgstr "{py:obj}`MappedUseStateFunc <evox.core.jit_util.MappedUseStateFunc>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:28
msgid "{py:obj}`vmap <evox.core.jit_util.vmap>`"
msgstr "{py:obj}`vmap <evox.core.jit_util.vmap>`"

#: ../../../src/evox/core/jit_util.py:30 ../../../src/evox/core/jit_util.py:97
msgid ""
"Vectorized map the given function to its mapped version, see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""
"向量化映射将给定的函数映射到其映射版本，更多信息请参见 "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html)。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:32
msgid "{py:obj}`_clone_inputs <evox.core.jit_util._clone_inputs>`"
msgstr "{py:obj}`_clone_inputs <evox.core.jit_util._clone_inputs>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:36
msgid ""
"{py:obj}`_form_positional_inputs "
"<evox.core.jit_util._form_positional_inputs>`"
msgstr ""
"{py:obj}`_form_positional_inputs "
"<evox.core.jit_util._form_positional_inputs>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:40
msgid "{py:obj}`jit <evox.core.jit_util.jit>`"
msgstr "{py:obj}`jit <evox.core.jit_util.jit>`"

#: ../../../src/evox/core/jit_util.py:42
#: ../../../src/evox/core/jit_util.py:118
msgid ""
"Just-In-Time (JIT) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""
"通过 "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) 或 "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`) 对给定的 `func` 进行即时编译 (JIT)。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:52
msgid "{py:obj}`T <evox.core.jit_util.T>`"
msgstr "{py:obj}`T <evox.core.jit_util.T>`"

#: ../../source/apidocs/evox/evox.core.jit_util.md:64
#: ../../source/apidocs/evox/evox.core.module.md:515
msgid "Bases: {py:obj}`typing.Protocol`"
msgstr "Bases: {py:obj}`typing.Protocol`"

#: ../../../src/evox/core/jit_util.py:71
msgid "Initialize the state of the mapped function."
msgstr "初始化映射函数的状态。"

#: ../../../src/evox/core/jit_util.py:73
msgid ""
"The batch size of the state. If None, the batch size of the state is "
"indicated by VMAP_DIM_CONST. Defaults to None."
msgstr "状态的批处理大小。如果为 None，则状态的批处理大小由 VMAP_DIM_CONST 指示。默认为 None。"

#: ../../../src/evox/core/jit_util.py:74
msgid ""
"Whether to torch.expand or torch.repeat the state tensors to the given batch"
" size."
msgstr "是否将状态张量使用 torch.expand 或 torch.repeat 扩展到给定的批量大小。"

#: ../../../src/evox/core/jit_util.py:76
msgid ""
"The initialized state, with the same keys as the state of the original "
"function."
msgstr "初始化状态，具有与原始函数状态相同的键。"

#: ../../source/apidocs/evox/evox.core.jit_util.md:87
#: ../../source/apidocs/evox/evox.core.module.md:192
#: ../../source/apidocs/evox/evox.core.module.md:601
#: ../../source/apidocs/evox/evox.core.module.md:635
msgid "'TypeVar(...)'"
msgstr "TypeVar(...)"

#: ../../../src/evox/core/jit_util.py:99
msgid "The function to be mapped. See torch.vmap."
msgstr "要映射的函数。请参见 torch.vmap。"

#: ../../../src/evox/core/jit_util.py:100
msgid "The inputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr "输入的批次维度。请参阅 torch.vmap。默认为 0。"

#: ../../../src/evox/core/jit_util.py:101
msgid "The outputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr "输出的批次维度。请参见 torch.vmap。默认为 0。"

#: ../../../src/evox/core/jit_util.py:102
msgid ""
"Whether to trace the mapped function with torch.jit.trace or simply use "
"torch.vmap. NOTICE: if trace=False`, all of the following inputs related to "
"tracing will be ignored."
msgstr ""
"是否使用 `torch.jit.trace` 追踪已映射的函数，还是简单地使用 `torch.vmap`。注意：如果 "
"`trace=False`，所有与追踪相关的输入将被忽略。"

#: ../../../src/evox/core/jit_util.py:103
msgid ""
"The ndim of the expected inputs of the batched function; thus, it must be at"
" least 1. Giving a single integer means same ndim for all inputs. Defaults "
"to 1."
msgstr "批处理函数期望输入的维度（ndim）；因此，它必须至少为 1。给定一个整数意味着所有输入具有相同的维度。默认值为 1。"

#: ../../../src/evox/core/jit_util.py:104
msgid "The . Defaults to None."
msgstr "默认为 None。"

#: ../../../src/evox/core/jit_util.py:105
msgid "description. Defaults to None."
msgstr "描述。默认为 None。"

#: ../../../src/evox/core/jit_util.py:106
#: ../../../src/evox/core/jit_util.py:132
msgid ""
"Strictly check the inputs or not. See torch.jit.trace. Defaults to False."
msgstr "严格检查输入与否。参见 torch.jit.trace。默认为 False。"

#: ../../../src/evox/core/jit_util.py:107
#: ../../../src/evox/core/jit_util.py:133
msgid ""
"Check the traced function or not. See torch.jit.trace. Defaults to False."
msgstr "检查是否跟踪了该函数。参见 torch.jit.trace。默认为 False。"

#: ../../../src/evox/core/jit_util.py:108
msgid ""
"The optional batched current state for a use_state wrapped function. If "
"None, a new batched state will be returned for each call of "
"init_state(None). Ignored when func is not wrapped by use_state. Defaults to"
" None."
msgstr ""
"可选的批处理当前状态，用于被 use_state 包裹的函数。如果为 None，则每次调用 init_state(None) "
"时将返回一个新的批处理状态。当 func 没有被 use_state 包裹时，该选项被忽略。默认值为 None。"

#: ../../../src/evox/core/jit_util.py:109
msgid ""
"When tracing, the example inputs may be broadcasted with additional "
"dimension(s) of size VMAP_DIM_CONST. Defaults to 13."
msgstr "依赖于 trace 时，示例输入可能会添加一个或多个大小为 VMAP_DIM_CONST 的维度。默认值：13。"

#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
msgid "Raises"
msgstr "引发"

#: ../../../src/evox/core/jit_util.py:111
msgid "If the function argument types are not supported"
msgstr "如果函数参数类型不支持"

#: ../../../src/evox/core/jit_util.py:113
msgid ""
"The “batched” (vectorized mapped) version of func. If the given func is "
"wrapped by use_state, the returned function will have a "
"init_state(batch_size: int) -> batched_state or init_state(None) -> "
"batched_state."
msgstr ""
"“批处理”（向量化映射）版本的 func。如果给定的 func 被 use_state 包裹，返回的函数将具有 "
"init_state(batch_size: int) -> batched_state 或 init_state(None) -> "
"batched_state。"

#: ../../../src/evox/core/jit_util.py:120
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260004
msgid ""
"This function wrapper effectively deals with nested JIT and vector map "
"(`vmap`) expressions like `jit(func1)` -> `vmap` -> `jit(func2)`, preventing"
" possible errors."
msgstr ""
"该函数包装器有效处理嵌套的 JIT 和向量映射 (`vmap`) 表达式，如 `jit(func1)` -> `vmap` -> "
"`jit(func2)`，从而防止可能出现的错误。"

#: ../../../src/evox/core/jit_util.py:128
msgid "The target function to be JIT"
msgstr "要进行 JIT 的目标函数"

#: ../../../src/evox/core/jit_util.py:129
msgid ""
"Whether using torch.jit.trace or torch.jit.script to JIT. Defaults to False."
msgstr "是否使用 torch.jit.trace 或 torch.jit.script 进行 JIT。默认为 False。"

#: ../../../src/evox/core/jit_util.py:130
msgid "Whether JIT lazily or immediately. Defaults to False."
msgstr "是选择懒加载还是立即执行 JIT。默认值为 False。"

#: ../../../src/evox/core/jit_util.py:131
msgid ""
"When lazy=False, the example inputs must be provided immediately, otherwise "
"ignored. Can be only positional arguments (a tuple), only keyword arguments "
"(a dict), or a tuple of positional arguments and keyword arguments (a tuple "
"of tuple and dict). Defaults to None."
msgstr ""
"当 lazy=False 时，示例输入必须立即提供，否则将被忽略。可以是仅位置参数（一个 tuple），仅关键字参数（一个 "
"dict），或位置参数和关键字参数的组合（一个 tuple 和 dict 的 tuple）。Defaults to None。"

#: ../../../src/evox/core/jit_util.py:134
msgid "Whether func is a generator or not. Defaults to False."
msgstr "无论 func 是否是生成器。默认为 False。"

#: ../../../src/evox/core/jit_util.py:135
msgid ""
"Whether to use torch.jit.trace directly (no_cache=True) or run the function "
"to make it cache internals when lazy=False. Defaults to False. Has no effect"
" when trace=False. This value must be set to False if the function contains "
"a instant call to torch.jit.trace which will be used inside a "
"torch.jit.script so that the JIT traced result shall be cached."
msgstr ""
"是否直接使用 torch.jit.trace （no_cache=True）或在 lazy=False 时运行函数以使其缓存内部内容。默认为 "
"False。当 trace=False 时没有效果。如果函数包含对 torch.jit.trace 的即时调用，并将在 torch.jit.script"
" 内部使用，则该值必须设置为 False，以便 JIT 跟踪的结果将被缓存。"

#: ../../../src/evox/core/jit_util.py:136
msgid ""
"Whether to return the dummy output of func as the second output or not. "
"Defaults to False. Has no effect when trace=False or lazy=True or "
"no_cache=True."
msgstr ""
"是否将 `func` 的 dummy 输出作为第二个输出返回默认值为False。如果 `trace=False` 或 `lazy=True` 或 "
"`no_cache=True` 则无效。"

#: ../../../src/evox/core/jit_util.py:137
msgid ""
"The manual seed to be set before each running of the function. Defaults to "
"None. Has no effect when trace=False. None means no manual seed will be set."
" Notice that any value other than None changes the GLOBAL random seed."
msgstr ""
"在每次运行该函数之前要设置的手动种子。默认为 None。当 trace=False 时没有效果。None "
"表示不设置手动种子。注意，任何其他值都将改变全局随机种子。"

#: ../../../src/evox/core/jit_util.py:139
msgid "The JIT version of func"
msgstr "func 的 JIT 版本"

#: ../../source/apidocs/evox/evox.core.module.md:1
msgid "{py:mod}`evox.core.module`"
msgstr "{py:mod}`evox.core.module`"

#: ../../source/apidocs/evox/evox.core.module.md:18
msgid "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"
msgstr "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"

#: ../../../src/evox/core/module.py:20 ../../../src/evox/core/module.py:226
msgid "The base module for all algorithms and problems in the library."
msgstr "该库中所有算法和问题的基础模块。"

#: ../../source/apidocs/evox/evox.core.module.md:22
msgid "{py:obj}`_WrapClassBase <evox.core.module._WrapClassBase>`"
msgstr "{py:obj}`_WrapClassBase <evox.core.module._WrapClassBase>`"

#: ../../source/apidocs/evox/evox.core.module.md:26
msgid "{py:obj}`UseStateFunc <evox.core.module.UseStateFunc>`"
msgstr "{py:obj}`UseStateFunc <evox.core.module.UseStateFunc>`"

#: ../../source/apidocs/evox/evox.core.module.md:36
msgid "{py:obj}`_if_none <evox.core.module._if_none>`"
msgstr "{py:obj}`_if_none <evox.core.module._if_none>`"

#: ../../source/apidocs/evox/evox.core.module.md:40
msgid "{py:obj}`_is_magic <evox.core.module._is_magic>`"
msgstr "{py:obj}`_is_magic <evox.core.module._is_magic>`"

#: ../../source/apidocs/evox/evox.core.module.md:44
msgid "{py:obj}`Parameter <evox.core.module.Parameter>`"
msgstr "{py:obj}`Parameter <evox.core.module.Parameter>`"

#: ../../../src/evox/core/module.py:46 ../../../src/evox/core/module.py:202
msgid "Wraps a value as parameter with `requires_grad=False`."
msgstr "将一个值包装为参数，`requires_grad=False`。"

#: ../../source/apidocs/evox/evox.core.module.md:48
msgid "{py:obj}`Mutable <evox.core.module.Mutable>`"
msgstr "{py:obj}`Mutable <evox.core.module.Mutable>`"

#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:209
msgid "Wraps a value as a mutable tensor."
msgstr "将值包装为可变张量。"

#: ../../source/apidocs/evox/evox.core.module.md:52
msgid ""
"{py:obj}`assign_load_state_dict <evox.core.module.assign_load_state_dict>`"
msgstr ""
"{py:obj}`assign_load_state_dict <evox.core.module.assign_load_state_dict>`"

#: ../../../src/evox/core/module.py:54 ../../../src/evox/core/module.py:216
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants."
msgstr "将参数和缓冲区从 state_dict 复制到此模块及其后代。"

#: ../../source/apidocs/evox/evox.core.module.md:56
msgid "{py:obj}`use_state_context <evox.core.module.use_state_context>`"
msgstr "{py:obj}`use_state_context <evox.core.module.use_state_context>`"

#: ../../../src/evox/core/module.py:58 ../../../src/evox/core/module.py:382
msgid "A context manager to set the value of `using_state` temporarily."
msgstr "一个上下文管理器，用于临时设置 `using_state` 的值。"

#: ../../source/apidocs/evox/evox.core.module.md:60
msgid ""
"{py:obj}`trace_caching_state_context "
"<evox.core.module.trace_caching_state_context>`"
msgstr ""
"{py:obj}`trace_caching_state_context "
"<evox.core.module.trace_caching_state_context>`"

#: ../../../src/evox/core/module.py:62 ../../../src/evox/core/module.py:389
msgid ""
"A context manager to set the value of `trace_caching_state` temporarily."
msgstr "一个上下文管理器，用于暂时设置 `trace_caching_state` 的值。"

#: ../../source/apidocs/evox/evox.core.module.md:64
msgid "{py:obj}`is_using_state <evox.core.module.is_using_state>`"
msgstr "{py:obj}`is_using_state <evox.core.module.is_using_state>`"

#: ../../../src/evox/core/module.py:66 ../../../src/evox/core/module.py:396
msgid "Get the current state of the `using_state`."
msgstr "获取当前的 `using_state` 状态。"

#: ../../source/apidocs/evox/evox.core.module.md:68
msgid ""
"{py:obj}`is_trace_caching_state <evox.core.module.is_trace_caching_state>`"
msgstr ""
"{py:obj}`is_trace_caching_state <evox.core.module.is_trace_caching_state>`"

#: ../../../src/evox/core/module.py:70 ../../../src/evox/core/module.py:403
msgid "Get the current state of the `trace_caching_state`."
msgstr "获取当前的 `trace_caching_state` 状态。"

#: ../../source/apidocs/evox/evox.core.module.md:72
msgid ""
"{py:obj}`tracing_or_using_state <evox.core.module.tracing_or_using_state>`"
msgstr ""
"{py:obj}`tracing_or_using_state <evox.core.module.tracing_or_using_state>`"

#: ../../../src/evox/core/module.py:74 ../../../src/evox/core/module.py:410
msgid ""
"Check if we are currently JIT tracing (inside a `torch.jit.trace`), in a "
"`use_state_context`, or in a `trace_caching_state`."
msgstr ""
"检查我们当前是否在进行 JIT 跟踪（在 `torch.jit.trace` 内），在 `use_state_context` 中，或者在 "
"`trace_caching_state` 中。"

#: ../../source/apidocs/evox/evox.core.module.md:76
msgid "{py:obj}`_get_vars <evox.core.module._get_vars>`"
msgstr "{py:obj}`_get_vars <evox.core.module._get_vars>`"

#: ../../source/apidocs/evox/evox.core.module.md:80
msgid "{py:obj}`use_state <evox.core.module.use_state>`"
msgstr "{py:obj}`use_state <evox.core.module.use_state>`"

#: ../../../src/evox/core/module.py:82 ../../../src/evox/core/module.py:574
msgid ""
"Transform the given stateful function (which in-place alters `nn.Module`s) "
"to a pure-functional version that receives an additional `state` parameter "
"(of type `Dict[str, torch.Tensor]`) and returns the altered state "
"additionally."
msgstr ""
"将给定的有状态函数（在原地更改 `nn.Module`s）转换为一个纯函数版本，该版本接收一个额外的 `state` 参数（类型为 `Dict[str,"
" torch.Tensor]`），并额外返回更改后的状态。"

#: ../../source/apidocs/evox/evox.core.module.md:84
msgid "{py:obj}`trace_impl <evox.core.module.trace_impl>`"
msgstr "{py:obj}`trace_impl <evox.core.module.trace_impl>`"

#: ../../../src/evox/core/module.py:86 ../../../src/evox/core/module.py:611
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a trace-JIT-time proxy of the given `target` method."
msgstr "用于注释的辅助函数，表明被包装的方法应被视为给定`target`方法的trace-JIT-time代理。"

#: ../../source/apidocs/evox/evox.core.module.md:88
msgid "{py:obj}`vmap_impl <evox.core.module.vmap_impl>`"
msgstr "{py:obj}`vmap_impl <evox.core.module.vmap_impl>`"

#: ../../../src/evox/core/module.py:90 ../../../src/evox/core/module.py:628
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a vmap-JIT-time proxy of the given `target` method."
msgstr "一个辅助函数，用于标记被包装的方法应被视为给定 `target` 方法的 vmap-JIT 时间代理。"

#: ../../source/apidocs/evox/evox.core.module.md:92
msgid "{py:obj}`jit_class <evox.core.module.jit_class>`"
msgstr "{py:obj}`jit_class <evox.core.module.jit_class>`"

#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:655
msgid ""
"A helper function used to JIT script (`torch.jit.script`) or trace "
"(`torch.jit.trace_module`) all member methods of class `cls`."
msgstr ""
"用于 JIT 脚本 (`torch.jit.script`) 或跟踪 (`torch.jit.trace_module`) 类 `cls` "
"的所有成员方法的辅助函数。"

#: ../../source/apidocs/evox/evox.core.module.md:104
msgid ""
"{py:obj}`_WRAPPING_MODULE_NAME <evox.core.module._WRAPPING_MODULE_NAME>`"
msgstr ""
"{py:obj}`_WRAPPING_MODULE_NAME <evox.core.module._WRAPPING_MODULE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:108
msgid "{py:obj}`ParameterT <evox.core.module.ParameterT>`"
msgstr "{py:obj}`ParameterT <evox.core.module.ParameterT>`"

#: ../../source/apidocs/evox/evox.core.module.md:112
msgid "{py:obj}`_using_state <evox.core.module._using_state>`"
msgstr "{py:obj}`_using_state <evox.core.module._using_state>`"

#: ../../source/apidocs/evox/evox.core.module.md:116
msgid "{py:obj}`_trace_caching_state <evox.core.module._trace_caching_state>`"
msgstr ""
"{py:obj}`_trace_caching_state <evox.core.module._trace_caching_state>`"

#: ../../source/apidocs/evox/evox.core.module.md:120
msgid "{py:obj}`_SUBMODULE_PREFIX <evox.core.module._SUBMODULE_PREFIX>`"
msgstr "{py:obj}`_SUBMODULE_PREFIX <evox.core.module._SUBMODULE_PREFIX>`"

#: ../../source/apidocs/evox/evox.core.module.md:124
msgid "{py:obj}`_USE_STATE_NAME <evox.core.module._USE_STATE_NAME>`"
msgstr "{py:obj}`_USE_STATE_NAME <evox.core.module._USE_STATE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:128
msgid "{py:obj}`_STATE_ARG_NAME <evox.core.module._STATE_ARG_NAME>`"
msgstr "{py:obj}`_STATE_ARG_NAME <evox.core.module._STATE_ARG_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:132
msgid "{py:obj}`_EMPTY_NAME <evox.core.module._EMPTY_NAME>`"
msgstr "{py:obj}`_EMPTY_NAME <evox.core.module._EMPTY_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:136
msgid ""
"{py:obj}`_TORCHSCRIPT_MODIFIER <evox.core.module._TORCHSCRIPT_MODIFIER>`"
msgstr ""
"{py:obj}`_TORCHSCRIPT_MODIFIER <evox.core.module._TORCHSCRIPT_MODIFIER>`"

#: ../../source/apidocs/evox/evox.core.module.md:140
msgid "{py:obj}`_TRACE_WRAP_NAME <evox.core.module._TRACE_WRAP_NAME>`"
msgstr "{py:obj}`_TRACE_WRAP_NAME <evox.core.module._TRACE_WRAP_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:144
msgid "{py:obj}`T <evox.core.module.T>`"
msgstr "{py:obj}`T <evox.core.module.T>`"

#: ../../source/apidocs/evox/evox.core.module.md:148
msgid "{py:obj}`_VMAP_WRAP_NAME <evox.core.module._VMAP_WRAP_NAME>`"
msgstr "{py:obj}`_VMAP_WRAP_NAME <evox.core.module._VMAP_WRAP_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:152
msgid "{py:obj}`ClassT <evox.core.module.ClassT>`"
msgstr "{py:obj}`ClassT <evox.core.module.ClassT>`"

#: ../../source/apidocs/evox/evox.core.module.md:156
msgid "{py:obj}`_BASE_NAME <evox.core.module._BASE_NAME>`"
msgstr "{py:obj}`_BASE_NAME <evox.core.module._BASE_NAME>`"

#: ../../source/apidocs/evox/evox.core.module.md:168
msgid "'__wrapping_module__'"
msgstr "'__wrapping_module__'"

#: ../../../src/evox/core/module.py:204
msgid "The parameter value."
msgstr "参数值。"

#: ../../../src/evox/core/module.py:205
msgid "The dtype of the parameter. Defaults to None."
msgstr "参数的数据类型。默认为 None。"

#: ../../../src/evox/core/module.py:206
msgid "The device of the parameter. Defaults to None."
msgstr "参数的设备。默认值为 None。"

#: ../../../src/evox/core/module.py:207
msgid "Whether the parameter requires gradient. Defaults to False."
msgstr "参数是否需要梯度。默认值为 False。"

#: ../../../src/evox/core/module.py:209
msgid "The parameter."
msgstr "参数。"

#: ../../../src/evox/core/module.py:211
msgid "The value to be wrapped."
msgstr "要包装的值。"

#: ../../../src/evox/core/module.py:212
msgid "The dtype of the tensor. Defaults to None."
msgstr "张量的 dtype。默认值为 None。"

#: ../../../src/evox/core/module.py:213
msgid "The device of the tensor. Defaults to None."
msgstr "张量的设备。默认为 None。"

#: ../../../src/evox/core/module.py:215
msgid "The wrapped tensor."
msgstr "被包装的张量。"

#: ../../../src/evox/core/module.py:218
msgid ""
"This method is used to mimic the behavior of `ModuleBase.load_state_dict` so"
" that a regular `nn.Module` can be used with `vmap`."
msgstr ""
"该方法用来模仿 `ModuleBase.load_state_dict` 的行为，使得一个普通的 `nn.Module` 能被用于 `vmap` 中。"

#: ../../source/apidocs/evox/evox.core.module.md:223
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:32
msgid "Bases: {py:obj}`torch.nn.Module`"
msgstr "Bases: {py:obj}`torch.nn.Module`"

#: ../../../src/evox/core/module.py:229
msgid "This module is an object-oriented one that can contain mutable values."
msgstr "该模块是一种面向对象的模块，可以包含可变值。"

#: ../../../src/evox/core/module.py:230
msgid ""
"Functional programming model is supported via `self.state_dict(...)` and "
"`self.load_state_dict(...)`."
msgstr ""
"支持功能编程模型是通过 `self.state_dict(...)` 和 `self.load_state_dict(...)` 来实现的。"

#: ../../../src/evox/core/module.py:231
msgid ""
"The module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr "建议将非静态成员的模块初始化写在重写的 `setup`（或其他成员方法）中，而不是 `__init__` 中。"

#: ../../../src/evox/core/module.py:232
msgid ""
"Basically, predefined submodule(s) which will be ADDED to this module and "
"accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr "基本上，预定义的子模块应被视为“非静态成员”，这些模块将被添加到此模块并在成员方法中稍后访问，而其他任何成员应视为“静态成员”。"

#: ../../../src/evox/core/module.py:235
msgid "Static methods to be JIT shall be defined as is, e.g.,"
msgstr "静态方法将按原样定义为 JIT，例如，"

#: ../../../src/evox/core/module.py:241
msgid ""
"If a class member function with python dynamic control flows like `if` were "
"to be JIT, a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""
"如果一个类成员函数具有像 `if` 这样的 Python 动态控制流，并且需要 JIT，则应使用一个单独的静态方法，格式为 `jit(..., "
"trace=False)` 或 `torch.jit.script_if_tracing`："

#: ../../../src/evox/core/module.py:261
msgid ""
"`ModuleBase` is usually used with `jit_class` to automatically JIT all non-"
"magic member methods:"
msgstr "`ModuleBase` 通常与 `jit_class` 一起使用，以自动 JIT 所有非魔法成员方法："

#: ../../../src/evox/core/module.py:244
msgid ""
"Setup the module. Module initialization lines should be written in the "
"overwritten method of `setup` rather than `__init__`."
msgstr "设置模块。模块初始化行应写在重写的 `setup` 方法中，而不是 `__init__` 中。"

#: ../../../src/evox/core/module.py:250
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable initialization cannot. Therefore, multiple calls of `setup` for "
"multiple initializations are possible."
msgstr "静态初始化仍然可以在 `__init__` 中编写，而可变初始化则不可以。因此，对于多个初始化，可以多次调用 `setup`。"

#: ../../../src/evox/core/module.py:252
msgid ""
"Prepares the control flow state of the module by collecting and merging the "
"state and non-local variables from the specified target functions."
msgstr "准备通过收集和合并指定目标函数的状态和非本地变量来准备模块的控制流状态。"

#: ../../../src/evox/core/module.py:254
msgid ""
"This function is used alongside with `after_control_flow()` to enable your "
"control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `after_control_flow()`."
msgstr ""
"**用于控制流操作（控制分支等）的前向操作**\n"
"\n"
"本函数与 `after_control_flow()` 配合使用，确保控制流操作（ `utils.control_flow.*` ）正确处理副作用。如果控制流操作没有副作用，则完全可以忽略本函数和 `after_control_flow()`。"

#: ../../../src/evox/core/module.py:256
msgid "Functions whose non-local variables are to be collected."
msgstr "收集非本地变量的函数。"

#: ../../../src/evox/core/module.py:257
msgid "See torch.nn.Module.state_dict(..., keep_vars). Defaults to True."
msgstr "See torch.nn.Module.state_dict(..., keep_vars). 默认为 True."

#: ../../../src/evox/core/module.py:259
msgid ""
"A tuple containing the merged state dictionary, a list of state keys, and a "
"list of non-local variable names."
msgstr "一个包含合并状态字典、状态键列表和非局部变量名称列表的元组。"

#: ../../../src/evox/core/module.py:261
msgid ""
"If not all target functions are local, global, or this class member "
"functions"
msgstr "如果不是所有目标函数都是局部的、全局的或这个类的成员函数"

#: ../../../src/evox/core/module.py:263
#: ../../../src/evox/problems/neuroevolution/brax.py:128
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:86
msgid "Warning"
msgstr "警告"

#: ../../../src/evox/core/module.py:264
msgid ""
"The non-local variables collected here can ONLY be used as read-only ones. "
"In-place modifications to these variables may not raise any error and "
"silently produce incorrect results."
msgstr "此处收集的非本地变量只能用作只读变量。对这些变量的就地修改可能不会引发任何错误，并在不经意间产生不正确的结果。"

#: ../../../src/evox/core/module.py:260
msgid ""
"Restores the module state to the one before `prepare_control_flow` from the "
"given `state` and returns the non-local variables collected in "
"`prepare_control_flow`."
msgstr "将模块状态恢复到在给定 `state` 之前的状态，并返回在 `prepare_control_flow` 中收集的非本地变量。"

#: ../../../src/evox/core/module.py:262
msgid ""
"This function is used alongside with `prepare_control_flow()` to enable your"
" control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `prepare_control_flow()`."
msgstr ""
"此函数与 `prepare_control_flow()` 一起使用，以使您的控制流操作 (`utils.control_flow.*`) "
"正确处理副作用。如果控制流操作没有副作用，您可以安全地忽略此函数和 `prepare_control_flow()`。"

#: ../../../src/evox/core/module.py:264
msgid "The state dictionary to restore the module state from."
msgstr "用于从中恢复模块状态的状态字典。"

#: ../../../src/evox/core/module.py:265
msgid "The keys of the state dictionary that represent the module state."
msgstr "表示模块状态的状态字典的键。"

#: ../../../src/evox/core/module.py:266
msgid ""
"The keys of the state dictionary that represent the non-local variables."
msgstr "表示非局部变量的状态字典的键。"

#: ../../../src/evox/core/module.py:268
msgid "The non-local variables dictionary collected in prepare_control_flow."
msgstr "在prepare_control_flow中收集的非局部变量字典。"

#: ../../../src/evox/core/module.py:271
msgid "See `prepare_control_flow()`."
msgstr "查看 `prepare_control_flow()` 。"

#: ../../../src/evox/core/module.py:268
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants. Overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""
"将参数和缓冲区从 state_dict 复制到此模块及其子模块中。覆盖 "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)。"

#: ../../../src/evox/core/module.py:271
msgid ""
"A dict containing parameters and buffers used to update this module. See "
"torch.nn.Module.load_state_dict."
msgstr "一个包含用于更新该模块的参数和缓冲区的字典。请参阅 torch.nn.Module.load_state_dict。"

#: ../../../src/evox/core/module.py:272
msgid ""
"Use the original torch.nn.Module.load_state_dict to copy the state_dict to "
"current state (copy=True) or use this implementation that assigns the values"
" of this module to the ones in the state_dict (copy=False). Defaults to "
"False."
msgstr ""
"使用原始的torch.nn.Module.load_state_dict来复制state_dict到当前状态（copy=True）或者使用此实现来将此模块的值分配给state_dict中的值（copy=False）。默认为False。"

#: ../../../src/evox/core/module.py:273
msgid ""
"The original arguments of torch.nn.Module.load_state_dict. Ignored if "
"copy=False."
msgstr ""
"torch.nn.Module.load_state_dict 的原始参数。\n"
"如果 copy=False，会忽略这些参数。"

#: ../../../src/evox/core/module.py:275
msgid ""
"If copy=True, returns the return of torch.nn.Module.load_state_dict; "
"otherwise, no return."
msgstr "如果 copy=True, 则返回 torch.nn.Module.load_state_dict 的返回值; 否则,不返回。"

#: ../../../src/evox/core/module.py:276
#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Define a mutable value in this module that can be accessed via `self.[name]`"
" and modified in-place."
msgstr "定义一个可变值，并将其在 `self.[name]` 中暴露出来，可以通过 `self.[name] = [值]` 来修改。"

#: ../../../src/evox/core/module.py:278
msgid "The mutable value's name."
msgstr "可变值的名称。"

#: ../../../src/evox/core/module.py:279
msgid "The mutable value, can be a tuple, list, dictionary of a torch.Tensor."
msgstr "可变值可以是一个元组、列表或一个 torch.Tensor 的字典。"

#: ../../../src/evox/core/module.py:281
msgid "If the mutable value's type is not supported yet."
msgstr "如果可变值的类型尚不受支持。"

#: ../../../src/evox/core/module.py:282
msgid "If the name is invalid."
msgstr "如果名称无效。"

#: ../../../src/evox/core/module.py:328
msgid "Get the mutable value(s) stored in this list-like module."
msgstr "获取存储在此类列表模块中的可变值。"

#: ../../../src/evox/core/module.py:330 ../../../src/evox/core/module.py:339
msgid "The key used to index mutable value(s)."
msgstr "用于索引可变值的关键。"

#: ../../../src/evox/core/module.py:332
msgid "If key is out of range."
msgstr "如果键超出范围。"

#: ../../../src/evox/core/module.py:333
msgid "If key is of wrong type."
msgstr "如果 key 类型错误。"

#: ../../../src/evox/core/module.py:335
msgid "The indexed mutable value(s)."
msgstr "索引可变值。"

#: ../../../src/evox/core/module.py:336
msgid "Set the mutable value(s) stored in this list-like module."
msgstr "设置存储在此类列表模块中的可变值。"

#: ../../../src/evox/core/module.py:338
msgid "The new mutable value(s)."
msgstr "新的可变值。"

#: ../../../src/evox/core/module.py:384
msgid ""
"When entering the context, the value of `using_state` is set to "
"`new_use_state` and a token is obtained. When exiting the context, the value"
" of `using_state` is reset to its previous value."
msgstr ""
"当进入上下文时，`using_state` 的值被设置为 `new_use_state`，并获得一个令牌。当退出上下文时，`using_state` "
"的值被重置为之前的值。"

#: ../../../src/evox/core/module.py:387
msgid "The new value of using_state. Defaults to True."
msgstr "使用 `using_state` 的新值。默认为 True。"

#: ../../../src/evox/core/module.py:391
msgid ""
"When entering the context, the value of `trace_caching_state` is set to "
"`new_trace_caching_state` and a token is obtained. When exiting the context,"
" the value of `trace_caching_state` is reset to its previous value."
msgstr ""
"在进入上下文时，`trace_caching_state` 的值被设置为 `new_trace_caching_state` "
"并获取一个令牌。当退出上下文时，`trace_caching_state` 的值被重置为其先前的值。"

#: ../../../src/evox/core/module.py:394
msgid "The new value of trace_caching_state. Defaults to True."
msgstr "trace_caching_state 的新值。默认为 True。"

#: ../../../src/evox/core/module.py:398
msgid "The current state of the using_state."
msgstr "使用状态的当前状态。"

#: ../../../src/evox/core/module.py:405
msgid "The current state of the trace_caching_state."
msgstr "当前的 trace_caching_state 状态。"

#: ../../../src/evox/core/module.py:412
msgid "True if either condition is true, False otherwise."
msgstr "如果任一条件为真，则返回 True；否则返回 False。"

#: ../../source/apidocs/evox/evox.core.module.md:417
msgid "'__submodule_'"
msgstr "'__submodule_'"

#: ../../source/apidocs/evox/evox.core.module.md:495
msgid "'__use_state__'"
msgstr "'__use_state__'"

#: ../../source/apidocs/evox/evox.core.module.md:505
msgid "'state'"
msgstr "'state'"

#: ../../../src/evox/core/module.py:533
msgid ""
"Get the cloned state of the closures of the function when it is wrapped by "
"`use_state`."
msgstr "获取函数被 `use_state` 包装时闭包的克隆状态。"

#: ../../../src/evox/core/module.py:535
msgid "Whether to clone the original state or not. Defaults to True."
msgstr "是否克隆原始状态。默认为 True。"

#: ../../../src/evox/core/module.py:537
msgid "The cloned state of the closures."
msgstr "闭包的克隆状态。"

#: ../../../src/evox/core/module.py:541
msgid "Set the closures of the function to the given state."
msgstr "将函数的闭包设置为给定状态。"

#: ../../../src/evox/core/module.py:543
msgid ""
"The new state to set to. If state=None, the new state would be the original "
"state when the function is wrapped by use_state. Defaults to None."
msgstr "要设置的新状态。如果 state=None，那么新状态将是当函数被 use_state 包裹时的原始状态。默认值为 None。"

#: ../../source/apidocs/evox/evox.core.module.md:557
msgid "'___empty___'"
msgstr "'___empty___'"

#: ../../../src/evox/core/module.py:576
msgid "The stateful function to be transformed or its generator function."
msgstr "要转换的有状态函数或其生成函数。"

#: ../../../src/evox/core/module.py:577
msgid ""
"Whether func is a function or a function generator (e.g. a lambda that "
"returns the stateful function). Defaults to True."
msgstr "func 是一个函数还是一个函数生成器（例如，返回有状态函数的 lambda）。默认为 True。"

#: ../../../src/evox/core/module.py:579
msgid ""
"The transformed pure-functional version of func. It contains a init_state() "
"-> state attribute that returns the copy of the current state that func uses"
" and can be used as example inputs of the additional state parameter. It "
"also contains a set_state(state) attribute to set the global state to the "
"given one (of course not JIT-compatible)."
msgstr ""
"`func` 的纯函数版本。它包含一个 `init_state() -> state` 属性，该属性返回 `func` "
"使用的当前状态的副本，并可用作附加状态参数的示例输入。它还包含一个 `set_state(state)` 属性，用于将全局状态设置为给定状态（当然不兼容"
" JIT）。"

#: ../../../src/evox/core/module.py:582
msgid ""
"Since PyTorch cannot JIT or vectorized-map a function with empty dictionary,"
" list, or tuple as its input, this function transforms the given function to"
" a function WITHOUT the additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and does NOT return the altered state additionally."
msgstr ""
"由于 PyTorch 不能对输入为空字典、列表或元组的函数进行 JIT 编译或矢量映射，该函数将给定函数转换为一个没有额外 `state` 参数（类型为"
" `Dict[str, torch.Tensor]`）的函数，并且不额外返回修改后的状态。"

#: ../../source/apidocs/evox/evox.core.module.md:581
msgid "'_torchscript_modifier'"
msgstr "'_torchscript_modifier'"

#: ../../source/apidocs/evox/evox.core.module.md:591
msgid "'__trace_wrapped__'"
msgstr "'__trace_wrapped__'"

#: ../../../src/evox/core/module.py:613 ../../../src/evox/core/module.py:630
msgid "Can ONLY be used inside a `jit_class` for a member method."
msgstr "只能在 `jit_class` 中的成员方法中使用。"

#: ../../../src/evox/core/module.py:615 ../../../src/evox/core/module.py:632
msgid "The target method invoked when not tracing JIT."
msgstr "未追踪 JIT 时调用的目标方法。"

#: ../../../src/evox/core/module.py:617 ../../../src/evox/core/module.py:634
msgid "The wrapping function to annotate the member method."
msgstr "用于注解成员方法的包装函数。"

#: ../../../src/evox/core/module.py:620 ../../../src/evox/core/module.py:637
msgid ""
"The target function and the annotated function MUST have same input/output "
"signatures (e.g. number of arguments and types); otherwise, the resulting "
"behavior is UNDEFINED."
msgstr "目标函数和注解函数 MUST拥有同样的输入/输出签名（例如参数个数和类型）；否则产生的行为是未定义的。"

#: ../../../src/evox/core/module.py:621 ../../../src/evox/core/module.py:638
msgid ""
"If the annotated function are to be `vmap`, it cannot contain any in-place "
"operations to `self` since such operations are not well-defined and cannot "
"be compiled."
msgstr "如果注解的函数是 `vmap`，则它不能包含对 `self` 的任何原地操作，因为这样的操作是不明确的，并且不能被编译。"

#: ../../../src/evox/core/module.py:624 ../../../src/evox/core/module.py:641
msgid "See `use_state`."
msgstr "请参阅 `use_state`。"

#: ../../source/apidocs/evox/evox.core.module.md:618
msgid "'__vmap_wrapped__'"
msgstr "__vmap_wrapped__"

#: ../../source/apidocs/evox/evox.core.module.md:645
msgid "'base'"
msgstr "基类"

#: ../../../src/evox/core/module.py:657
msgid "The original class whose member methods are to be lazy JIT."
msgstr "原始类，其成员方法将被延迟 JIT。"

#: ../../../src/evox/core/module.py:658
msgid "Whether to trace the module or to script the module. Default to False."
msgstr "是否追踪模块或将模块脚本化。默认为 False。"

#: ../../../src/evox/core/module.py:660
msgid "Returns:     The wrapped class."
msgstr "返回：     被封装的类。"

#: ../../../src/evox/core/module.py:664
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with `jit_class`, the workflow(s) will do the trick for you."
msgstr "在许多情况下，您不需要使用 `jit_class` 来包装您的自定义算法或问题，工作流将为您完成此任务。"

#: ../../../src/evox/core/module.py:665
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional"
msgstr ""
"设置 `trace=True` 时，所有成员函数都会被有效地修改，以额外返回 `self`，因为副作用无法被追踪。如果您想保留副作用，请将 "
"`trace=False`，并使用 `use_state` 函数来包装成员方法以生成纯函数。"

#: ../../../src/evox/core/module.py:666
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220012
msgid ""
"Similarly, all module-wide operations like `self.to(...)` can only returns "
"the unwrapped module, which may not be desired. Since most of them are in-"
"place operations, a simple `module.to(...)` can be used instead of `module ="
" module.to(...)`."
msgstr ""
"类似地，所有模块级的操作如 `self.to(...)` 只能返回未包装的模块，这可能不是我们想要的。由于它们大多是就地操作，可以使用简单的 "
"`module.to(...)` 来替代 `module = module.to(...)`。"

#: ../../source/apidocs/evox/evox.metrics.md:1
msgid "{py:mod}`evox.metrics`"
msgstr "{py:mod}`evox.metrics`"

#: ../../source/apidocs/evox/evox.metrics.md:29
msgid "{py:obj}`__all__ <evox.metrics.__all__>`"
msgstr "{py:obj}`__all__ <evox.metrics.__all__>`"

#: ../../source/apidocs/evox/evox.metrics.md:41
msgid "['gd', 'hv', 'igd']"
msgstr "['gd', 'hv', 'igd']"

#: ../../source/apidocs/evox/evox.metrics.gd.md:1
msgid "{py:mod}`evox.metrics.gd`"
msgstr "{py:mod}`evox.metrics.gd`"

#: ../../source/apidocs/evox/evox.metrics.gd.md:18
msgid "{py:obj}`gd <evox.metrics.gd.gd>`"
msgstr "{py:obj}`gd <evox.metrics.gd.gd>`"

#: ../../../src/evox/metrics/gd.py:20 ../../../src/evox/metrics/gd.py:30
msgid ""
"Calculate the Generational Distance (GD) metric between a set of solutions "
"and the Pareto front."
msgstr "计算一组解与帕累托前沿之间的世代距离（GD）指标。"

#: ../../../src/evox/metrics/gd.py:32 ../../../src/evox/metrics/igd.py:32
msgid ""
"A tensor of shape (n, m), where n is the number of solutions and m is the "
"number of objectives. Represents the set of solutions to be evaluated."
msgstr "一个形状为 (n, m) 的张量，其中 n 是解的数量，m 是目标的数量。表示要评估的解集。"

#: ../../../src/evox/metrics/gd.py:34 ../../../src/evox/metrics/igd.py:34
msgid ""
"A tensor of shape (k, m), where k is the number of points on the Pareto "
"front and m is the number of objectives. Represents the true Pareto front."
msgstr "一个形状为 (k, m) 的张量，其中 k 是帕累托前沿上的点数，m 是目标数量。表示真实的帕累托前沿。"

#: ../../../src/evox/metrics/gd.py:37
msgid ""
"The GD score, a scalar representing the average distance of the solutions to"
" the Pareto front."
msgstr "GD 分数是一种标量，代表着解与帕雷托前沿的平均距离。"

#: ../../../src/evox/metrics/gd.py:40
msgid ""
"The GD score is lower when the approximation is closer to the Pareto front."
msgstr "GD 得分会随着近似值逼近帕累托前沿而降低。"

#: ../../source/apidocs/evox/evox.metrics.hv.md:1
msgid "{py:mod}`evox.metrics.hv`"
msgstr "{py:mod}`evox.metrics.hv`"

#: ../../source/apidocs/evox/evox.metrics.hv.md:18
msgid "{py:obj}`hv <evox.metrics.hv.hv>`"
msgstr "{py:obj}`hv <evox.metrics.hv.hv>`"

#: ../../../src/evox/metrics/hv.py:20 ../../../src/evox/metrics/hv.py:30
msgid "Monte Carlo Hypervolume Calculation using bounding cube method."
msgstr "蒙特卡罗超体积计算使用边界立方体方法。"

#: ../../../src/evox/metrics/hv.py:32
msgid "Objective points of shape (n_points, n_objs)."
msgstr "目标点的形状为 (n_points, n_objs)。"

#: ../../../src/evox/metrics/hv.py:33
msgid "Reference point of shape (n_objs, )."
msgstr "形状为 (n_objs, ) 的参考点。"

#: ../../../src/evox/metrics/hv.py:34
msgid "Number of Monte Carlo samples."
msgstr "蒙特卡罗样本数量。"

#: ../../../src/evox/metrics/hv.py:35
msgid "Estimated hypervolume."
msgstr "估计的超体积"

#: ../../source/apidocs/evox/evox.metrics.igd.md:1
msgid "{py:mod}`evox.metrics.igd`"
msgstr "{py:mod}`evox.metrics.igd`"

#: ../../source/apidocs/evox/evox.metrics.igd.md:18
msgid "{py:obj}`igd <evox.metrics.igd.igd>`"
msgstr "{py:obj}`igd <evox.metrics.igd.igd>`"

#: ../../../src/evox/metrics/igd.py:20 ../../../src/evox/metrics/igd.py:30
msgid ""
"Calculate the Inverted Generational Distance (IGD) metric between a set of "
"solutions and the Pareto front."
msgstr "计算一组解决方案与帕累托前沿之间的逆向代际距离 (IGD) 指标。"

#: ../../../src/evox/metrics/igd.py:36
msgid ""
"The power parameter used in the calculation (default is 1). This defines the"
" distance metric (L^p norm)."
msgstr "计算中使用的幂参数（默认为1）。这定义了距离度量（L^p 范数）。"

#: ../../../src/evox/metrics/igd.py:38
msgid ""
"The IGD score, a scalar representing the average distance of the solutions "
"to the Pareto front."
msgstr "IGD得分是一个标量，表示解到帕累托前沿的平均距离。"

#: ../../../src/evox/metrics/igd.py:41
msgid ""
"The IGD score is lower when the approximation is closer to the Pareto front."
msgstr "当近似值接近Pareto前沿时，IGD得分较低。"

#: ../../source/apidocs/evox/evox.operators.md:1
msgid "{py:mod}`evox.operators`"
msgstr "{py:mod}`evox.operators`"

#: ../../source/apidocs/evox/evox.operators.md:30
msgid "{py:obj}`__all__ <evox.operators.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.__all__>`"

#: ../../source/apidocs/evox/evox.operators.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'non_dominate_rank', "
"'non_dominated_sort_script']"
msgstr ""
"['NonDominatedSort', 'crowding_distance', 'non_dominate_rank', "
"'non_dominated_sort_script']"

#: ../../source/apidocs/evox/evox.operators.crossover.md:1
msgid "{py:mod}`evox.operators.crossover`"
msgstr "{py:mod}`evox.operators.crossover`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:29
msgid "{py:obj}`__all__ <evox.operators.crossover.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.crossover.__all__>`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:41
msgid ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."
msgstr ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:1
msgid "{py:mod}`evox.operators.crossover.differential_evolution`"
msgstr "{py:mod}`evox.operators.crossover.differential_evolution`"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:18
msgid ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"
msgstr ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:20
#: ../../../src/evox/operators/crossover/differential_evolution.py:42
msgid "Computes the difference vectors' sum in differential evolution."
msgstr "计算差分演化中的差异向量总和。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:22
msgid ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"
msgstr ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:24
#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "Performs binary crossover in differential evolution."
msgstr "在差分演化中执行二进制交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:26
msgid ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"
msgstr ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:28
#: ../../../src/evox/operators/crossover/differential_evolution.py:56
msgid "Performs exponential crossover in differential evolution."
msgstr "在差分演化中执行指数交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:30
msgid ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"
msgstr ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:32
#: ../../../src/evox/operators/crossover/differential_evolution.py:63
msgid "Performs arithmetic recombination in differential evolution."
msgstr "在演化算法中进行差分进化的算术重组。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:44
msgid "The number of padding difference vectors."
msgstr "padding差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:45
msgid "The number of difference vectors used in mutation."
msgstr "变异过程中使用的差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:46
msgid "The index of current individual."
msgstr "当前个体的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:47
msgid "The population tensor."
msgstr "种群张量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "The difference sum and the index of first difference vector."
msgstr "差分总和和第一个差分向量的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:51
#: ../../../src/evox/operators/crossover/differential_evolution.py:58
#: ../../../src/evox/operators/crossover/differential_evolution.py:65
msgid "The mutated vector for each individual in the population."
msgstr "种群中每个个体的变异向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:52
#: ../../../src/evox/operators/crossover/differential_evolution.py:59
#: ../../../src/evox/operators/crossover/differential_evolution.py:66
msgid "The current vector for each individual in the population."
msgstr "每个个体在种群中的当前向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:53
#: ../../../src/evox/operators/crossover/differential_evolution.py:60
msgid "The crossover probability for each individual."
msgstr "每个个体的交叉概率。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:55
#: ../../../src/evox/operators/crossover/differential_evolution.py:62
msgid "The trial vector after crossover for each individual."
msgstr "每个个体交叉后的试验向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:67
msgid "The coefficient for each individual."
msgstr "每个个体的系数。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:69
msgid "The trial vector after recombination for each individual."
msgstr "每个个体重组后的试验向量。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:1
msgid "{py:mod}`evox.operators.crossover.sbx`"
msgstr "{py:mod}`evox.operators.crossover.sbx`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:18
msgid ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"
msgstr ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"

#: ../../../src/evox/operators/crossover/sbx.py:20
#: ../../../src/evox/operators/crossover/sbx.py:30
msgid "Simulated binary crossover (SBX)"
msgstr "模拟二进制交叉 (SBX)"

#: ../../../src/evox/operators/crossover/sbx.py:32
#: ../../../src/evox/operators/crossover/sbx_half.py:32
msgid "Parent solutions in a 2D tensor (size: n x d)."
msgstr "在二维张量中的父解 (大小: n x d)。"

#: ../../../src/evox/operators/crossover/sbx.py:33
#: ../../../src/evox/operators/crossover/sbx_half.py:33
msgid "Probability of doing crossover."
msgstr "进行交叉的概率。"

#: ../../../src/evox/operators/crossover/sbx.py:34
#: ../../../src/evox/operators/crossover/sbx_half.py:34
msgid "Distribution index of SBX."
msgstr "SBX的分配指数。"

#: ../../../src/evox/operators/crossover/sbx.py:36
#: ../../../src/evox/operators/crossover/sbx_half.py:36
msgid "Offspring solutions after crossover."
msgstr "交叉后的后代解。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:1
msgid "{py:mod}`evox.operators.crossover.sbx_half`"
msgstr "{py:mod}`evox.operators.crossover.sbx_half`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:18
msgid ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"
msgstr ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"

#: ../../../src/evox/operators/crossover/sbx_half.py:20
#: ../../../src/evox/operators/crossover/sbx_half.py:30
msgid ""
"Generate half of the offspring solutions after simulated binary crossover "
"(SBX)."
msgstr "在进行模拟二进制交叉（SBX）后生成一半的后代解。"

#: ../../source/apidocs/evox/evox.operators.mutation.md:1
msgid "{py:mod}`evox.operators.mutation`"
msgstr "{py:mod}`evox.operators.mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:27
msgid "{py:obj}`__all__ <evox.operators.mutation.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.mutation.__all__>`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:39
msgid "['polynomial_mutation']"
msgstr "['polynomial_mutation']"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:1
msgid "{py:mod}`evox.operators.mutation.pm_mutation`"
msgstr "{py:mod}`evox.operators.mutation.pm_mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:18
msgid ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"
msgstr ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"

#: ../../../src/evox/operators/mutation/pm_mutation.py:20
#: ../../../src/evox/operators/mutation/pm_mutation.py:30
msgid "Polynomial mutation. Inspired by PlatEMO."
msgstr "多项式变异。灵感来自 PlatEMO。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:33
msgid "The input population (size: n x d)."
msgstr "输入种群（大小：n x d）。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:36
msgid "Probability of mutation."
msgstr "突变概率。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:37
msgid "The distribution index for polynomial mutation."
msgstr "多项式变异的分布指数。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:39
msgid "The mutated population. (size: n x d)"
msgstr "变异种群。(大小: n x d)"

#: ../../source/apidocs/evox/evox.operators.sampling.md:1
msgid "{py:mod}`evox.operators.sampling`"
msgstr "{py:mod}`evox.operators.sampling`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:29
msgid "{py:obj}`__all__ <evox.operators.sampling.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.sampling.__all__>`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:41
msgid ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."
msgstr ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:1
msgid "{py:mod}`evox.operators.sampling.gird`"
msgstr "{py:mod}`evox.operators.sampling.gird`"

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:18
msgid "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"
msgstr "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"

#: ../../../src/evox/operators/sampling/gird.py:20
#: ../../../src/evox/operators/sampling/gird.py:30
msgid "Grid sampling. Inspired by PlatEMO."
msgstr "网格采样。受PlatEMO启发。"

#: ../../../src/evox/operators/sampling/gird.py:33
msgid "Number of grid points along each axis."
msgstr "每个轴上的网格点数。"

#: ../../../src/evox/operators/sampling/gird.py:34
msgid "Dimensionality of the grid (number of axes)."
msgstr "网格的维度（轴的数量）。"

#: ../../../src/evox/operators/sampling/gird.py:36
msgid "Grid points, and the number of samples."
msgstr "网格点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:1
msgid "{py:mod}`evox.operators.sampling.latin_hypercube`"
msgstr "{py:mod}`evox.operators.sampling.latin_hypercube`"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:18
msgid ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:20
#: ../../../src/evox/operators/sampling/latin_hypercube.py:34
msgid "Generate Latin Hypercube samples in the unit hypercube."
msgstr "在单位超立方体中生成拉丁超立方体样本。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:22
msgid ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:24
#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"Generate Latin Hypercube samples in the given hypercube defined by `lb` and "
"`ub`."
msgstr ""
"**生成拉丁超立方样本**\n"
"\n"
"生成拉丁超立方样本在给定的超立方体中，该超立方体由 `lb` 和 `ub` 定义。\n"
"\n"
"```python\n"
"self.latins = Algorithms.latin_hypercube_sample(self.lb, self.ub, self.population_size)\n"
"```"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:36
#: ../../../src/evox/operators/sampling/latin_hypercube.py:43
msgid "The number of sample points to generate."
msgstr "生成的采样点数量。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:37
#: ../../../src/evox/operators/sampling/latin_hypercube.py:44
msgid "The dimensionality of the samples."
msgstr "样本的维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:38
msgid "The device on which to generate the samples."
msgstr "生成样本的设备。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:39
#: ../../../src/evox/operators/sampling/latin_hypercube.py:47
msgid "Whether to scramble the order of the samples. Defaults to True."
msgstr "是否打乱样本的顺序。默认为 True。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，每列代表一个维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:45
msgid ""
"The lower bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as ub."
msgstr "超立方体的下界。必须是与 `ub` 具有相同形状、数据类型和设备的一维张量。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:46
msgid ""
"The upper bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as lb."
msgstr "超立方体的上界。必须是一个一维张量，其形状、数据类型和设备与 lb 相同。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:49
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension whose device is the same as lb and ub."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，各列代表一个维度，其设备与 lb 和 ub 一致。"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:1
msgid "{py:mod}`evox.operators.sampling.uniform`"
msgstr "{py:mod}`evox.operators.sampling.uniform`"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:18
msgid ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"
msgstr ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"

#: ../../../src/evox/operators/sampling/uniform.py:20
#: ../../../src/evox/operators/sampling/uniform.py:30
msgid ""
"Uniform sampling using Das and Dennis's method, Deb and Jain's method. "
"Inspired by PlatEMO's NBI algorithm."
msgstr "使用Das和Dennis的方法进行均匀采样，Deb和Jain的方法。灵感来源于PlatEMO的NBI算法。"

#: ../../../src/evox/operators/sampling/uniform.py:33
msgid "Number of points to generate."
msgstr "生成的点数。"

#: ../../../src/evox/operators/sampling/uniform.py:34
msgid "Dimensionality of the grid."
msgstr "网格的维度。"

#: ../../../src/evox/operators/sampling/uniform.py:36
msgid "The generated points, and the number of samples."
msgstr "生成的点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.selection.md:1
msgid "{py:mod}`evox.operators.selection`"
msgstr "{py:mod}`evox.operators.selection`"

#: ../../source/apidocs/evox/evox.operators.selection.md:30
msgid "{py:obj}`__all__ <evox.operators.selection.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.selection.__all__>`"

#: ../../source/apidocs/evox/evox.operators.selection.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'nd_environmental_selection', "
"'non_dominate_rank', 'non_do..."
msgstr ""
"['NonDominatedSort', 'crowding_distance', 'nd_environmental_selection', "
"'non_dominate_rank', 'non_do..."

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:1
msgid "{py:mod}`evox.operators.selection.find_pbest`"
msgstr "{py:mod}`evox.operators.selection.find_pbest`"

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:18
msgid ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"
msgstr ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"

#: ../../../src/evox/operators/selection/find_pbest.py:20
#: ../../../src/evox/operators/selection/find_pbest.py:30
msgid ""
"Selects a random personal-best vector from the population for each "
"individual."
msgstr "从种群中为每个个体随机选择一个个人最佳向量。"

#: ../../../src/evox/operators/selection/find_pbest.py:32
msgid ""
"The proportion of the population to consider as best. Must be between 0 and "
"1."
msgstr "种群中考虑为最好的比例。必须在 0 和 1 之间。"

#: ../../../src/evox/operators/selection/find_pbest.py:33
msgid "The population tensor of shape (pop_size, dim)."
msgstr "种群张量，形状为 (pop_size, dim)。"

#: ../../../src/evox/operators/selection/find_pbest.py:34
msgid "The fitness tensor of shape (pop_size,)."
msgstr "适应度张量的形状为 (pop_size,)。"

#: ../../../src/evox/operators/selection/find_pbest.py:36
msgid ""
"A tensor containing the selected personal-best vector for each individual."
msgstr "一个张量，包含每个个体的选择的个人最佳向量。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:1
msgid "{py:mod}`evox.operators.selection.non_dominate`"
msgstr "{py:mod}`evox.operators.selection.non_dominate`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:18
msgid ""
"{py:obj}`NonDominatedSort "
"<evox.operators.selection.non_dominate.NonDominatedSort>`"
msgstr ""
"{py:obj}`NonDominatedSort "
"<evox.operators.selection.non_dominate.NonDominatedSort>`"

#: ../../../src/evox/operators/selection/non_dominate.py:20
#: ../../../src/evox/operators/selection/non_dominate.py:108
msgid ""
"A module for performing non-dominated sorting, implementing caching and "
"support for PyTorch's full map-reduce method."
msgstr "一个用于执行非支配排序的模块，实现了缓存并支持PyTorch的完整映射-归约方法。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:30
msgid ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"
msgstr ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"

#: ../../../src/evox/operators/selection/non_dominate.py:32
#: ../../../src/evox/operators/selection/non_dominate.py:74
msgid ""
"Return the domination relation matrix A, where A_{ij} is True if x_i "
"dominates y_j."
msgstr "返回支配关系矩阵 A，其中 A_{ij} 为 True，如果 x_i 支配 y_j。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:34
msgid ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"
msgstr ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:36
#: ../../../src/evox/operators/selection/non_dominate.py:81
msgid "Update the dominate count and ranks for the current Pareto front."
msgstr "更新当前帕累托前沿的主导计数和等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:38
msgid ""
"{py:obj}`non_dominated_sort_script "
"<evox.operators.selection.non_dominate.non_dominated_sort_script>`"
msgstr ""
"{py:obj}`non_dominated_sort_script "
"<evox.operators.selection.non_dominate.non_dominated_sort_script>`"

#: ../../../src/evox/operators/selection/non_dominate.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:88
msgid "Perform non-dominated sort using PyTorch in torch.script mode."
msgstr "在torch.script模式下使用PyTorch执行非支配排序。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:42
msgid ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"
msgstr ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"

#: ../../../src/evox/operators/selection/non_dominate.py:44
#: ../../../src/evox/operators/selection/non_dominate.py:145
msgid ""
"Compute the crowding distance for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:46
msgid ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"
msgstr ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:48
#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid ""
"Compute the non-domination rank for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的非支配等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:50
msgid ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"
msgstr ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"

#: ../../../src/evox/operators/selection/non_dominate.py:52
#: ../../../src/evox/operators/selection/non_dominate.py:159
msgid ""
"Perform environmental selection based on non-domination rank and crowding "
"distance."
msgstr "基于非支配等级和拥挤距离进行环境选择。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:62
msgid ""
"{py:obj}`_NDS_cache <evox.operators.selection.non_dominate._NDS_cache>`"
msgstr ""
"{py:obj}`_NDS_cache <evox.operators.selection.non_dominate._NDS_cache>`"

#: ../../../src/evox/operators/selection/non_dominate.py:76
msgid ""
"An array with shape (n1, m) where n1 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n1, m) 的数组，其中 n1 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:77
msgid ""
"An array with shape (n2, m) where n2 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n2, m) 的数组，其中 n2 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:79
msgid "The domination relation matrix of x and y."
msgstr "x 和 y 的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:83
msgid "The domination relation matrix between individuals."
msgstr "个体之间的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:84
msgid "The count of how many individuals dominate each individual."
msgstr "每个个体被多少个体所支配的计数。"

#: ../../../src/evox/operators/selection/non_dominate.py:85
msgid "A tensor indicating which individuals are in the current Pareto front."
msgstr "一个张量表示当前帕累托前沿中的个体。"

#: ../../../src/evox/operators/selection/non_dominate.py:86
msgid "A tensor storing the rank of each individual."
msgstr "每个个体的等级的张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:87
msgid "The current Pareto front rank."
msgstr "当前帕累托前沿排名"

#: ../../../src/evox/operators/selection/non_dominate.py:89
msgid ""
"rank: Updated rank tensor.  dominate_count: Updated dominate count tensor."
msgstr ""
"**rank:** 更新的排名张量。\n"
"**dominate_count:** 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:90
msgid "**rank**: Updated rank tensor."
msgstr "**rank**: 更新后的等级张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:91
msgid "**dominate_count**: Updated dominate count tensor."
msgstr "**dominate_count**: 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:90
#: ../../../src/evox/operators/selection/non_dominate.py:131
#: ../../../src/evox/operators/selection/non_dominate.py:139
msgid ""
"An array with shape (n, m) where n is the population size and m is the "
"number of objectives."
msgstr "具有形状 (n, m) 的数组，其中 n 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:92
#: ../../../src/evox/operators/selection/non_dominate.py:133
#: ../../../src/evox/operators/selection/non_dominate.py:141
msgid "A one-dimensional tensor representing the ranking, starting from 0."
msgstr "一个一维张量表示排名，从0开始。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:105
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:30
msgid "Bases: {py:obj}`evox.core.ModuleBase`"
msgstr "Bases: {py:obj}`evox.core.ModuleBase`"

#: ../../../src/evox/operators/selection/non_dominate.py:110
msgid ""
"This class provides an efficient implementation of non-dominated sorting "
"using both direct computation and a traceable map-reduce method for large-"
"scale multi-objective optimization problems."
msgstr "该类提供了一种高效的非支配排序实现，使用直接计算和可追踪的地图-归约方法，适用于大规模多目标优化问题。"

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"This class is designed to automatically identify script and trace modes, "
"with a particular focus on supporting `vmap`. In script mode, use "
"`non_dominated_sort_script`, and in trace mode, use "
"`trace_non_dominated_sort`."
msgstr ""
"该类旨在自动识别脚本和跟踪模式，特别关注支持`vmap`。在脚本模式下，使用`non_dominated_sort_script`，在跟踪模式下，使用`trace_non_dominated_sort"

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"Initialize the NonDominatedSort module, setting up caching for efficient "
"reuse."
msgstr "初始化 NonDominatedSort 模块，为高效重用设置缓存。"

#: ../../../src/evox/operators/selection/non_dominate.py:129
msgid ""
"Perform non-dominated sorting using PyTorch's scripting mechanism for "
"efficient computation."
msgstr "使用 PyTorch 的脚本机制执行非支配排序以提高计算效率。"

#: ../../../src/evox/operators/selection/non_dominate.py:137
msgid ""
"Perform non-dominated sorting using PyTorch's tracing mechanism for "
"efficient computation."
msgstr "使用PyTorch的追踪机制进行非支配排序，以提高计算效率。"

#: ../../../src/evox/operators/selection/non_dominate.py:147
msgid ""
"The crowding distance is a measure of the diversity of solutions within a "
"Pareto front."
msgstr ""
"**Pareto 前景中解的多样性度量：**\n"
"\n"
"**Crowding Distance**\n"
"\n"
"Crowding距离是Pareto前景中解的多样性度量。 \n"
"\n"
"**References**\n"
"\n"
"[1] \n"
"[2]"

#: ../../../src/evox/operators/selection/non_dominate.py:149
#: ../../../src/evox/operators/selection/non_dominate.py:156
#: ../../../src/evox/operators/selection/non_dominate.py:162
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" an objective."
msgstr "一个二维张量，其中每一行代表一个解，每一列代表一个目标。"

#: ../../../src/evox/operators/selection/non_dominate.py:150
msgid "A 1D boolean tensor indicating which solutions should be considered."
msgstr "一个 1D 布尔张量，指示哪些解决方案应该被考虑。"

#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid "A 1D tensor containing the crowding distance for each solution."
msgstr "一个 1D 张量，包含每个解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:154
msgid ""
"The non-domination rank is a measure of the Pareto optimality of each "
"solution."
msgstr "每个解的帕累托最优度被称为非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:158
msgid "A 1D tensor containing the non-domination rank for each solution."
msgstr "一个 1D 张量，包含每个解的非支配排名。"

#: ../../../src/evox/operators/selection/non_dominate.py:161
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" a decision variable."
msgstr "一个二维张量，其中每行代表一个解决方案，每列代表一个决策变量。"

#: ../../../src/evox/operators/selection/non_dominate.py:163
msgid "The number of solutions to select."
msgstr "选择的解的数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:165
msgid ""
"A tuple of four tensors:x: The selected solutions.  f: The corresponding "
"objective values.  rank: The non-domination rank of the selected solutions."
"  crowding_dis: The crowding distance of the selected solutions."
msgstr ""
"一个由四个张量组成的元组：x：选择的解。 f：对应的目标值。 rank：选择的解的非支配等级。 crowding_dis：选择的解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:166
msgid "A tuple of four tensors:"
msgstr "一个包含四个张量的元组："

#: ../../../src/evox/operators/selection/non_dominate.py:167
msgid "**x**: The selected solutions."
msgstr "**x**: 选中的解。"

#: ../../../src/evox/operators/selection/non_dominate.py:168
msgid "**f**: The corresponding objective values."
msgstr "**f**: 对应的目标值。"

#: ../../../src/evox/operators/selection/non_dominate.py:169
msgid "**rank**: The non-domination rank of the selected solutions."
msgstr "**rank**: 演化算法中的非支配等级，即选定的解决方案的非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:170
msgid "**crowding_dis**: The crowding distance of the selected solutions."
msgstr "**crowding_dis**: 所选解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:1
msgid "{py:mod}`evox.operators.selection.rvea_selection`"
msgstr "{py:mod}`evox.operators.selection.rvea_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:18
msgid "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"
msgstr "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:20
#: ../../../src/evox/operators/selection/rvea_selection.py:34
msgid "Compute the APD (Angle-Penalized Distance) based on the given inputs."
msgstr "根据给定的输入计算APD（角惩罚距离）。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:22
msgid ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"
msgstr ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:24
#: ../../../src/evox/operators/selection/rvea_selection.py:41
msgid ""
"Perform the Reference Vector Guided Evolutionary Algorithm (RVEA) selection "
"process."
msgstr "执行参考向量指导演化算法 (RVEA) 选择过程。"

#: ../../../src/evox/operators/selection/rvea_selection.py:36
msgid "A tensor representing the indices of the partition."
msgstr "表示分区索引的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:37
msgid "A tensor representing the gamma."
msgstr "一个表示伽马的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:38
msgid "A tensor representing the angle."
msgstr "表示角度的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:39
msgid "A tensor of shape (n, m) representing the objectives of the solutions."
msgstr "一个形状为 (n, m) 的张量，表示解的目标。"

#: ../../../src/evox/operators/selection/rvea_selection.py:40
msgid ""
"A tensor representing the parameter theta used for scaling the reference "
"vector."
msgstr "一个张量表示用于缩放参考向量的参数 theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:42
msgid "A tensor containing the APD values for each solution."
msgstr "一个包含每个解的 APD 值的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:43
msgid ""
"This function selects solutions based on the Reference Vector Guided "
"Evolutionary Algorithm. It calculates the distances and angles between "
"solutions and reference vectors, and returns the next set of solutions to be"
" evolved."
msgstr "此函数基于参考向量引导的演化算法选择解决方案。它计算解决方案与参考向量之间的距离和角度，并返回下一组待演化的解决方案。"

#: ../../../src/evox/operators/selection/rvea_selection.py:47
msgid ""
"A tensor of shape (n, d) representing the current population solutions."
msgstr "一个形状为 (n, d) 的张量，表示当前种群的解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:48
#: ../../../src/evox/problems/numerical/dtlz.py:68
msgid ""
"A tensor of shape (n, m) representing the objective values for each "
"solution."
msgstr "表示每个解的目标值的张量，以形状 (n, m) 表示。"

#: ../../../src/evox/operators/selection/rvea_selection.py:49
msgid "A tensor of shape (r, m) representing the reference vectors."
msgstr "一个形状为 (r, m) 的张量，表示参考向量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:50
msgid "A tensor representing the parameter theta used in the APD calculation."
msgstr "一个张量，表示在APD计算中使用的参数theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid ""
"A tuple containing:next_x: The next selected solutions.  next_f: The "
"objective values of the next selected solutions."
msgstr "一个元组包含：next_x：下一个选定的解决方案。 next_f：下一个选定的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid "A tuple containing:"
msgstr "一个元组包含："

#: ../../../src/evox/operators/selection/rvea_selection.py:53
msgid "next_x: The next selected solutions."
msgstr "next_x: 下一步选择的解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:54
msgid "next_f: The objective values of the next selected solutions."
msgstr "next_f: 下一个选择的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:57
msgid ""
"The function computes the distances between the solutions and reference "
"vectors, and selects the solutions with the minimum APD. It currently uses a"
" suboptimal selection implementation, and future improvements will optimize "
"the process using a `segment_sort` or `segment_argmin` in CUDA."
msgstr ""
"该函数计算解与参考向量之间的距离，并选择具有最小APD的解。它当前使用的是次优选择实现，未来的改进将使用CUDA中的`segment_sort`或`segment_argmin`来优化该过程。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:1
msgid "{py:mod}`evox.operators.selection.tournament_selection`"
msgstr "{py:mod}`evox.operators.selection.tournament_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:18
msgid ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"
msgstr ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:20
#: ../../../src/evox/operators/selection/tournament_selection.py:34
msgid "Perform tournament selection based on multiple fitness values."
msgstr "基于多个适应度值执行锦标赛选择。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:22
msgid ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"
msgstr ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:24
#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid "Perform tournament selection based on single fitness values."
msgstr "根据单一适应度值执行锦标赛选择。"

#: ../../../src/evox/operators/selection/tournament_selection.py:36
#: ../../../src/evox/operators/selection/tournament_selection.py:43
msgid "Number of rounds of selection (how many solutions to select)."
msgstr "选择轮数（选择多少个解）。"

#: ../../../src/evox/operators/selection/tournament_selection.py:37
msgid ""
"A list of 1D tensors, each representing the fitness values of candidates for"
" different objectives."
msgstr "一个1D张量的列表，每个张量表示不同目标的候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:38
#: ../../../src/evox/operators/selection/tournament_selection.py:45
msgid "Number of candidates in each tournament. Defaults to 2."
msgstr "每个锦标赛中的候选人数量。 默认值为 2。"

#: ../../../src/evox/operators/selection/tournament_selection.py:39
#: ../../../src/evox/operators/selection/tournament_selection.py:46
msgid "Indices of the selected solutions after tournament selection."
msgstr "所选解决方案在锦标赛选择后的索引。"

#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values across multiple objectives."
msgstr "此函数通过随机选择每轮的一组候选者进行锦标赛选择，并根据他们在多个目标上的适应度值从每组中选择最佳者。"

#: ../../../src/evox/operators/selection/tournament_selection.py:44
msgid "A 1D tensor representing the fitness values of candidates."
msgstr "一个一维张量，表示候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:48
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values."
msgstr "此函数通过随机选择每轮的候选者组来执行锦标赛选择，并根据他们的适应度值从每组中选择最佳者。"

#: ../../source/apidocs/evox/evox.problems.md:1
msgid "{py:mod}`evox.problems`"
msgstr "{py:mod}`evox.problems`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:1
msgid "{py:mod}`evox.problems.hpo_wrapper`"
msgstr "{py:mod}`evox.problems.hpo_wrapper`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:18
msgid "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"
msgstr "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:20
#: ../../../src/evox/problems/hpo_wrapper.py:41
msgid ""
"The base class for hyper parameter optimization (HPO) monitors used in "
"`HPOProblem.workflow.monitor`."
msgstr "用于`HPOProblem.workflow.monitor`中的超参数优化（HPO）监控的基类。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:22
msgid ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"
msgstr ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:24
#: ../../../src/evox/problems/hpo_wrapper.py:66
msgid ""
"The monitor for hyper parameter optimization (HPO) that records the best "
"fitness found so far in the optimization process."
msgstr "用于超参数优化（HPO）的监视器，记录在优化过程中迄今为止发现的最佳适应度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:26
msgid ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"
msgstr ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"

#: ../../../src/evox/problems/hpo_wrapper.py:28
#: ../../../src/evox/problems/hpo_wrapper.py:98
msgid "The problem for hyper parameter optimization (HPO)."
msgstr "超参数优化（HPO）问题。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:38
msgid "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"

#: ../../../src/evox/problems/hpo_wrapper.py:55
#: ../../../src/evox/problems/hpo_wrapper.py:87
msgid ""
"Get the best fitness found so far in the optimization process that this "
"monitor is monitoring."
msgstr "在此监控器监控的优化过程中，获取迄今为止找到的最佳适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:57
#: ../../../src/evox/problems/hpo_wrapper.py:89
msgid "The best fitness so far."
msgstr "迄今为止的最佳适应度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:63
msgid "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"
msgstr "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"

#: ../../../src/evox/problems/hpo_wrapper.py:72
msgid "Initialize the HPO fitness monitor."
msgstr "初始化 HPO 适应度监控器。"

#: ../../../src/evox/problems/hpo_wrapper.py:74
msgid ""
"The metric function to use for multi-objective optimization, unused in "
"single-objective optimization. Currently we only support \"IGD\" or \"HV\" "
"for multi-objective optimization. Defaults to None."
msgstr "用于多目标优化的度量函数，在单目标优化中不使用。目前，我们仅支持多目标优化的“IGD”或“HV”。默认为None。"

#: ../../../src/evox/problems/hpo_wrapper.py:79
msgid ""
"Update the best fitness value found so far based on the provided fitness "
"tensor and multi-objective metric."
msgstr "根据提供的适应度张量和多目标度量更新迄今为止找到的最佳适应度值。"

#: ../../../src/evox/problems/hpo_wrapper.py:81
msgid ""
"A tensor representing fitness values. It can be either a 1D tensor for "
"single-objective optimization or a 2D tensor for multi-objective "
"optimization."
msgstr "表示适应度值的张量。对于单目标优化，它可以是一个一维张量；对于多目标优化，它可以是一个二维张量。"

#: ../../../src/evox/problems/hpo_wrapper.py:83
msgid "If the dimensionality of the fitness tensor is not 1 or 2."
msgstr "如果适应度张量的维度不是1或2。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:97
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:67
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:86
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:48
msgid "Bases: {py:obj}`evox.core.Problem`"
msgstr "Bases: {py:obj}`evox.core.Problem`"

#: ../../../src/evox/problems/hpo_wrapper.py:104
msgid "Initialize the HPO problem wrapper."
msgstr "初始化 HPO 问题包装器。"

#: ../../../src/evox/problems/hpo_wrapper.py:106
msgid "The number of iterations to be executed in the optimization process."
msgstr "在优化过程中要执行的迭代次数。"

#: ../../../src/evox/problems/hpo_wrapper.py:107
msgid ""
"The number of instances to be executed in parallel in the optimization "
"process."
msgstr "在优化过程中并行执行的实例数量。"

#: ../../../src/evox/problems/hpo_wrapper.py:108
msgid ""
"The workflow to be used in the optimization process. Must be wrapped by "
"core.jit_class."
msgstr "在优化过程中使用的工作流。必须由 core.jit_class 包装。"

#: ../../../src/evox/problems/hpo_wrapper.py:109
msgid ""
"Whether to copy the initial state of the workflow for each evaluation. "
"Defaults to True. If your workflow contains operations that IN-PLACE modify "
"the tensor(s) in initial state, this should be set to True. Otherwise, you "
"can set it to False to save memory."
msgstr ""
"是否为每次评估复制工作流的初始状态。默认为 True。如果您的工作流包含对初始状态中的张量进行原地修改的操作，则应将其设置为 "
"True。否则，您可以将其设置为 False 以节省内存。"

#: ../../../src/evox/problems/hpo_wrapper.py:111
msgid ""
"Evaluate the fitness (given by the internal workflow's monitor) of the batch"
" of hyper parameters by running the internal workflow."
msgstr "评估一批超参数的适应度（由内部工作流的监控器提供），通过运行内部工作流。"

#: ../../../src/evox/problems/hpo_wrapper.py:113
msgid "The hyper parameters to evaluate."
msgstr "需要评估的超参数。"

#: ../../../src/evox/problems/hpo_wrapper.py:115
msgid "The final fitness of the hyper parameters."
msgstr "最终的超参数适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:119
msgid ""
"Return the initial hyper-parameters dictionary of the underlying workflow."
msgstr "返回底层工作流的初始超参数字典。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:1
msgid "{py:mod}`evox.problems.neuroevolution`"
msgstr "{py:mod}`evox.problems.neuroevolution`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:1
msgid "{py:mod}`evox.problems.neuroevolution.brax`"
msgstr "{py:mod}`evox.problems.neuroevolution.brax`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:18
msgid "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"
msgstr "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"

#: ../../../src/evox/problems/neuroevolution/brax.py:20
#: ../../../src/evox/problems/neuroevolution/brax.py:100
msgid "The Brax problem wrapper."
msgstr "Brax 问题封装器。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:30
msgid ""
"{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"
msgstr ""
"{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:34
msgid ""
"{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"
msgstr ""
"{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:46
msgid "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"
msgstr "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:50
msgid ""
"{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"
msgstr ""
"{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:62
msgid "['BraxProblem']"
msgstr "['BraxProblem']"

#: ../../../src/evox/problems/neuroevolution/brax.py:106
msgid ""
"Construct a Brax-based problem. Firstly, you need to define a policy model. "
"Then you need to set the `environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`, the maximum episode "
"length, the number of episodes to evaluate for each individual. For each "
"individual, it will run the policy with the environment for num_episodes "
"times with different seed, and use the reduce_fn to reduce the rewards "
"(default to average). Different individuals will share the same set of "
"random keys in each iteration."
msgstr ""
"构建一个基于 Brax 的问题。首先，您需要定义一个策略模型。然后，您需要设置`environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`，最大 episode "
"长度，以及用于评估每个个体的 episode 数量。对于每个个体，它将在环境中运行策略 num_episodes 次，每次使用不同的种子，并使用 "
"reduce_fn 函数对奖励进行归约（默认为取平均值）。在每次迭代中，不同个体将共享同一组随机键。"

#: ../../../src/evox/problems/neuroevolution/brax.py:115
msgid ""
"The policy model whose forward function is :code:forward(batched_obs) -> "
"action."
msgstr "该策略模型的前向函数是: `forward(batched_obs) -> action"

#: ../../../src/evox/problems/neuroevolution/brax.py:116
msgid "The environment name."
msgstr "环境名。"

#: ../../../src/evox/problems/neuroevolution/brax.py:117
msgid "The maximum number of time steps of each episode."
msgstr "每个episode的最大时间步数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:118
msgid "The number of episodes to evaluate for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:119
msgid ""
"The size of the population to be evaluated. If None, we expect the input to "
"have a population size of 1."
msgstr "要评估的种群大小。如果为 None，我们期望输入的种群大小为 1。"

#: ../../../src/evox/problems/neuroevolution/brax.py:120
msgid ""
"Indicates whether to rotate the random key for each iteration (default is "
"True). <br/> If True, the random key will rotate after each iteration, "
"resulting in non-deterministic and potentially noisy fitness evaluations. "
"This means that identical policy weights may yield different fitness values "
"across iterations. <br/> If False, the random key remains the same for all "
"iterations, ensuring consistent fitness evaluations."
msgstr ""
"表示是否在每次迭代中旋转随机键（默认为 True）。<br/> 如果为 "
"True，随机键将在每次迭代后旋转，从而导致非确定性且可能有噪声的适应度评估。这意味着相同的策略权重在不同迭代中可能会产生不同的适应度值。<br/> "
"如果为 False，随机键在所有迭代中保持不变，以确保适应度评估的一致性。"

#: ../../../src/evox/problems/neuroevolution/brax.py:121
msgid ""
"The function to reduce the rewards of multiple episodes. Default to "
"torch.mean."
msgstr "用于减少多个episode奖励的函数。默认值为torch.mean。"

#: ../../../src/evox/problems/neuroevolution/brax.py:122
msgid ""
"Brax's backend. If None, the default backend of the environment will be "
"used. Default to None."
msgstr "Brax 的后端。如果为 None，将使用环境的默认后端。默认为 None。"

#: ../../../src/evox/problems/neuroevolution/brax.py:123
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:82
msgid ""
"The device to run the computations on. Defaults to the current default "
"device."
msgstr "用于运行计算的设备。默认为当前默认设备。"

#: ../../../src/evox/problems/neuroevolution/brax.py:125
#: ../../../src/evox/workflows/std_workflow.py:75
msgid "Notice"
msgstr "注意"

#: ../../../src/evox/problems/neuroevolution/brax.py:126
msgid "The initial key is obtained from `torch.random.get_rng_state()`."
msgstr "初始密钥是从 `torch.random.get_rng_state()` 获得的。"

#: ../../../src/evox/problems/neuroevolution/brax.py:129
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:87
msgid ""
"This problem does NOT support HPO wrapper "
"(`problems.hpo_wrapper.HPOProblemWrapper`), i.e., the workflow containing "
"this problem CANNOT be vmapped."
msgstr ""
"此问题不支持 HPO 包装器 (`problems.hpo_wrapper.HPOProblemWrapper`)，即包含此问题的工作流不能被 "
"vmapped。"

#: ../../../src/evox/problems/neuroevolution/brax.py:131
#: ../../source/guide/developer/1-modulebase.md:126 ../../source/index.md:22
msgid "Examples"
msgstr "示例"

#: ../../../src/evox/problems/neuroevolution/brax.py:132
msgid ""
"from evox import problems problem = problems.neuroevolution.Brax( ...    "
"env_name=\"swimmer\", ...    policy=model, ...    max_episode_length=1000, "
"...    num_episodes=3, ...    pop_size=100, ...    rotate_key=False, ...)"
msgstr ""
"from evox import problems\n"
"problem = problems.neuroevolution.Brax(\n"
"    ...    env_name=\"swimmer\",\n"
"    ...    policy=model,\n"
"    ...    max_episode_length=1000,\n"
"    ...    num_episodes=3,\n"
"    ...    pop_size=100,\n"
"    ...    rotate_key=False,\n"
"...)"

#: ../../../src/evox/problems/neuroevolution/brax.py:113
msgid ""
"Evaluate the final rewards of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批量）的最终奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:115
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:125
msgid ""
"A dictionary of parameters where each key is a parameter name and each value"
" is a tensor of shape (batch_size, *param_shape) representing the batched "
"parameters of batched models."
msgstr "参数字典，其中每个键是参数名称，每个值是形状为 (batch_size, *param_shape) 的张量，表示批量模型的批量参数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:117
msgid ""
"A tensor of shape (batch_size,) containing the reward of each sample in the "
"population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:137
msgid "Visualize the brax environment with the given policy and weights."
msgstr "可视化带有指定策略和权重的brax环境。"

#: ../../../src/evox/problems/neuroevolution/brax.py:139
msgid "The weights of the policy model. Which is a dictionary of parameters."
msgstr "策略模型的权重。这是一个参数字典。"

#: ../../../src/evox/problems/neuroevolution/brax.py:140
msgid ""
"The output type of the visualization, \"HTML\" or \"rgb_array\". Default to "
"\"HTML\"."
msgstr "可视化的输出类型，“HTML”或“rgb_array”。默认为“HTML”。"

#: ../../../src/evox/problems/neuroevolution/brax.py:142
msgid "The visualization output."
msgstr "可视化输出。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:1
msgid "{py:mod}`evox.problems.neuroevolution.supervised_learning`"
msgstr "{py:mod}`evox.problems.neuroevolution.supervised_learning`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:18
msgid ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"
msgstr ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:20
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:70
msgid ""
"The supervised learning problem to test a model's parameters or a batch of "
"parameters with given data and criterion."
msgstr "监督学习问题是使用给定的数据和标准来测试模型参数或一批参数。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:30
msgid ""
"{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"
msgstr ""
"{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:34
msgid ""
"{py:obj}`__supervised_data__ "
"<evox.problems.neuroevolution.supervised_learning.__supervised_data__>`"
msgstr ""
"{py:obj}`__supervised_data__ "
"<evox.problems.neuroevolution.supervised_learning.__supervised_data__>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:46
msgid "['SupervisedLearningProblem']"
msgstr "['监督学习问题']"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:76
msgid "Initialize the `SupervisedLearningProblem`."
msgstr "初始化 `SupervisedLearningProblem`。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:78
msgid "The neural network model whose parameters need to be evaluated."
msgstr "需要评估参数的神经网络模型。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:79
msgid "The data loader providing the dataset for evaluation."
msgstr "用于评估的数据加载器提供数据集。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:80
msgid "The loss function used to evaluate the parameters' performance."
msgstr "用于评估参数性能的损失函数。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:81
msgid ""
"The size of the population (batch size of the parameters) to be evaluated. "
"Defaults to None for single-run mode."
msgstr "种群的大小（参数的批量大小）需要进行评估。默认为 None，表示单次运行模式。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:84
msgid "If the data loader contains no items."
msgstr "如果数据加载器不包含任何项目。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:123
msgid "Evaluate the fitness of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批次）的适应度。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:127
msgid ""
"A tensor of shape (batch_size,) containing the fitness of each sample in the"
" population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的适应度。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:1
msgid "{py:mod}`evox.problems.neuroevolution.utils`"
msgstr "{py:mod}`evox.problems.neuroevolution.utils`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:18
msgid ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"
msgstr ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:30
msgid ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"
msgstr ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"

#: ../../../src/evox/problems/neuroevolution/utils.py:32
#: ../../../src/evox/problems/neuroevolution/utils.py:107
msgid ""
"Get model state forward function for vmap and non-vmap models. When "
"`get_non_vmap` is False, the function returns only vmap model state forward "
"function. When `get_non_vmap` is True, the function returns both vmap and "
"non-vmap model state forward functions."
msgstr ""
"获取用于 vmap 和非 vmap 模型的模型状态前向函数。当 `get_non_vmap` 为 False 时，该函数仅返回 vmap "
"模型状态前向函数。当 `get_non_vmap` 为 True 时，该函数返回 vmap 和非 vmap 模型状态前向函数。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:42
msgid "Bases: {py:obj}`typing.NamedTuple`"
msgstr "Bases: {py:obj}`typing.NamedTuple`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:1
msgid "{py:mod}`evox.problems.numerical`"
msgstr "{py:mod}`evox.problems.numerical`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:29
msgid "{py:obj}`__all__ <evox.problems.numerical.__all__>`"
msgstr "{py:obj}`__all__ <evox.problems.numerical.__all__>`"

#: ../../source/apidocs/evox/evox.problems.numerical.md:41
msgid ""
"['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
"'CEC2022', 'DTLZ1', 'DTLZ2',..."
msgstr ""
"['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
"'CEC2022', 'DTLZ1', 'DTLZ2',..."

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:1
msgid "{py:mod}`evox.problems.numerical.basic`"
msgstr "{py:mod}`evox.problems.numerical.basic`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:18
msgid ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"
msgstr ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"

#: ../../../src/evox/problems/numerical/basic.py:20
#: ../../../src/evox/problems/numerical/basic.py:89
msgid ""
"A numerical problem with a shift and affine transformations to the input "
"points."
msgstr "一个数值问题，包含对输入点的平移和仿射变换。"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:22
msgid "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"
msgstr "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"

#: ../../../src/evox/problems/numerical/basic.py:24
#: ../../../src/evox/problems/numerical/basic.py:120
msgid "The Ackley function whose minimum is x = [0, ..., 0]"
msgstr "Ackley 函数的最小值为 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:26
msgid "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"
msgstr "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"

#: ../../../src/evox/problems/numerical/basic.py:28
#: ../../../src/evox/problems/numerical/basic.py:151
msgid "The Griewank function whose minimum is x = [0, ..., 0]"
msgstr "Griewank 函数的最小值是 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:30
msgid "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"
msgstr "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"

#: ../../../src/evox/problems/numerical/basic.py:32
#: ../../../src/evox/problems/numerical/basic.py:182
msgid "The Rastrigin function whose minimum is x = [0, ..., 0]"
msgstr "Rastrigin 函数的最小值是 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:34
msgid "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"
msgstr "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"

#: ../../../src/evox/problems/numerical/basic.py:36
#: ../../../src/evox/problems/numerical/basic.py:213
msgid "The Rosenbrock function whose minimum is x = [1, ..., 1]"
msgstr "Rosenbrock 函数的最小值为 x = [1, ..., 1]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:38
msgid "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"
msgstr "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"

#: ../../../src/evox/problems/numerical/basic.py:40
#: ../../../src/evox/problems/numerical/basic.py:244
msgid "The Schwefel function whose minimum is x = [420.9687, ..., 420.9687]"
msgstr "Schwefel 函数的最小值为 x = [420.9687, ..., 420.9687]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:42
msgid "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"
msgstr "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"

#: ../../../src/evox/problems/numerical/basic.py:44
#: ../../../src/evox/problems/numerical/basic.py:275
msgid "The sphere function whose minimum is x = [0, ..., 0]"
msgstr "球体函数（sphere function），其最小值为 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:54
msgid "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"
msgstr "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:58
msgid "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"
msgstr "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:62
msgid ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"
msgstr ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:66
msgid ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"
msgstr ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:70
msgid "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"
msgstr "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:74
msgid "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"
msgstr "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"

#: ../../../src/evox/problems/numerical/basic.py:95
msgid "Initialize the ShiftAffineNumericalProblem."
msgstr "初始化 ShiftAffineNumericalProblem。"

#: ../../../src/evox/problems/numerical/basic.py:97
msgid "The shift vector. Defaults to None. None represents no shift."
msgstr "偏移向量。默认为 None。None 表示没有偏移。"

#: ../../../src/evox/problems/numerical/basic.py:98
msgid ""
"The affine transformation matrix. Defaults to None. None represents no "
"affine transformation."
msgstr "仿射变换矩阵。默认为 None。None 表示没有仿射变换。"

#: ../../../src/evox/problems/numerical/basic.py:102
msgid ""
"Evaluate the given population by shifting and applying an affine "
"transformation to the input points first, and then evaluating the points "
"with the actual function."
msgstr "首先对给定的种群进行平移和仿射变换，然后用实际函数评估这些点。"

#: ../../../src/evox/problems/numerical/basic.py:104
msgid "The population of points to evaluate."
msgstr "要评估的点的种群。"

#: ../../../src/evox/problems/numerical/basic.py:106
msgid "The evaluated fitness of the population."
msgstr "种群的适应度评估结果。"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:117
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:148
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:179
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:210
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:241
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:272
msgid ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"
msgstr ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"

#: ../../../src/evox/problems/numerical/basic.py:126
msgid "Initialize the Ackley function with the given parameters."
msgstr "用给定的参数初始化 Ackley 函数。"

#: ../../../src/evox/problems/numerical/basic.py:128
msgid "The parameter a in the equation. Defaults to 20.0."
msgstr "方程中的参数a。默认值为20.0。"

#: ../../../src/evox/problems/numerical/basic.py:129
msgid "The parameter b in the equation. Defaults to 0.2."
msgstr "方程中的参数 b。默认值为 0.2。"

#: ../../../src/evox/problems/numerical/basic.py:130
msgid "The parameter c in the equation. Defaults to 2 * pi."
msgstr "方程中的参数c。默认值为2 * pi。"

#: ../../../src/evox/problems/numerical/basic.py:131
#: ../../../src/evox/problems/numerical/basic.py:159
#: ../../../src/evox/problems/numerical/basic.py:190
#: ../../../src/evox/problems/numerical/basic.py:221
#: ../../../src/evox/problems/numerical/basic.py:252
#: ../../../src/evox/problems/numerical/basic.py:283
msgid ""
"The keyword arguments (shift and affine) to pass to the superclass "
"ShiftAffineNumericalProblem."
msgstr "传递给超类 ShiftAffineNumericalProblem 的关键字参数（shift 和 affine）。"

#: ../../../src/evox/problems/numerical/basic.py:157
#: ../../../src/evox/problems/numerical/basic.py:188
#: ../../../src/evox/problems/numerical/basic.py:219
#: ../../../src/evox/problems/numerical/basic.py:250
#: ../../../src/evox/problems/numerical/basic.py:281
msgid "Initialize the Griewank function with the given parameters."
msgstr "用给定的参数初始化 Griewank 函数。"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:1
msgid "{py:mod}`evox.problems.numerical.cec2022`"
msgstr "{py:mod}`evox.problems.numerical.cec2022`"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:18
msgid "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"
msgstr "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"

#: ../../../src/evox/problems/numerical/cec2022.py:20
#: ../../../src/evox/problems/numerical/cec2022.py:33
msgid "The CEC 2022 single-objective test suite Problem"
msgstr "CEC 2022 单目标测试套件问题"

#: ../../../src/evox/problems/numerical/cec2022.py:39
msgid ""
"Initialize a single test function instance from the CEC2022 test suite."
msgstr "从CEC2022测试套件初始化一个单一测试函数实例。"

#: ../../../src/evox/problems/numerical/cec2022.py:41
msgid ""
"Args:     problem_number (`int`): The index for the specific test function "
"to be used. Must be ranged from 1 to 12.     dimension (`int`): The "
"dimensionality of the problem. Must be one of [2, 10, 20].     device "
"(`torch.device`, optional): The device on which tensors will be allocated. "
"Defaults to None."
msgstr ""
"Args:     \n"
"- problem_number (`int`): 要使用的特定测试函数的索引。必须在1到12之间。\n"
"- dimension (`int`): 问题的维度。必须是[2, 10, 20]之一。\n"
"- device (`torch.device`, optional): 分配张量的设备。默认为None。"

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid ""
"Raises:     AssertionError: If the dimension is not one of the allowed "
"values or if the function is not defined.     FileNotFoundError: If the "
"necessary data files for the problem are not found."
msgstr ""
"引发：  \n"
"    AssertionError: 如果维度不是允许的值之一或函数未定义。  \n"
"    FileNotFoundError: 如果问题所需的数据文件未找到。"

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid "Shift the input vector."
msgstr "将输入向量移位。"

#: ../../../src/evox/problems/numerical/cec2022.py:54
msgid "Rotate the input vector."
msgstr "旋转输入向量。"

#: ../../../src/evox/problems/numerical/cec2022.py:70
msgid "Shift and rotate function with rate."
msgstr "平移和旋转函数与速率。"

#: ../../../src/evox/problems/numerical/cec2022.py:86
msgid "Zakharov Function"
msgstr "Zakharov 函数"

#: ../../../src/evox/problems/numerical/cec2022.py:94
msgid "Rosenbrock Function"
msgstr "Rosenbrock Function  \n"

#: ../../../src/evox/problems/numerical/cec2022.py:102
msgid "Schaffer F7 Function"
msgstr "Schaffer F7 函数"

#: ../../../src/evox/problems/numerical/cec2022.py:110
msgid "Step Rastrigin Function (Noncontinuous Rastrigin's)"
msgstr "Rastrigin 函数步骤（不连续的 Rastrigin's）"

#: ../../../src/evox/problems/numerical/cec2022.py:118
msgid "Levy Function"
msgstr ""
"Levy Function  \n"
"Levy Function"

#: ../../../src/evox/problems/numerical/cec2022.py:126
msgid "Hybrid Function 2"
msgstr "混合函数2"

#: ../../../src/evox/problems/numerical/cec2022.py:134
msgid "Hybrid Function 10"
msgstr "混合函数 10"

#: ../../../src/evox/problems/numerical/cec2022.py:142
msgid "Hybrid Function 6"
msgstr "混合函数6"

#: ../../../src/evox/problems/numerical/cec2022.py:150
msgid "Composition Function 1"
msgstr "Composition Function 1"

#: ../../../src/evox/problems/numerical/cec2022.py:158
msgid "Composition Function 2"
msgstr "Composition Function 2"

#: ../../../src/evox/problems/numerical/cec2022.py:166
msgid "Composition Function 6"
msgstr "Composition Function 6"

#: ../../../src/evox/problems/numerical/cec2022.py:174
msgid "Composition Function 7"
msgstr "Composition Function 7"

#: ../../../src/evox/problems/numerical/cec2022.py:182
msgid "Problem number = 1."
msgstr "问题编号 = 1。"

#: ../../../src/evox/problems/numerical/cec2022.py:190
msgid "Problem number = 4."
msgstr "问题编号 = 4。"

#: ../../../src/evox/problems/numerical/cec2022.py:198
msgid "Problem number = 5."
msgstr "问题编号 = 5。"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:1
msgid "{py:mod}`evox.problems.numerical.dtlz`"
msgstr "{py:mod}`evox.problems.numerical.dtlz`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:18
msgid "{py:obj}`DTLZTestSuit <evox.problems.numerical.dtlz.DTLZTestSuit>`"
msgstr "{py:obj}`DTLZTestSuit <evox.problems.numerical.dtlz.DTLZTestSuit>`"

#: ../../../src/evox/problems/numerical/dtlz.py:20
#: ../../../src/evox/problems/numerical/dtlz.py:51
msgid ""
"Base class for DTLZ test suite problems in multi-objective optimization."
msgstr "用于多目标优化中DTLZ测试套件问题的基类。"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:22
msgid "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"
msgstr "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:24
msgid "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"
msgstr "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:26
msgid "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"
msgstr "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:30
msgid "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"
msgstr "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:34
msgid "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"
msgstr "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:36
msgid "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"
msgstr "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:38
msgid "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"
msgstr "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"

#: ../../../src/evox/problems/numerical/dtlz.py:53
msgid "Inherit this class to implement specific DTLZ problem variants."
msgstr "继承此类以实现特定的DTLZ问题变体。"

#: ../../../src/evox/problems/numerical/dtlz.py:55
msgid "Number of decision variables."
msgstr "决策变量的数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:56
msgid "Number of objectives."
msgstr "目标数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Number of reference points used in the problem."
msgstr "问题中使用的参考点数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Override the setup method to initialize the parameters"
msgstr "重写 `setup` 方法以初始化参数。"

#: ../../../src/evox/problems/numerical/dtlz.py:65
msgid ""
"Abstract method to evaluate the objective values for given decision "
"variables."
msgstr "抽象方法用于评估给定决策变量的目标值。"

#: ../../../src/evox/problems/numerical/dtlz.py:67
msgid ""
"A tensor of shape (n, d), where n is the number of solutions and d is the "
"number of decision variables."
msgstr "形状为 (n, d) 的张量，其中 n 是解的数量，d 是决策变量的数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:73
msgid "Return the Pareto front for the problem."
msgstr "返回问题的帕累托前沿。"

#: ../../../src/evox/problems/numerical/dtlz.py:75
msgid "A tensor representing the Pareto front."
msgstr "表示帕累托前沿的张量。"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:81
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:93
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:158
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:175
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:192
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZTestSuit`"
msgstr "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZTestSuit`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:110
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:134
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"
msgstr "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"

#: ../../source/apidocs/evox/evox.utils.md:1
msgid "{py:mod}`evox.utils`"
msgstr "{py:mod}`evox.utils`"

#: ../../source/apidocs/evox/evox.utils.md:29
msgid "{py:obj}`__all__ <evox.utils.__all__>`"
msgstr "{py:obj}`__all__ <evox.utils.__all__>`"

#: ../../source/apidocs/evox/evox.utils.md:41
msgid ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."
msgstr ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."

#: ../../source/apidocs/evox/evox.utils.control_flow.md:1
msgid "{py:mod}`evox.utils.control_flow`"
msgstr "{py:mod}`evox.utils.control_flow`"

#: ../../source/apidocs/evox/evox.utils.control_flow.md:18
msgid "{py:obj}`__all__ <evox.utils.control_flow.__all__>`"
msgstr "{py:obj}`__all__ <evox.utils.control_flow.__all__>`"

#: ../../source/apidocs/evox/evox.utils.control_flow.md:30
msgid "['TracingCond', 'TracingWhile', 'TracingSwitch']"
msgstr "['TracingCond', 'TracingWhile', 'TracingSwitch']"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:1
msgid "{py:mod}`evox.utils.jit_fix_operator`"
msgstr "{py:mod}`evox.utils.jit_fix_operator`"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:18
msgid "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"
msgstr "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"

#: ../../../src/evox/utils/jit_fix_operator.py:20
#: ../../../src/evox/utils/jit_fix_operator.py:82
msgid ""
"Element-wise switch select operator that generates a tensor from a list of "
"tensors based on the label tensor."
msgstr "基于标签张量从张量列表中生成张量的逐元素切换选择运算符。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:22
msgid "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"
msgstr "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"

#: ../../../src/evox/utils/jit_fix_operator.py:24
#: ../../../src/evox/utils/jit_fix_operator.py:89
msgid ""
"Clamp the values of the input tensor `a` to be within the given lower (`lb`)"
" and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的值限制在给定的下界 (`lb`) 和上界 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:26
msgid "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"
msgstr "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:28
#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"Clamp the float values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的浮点值限制在给定的下界 (`lb`) 和上界 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:30
msgid "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"
msgstr "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:32
#: ../../../src/evox/utils/jit_fix_operator.py:103
msgid ""
"Clamp the int values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的整数值限制在给定的下限 (`lb`) 和上限 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:34
msgid "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"
msgstr "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"

#: ../../../src/evox/utils/jit_fix_operator.py:36
#: ../../../src/evox/utils/jit_fix_operator.py:110
msgid "Clip the values of the input tensor `a` to be within the range [0, 1]."
msgstr "将输入张量 `a` 的值裁剪到 [0, 1] 范围内。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:38
msgid "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"
msgstr "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"

#: ../../../src/evox/utils/jit_fix_operator.py:40
#: ../../../src/evox/utils/jit_fix_operator.py:117
msgid "Element-wise maximum of two input tensors `a` and `b`."
msgstr "两个输入张量 `a` 和 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:42
msgid "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"
msgstr "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"

#: ../../../src/evox/utils/jit_fix_operator.py:44
#: ../../../src/evox/utils/jit_fix_operator.py:124
msgid "Element-wise minimum of two input tensors `a` and `b`."
msgstr "两个输入张量 `a` 和 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:46
msgid "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"
msgstr "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:48
#: ../../../src/evox/utils/jit_fix_operator.py:131
msgid "Element-wise maximum of input tensor `a` and float `b`."
msgstr "输入张量 `a` 和浮点数 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:50
msgid "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"
msgstr "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:52
#: ../../../src/evox/utils/jit_fix_operator.py:138
msgid "Element-wise minimum of input tensor `a` and float `b`."
msgstr "输入张量 `a` 和浮点数 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:54
msgid "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"
msgstr "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:145
msgid "Element-wise maximum of input tensor `a` and int `b`."
msgstr "输入张量 `a` 和整数 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:58
msgid "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"
msgstr "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:60
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "Element-wise minimum of input tensor `a` and int `b`."
msgstr "输入张量 `a` 和整数 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:62
msgid "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"
msgstr "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"

#: ../../../src/evox/utils/jit_fix_operator.py:64
#: ../../../src/evox/utils/jit_fix_operator.py:159
msgid ""
"Perform lexicographical sorting of multiple tensors, considering each tensor"
" as a key."
msgstr "对多个张量进行字典序排序，将每个张量视为一个键。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:66
msgid "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"
msgstr "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"

#: ../../../src/evox/utils/jit_fix_operator.py:68
#: ../../../src/evox/utils/jit_fix_operator.py:166
msgid ""
"Compute the minimum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr "计算张量在指定维度上的最小值，忽略NaN值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:70
msgid "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"
msgstr "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"

#: ../../../src/evox/utils/jit_fix_operator.py:72
#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"Compute the maximum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr "计算张量在指定维度上的最大值，忽略NaN值。"

#: ../../../src/evox/utils/jit_fix_operator.py:84
msgid ""
"A tensor containing labels used to select from the list of tensors. Must be "
"broadcastable to the shape of rest arguments."
msgstr "一个张量，包含用于从张量列表中选择的标签。必须可以广播到其余参数的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:85
msgid ""
"A list of tensors from which one is selected based on the label. All tensors"
" in the list must be broadcastable to the same shape."
msgstr "根据标签从中选择的张量列表。列表中的所有张量必须可以广播到相同的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:88
msgid ""
"A tensor where each element is selected from the list of tensors based on "
"the corresponding element in the label tensor."
msgstr "一个张量，其中每个元素都是根据标签张量中的相应元素从张量列表中选择的。"

#: ../../../src/evox/utils/jit_fix_operator.py:91
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"the corresponding element of `lb` and not greater than the corresponding "
"element of `ub`."
msgstr "此函数确保张量 `a` 的每个元素不小于 `lb` 的相应元素且不大于 `ub` 的相应元素。"

#: ../../../src/evox/utils/jit_fix_operator.py:95
#: ../../../src/evox/utils/jit_fix_operator.py:101
#: ../../../src/evox/utils/jit_fix_operator.py:108
msgid ""
"This is a fix function for "
"[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html) "
"since it is not supported in JIT operator fusion."
msgstr ""
"这是一个用于[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html)的修复函数，因为它在JIT操作符融合中不被支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a`, `lb` or `ub` is a"
" float tensor and may suffer from numerical precision losses. Please use "
"`torch.clamp` instead if a precise clamp is required."
msgstr ""
"这不是`torch.clamp`的精确复制，如果`a`、`lb`或`ub`是浮点张量，可能会遭受数值精度损失。如果需要精确的限制，请使用`torch.clamp"

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:104
#: ../../../src/evox/utils/jit_fix_operator.py:111
msgid "The input tensor to be clamped."
msgstr "要被限制的输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:99
msgid "The lower bound tensor. Must be broadcastable to the shape of a."
msgstr "下界张量。必须可以广播到 a 的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:100
msgid "The upper bound tensor. Must be broadcastable to the shape of a."
msgstr "上界张量。必须可以广播到a的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:102
#: ../../../src/evox/utils/jit_fix_operator.py:108
#: ../../../src/evox/utils/jit_fix_operator.py:115
msgid ""
"A tensor where each element is clamped to be within the specified bounds."
msgstr "张量，其中每个元素都被限制在指定的界限内。"

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:105
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"`lb` and not greater than `ub`."
msgstr "此函数确保张量 `a` 的每个元素不小于 `lb` 且不大于 `ub"

#: ../../../src/evox/utils/jit_fix_operator.py:102
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a float tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""
"这不是`torch.clamp`的精确复制，如果`a`是浮点张量，可能会遭受数值精度损失。如果需要精确的限制，请使用`torch.clamp"

#: ../../../src/evox/utils/jit_fix_operator.py:105
#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid ""
"The lower bound value. Each element of a will be clamped to be not less than"
" lb."
msgstr "下界值。a 的每个元素将被限制为不小于 lb。"

#: ../../../src/evox/utils/jit_fix_operator.py:106
#: ../../../src/evox/utils/jit_fix_operator.py:113
msgid ""
"The upper bound value. Each element of a will be clamped to be not greater "
"than ub."
msgstr "上限值。a 的每个元素将被限制为不大于 ub。"

#: ../../../src/evox/utils/jit_fix_operator.py:109
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a int tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""
"这不是`torch.clamp`的精确复制，如果`a`是一个整数张量，可能会遭受数值精度损失。如果需要精确的限制，请使用`torch.clamp"

#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid "Notice: This function invokes `clamp(a, 0, 1)`."
msgstr "注意：此函数调用 `clamp(a, 0, 1)"

#: ../../../src/evox/utils/jit_fix_operator.py:114
msgid "The input tensor to be clipped."
msgstr "要裁剪的输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:116
msgid "A tensor where each element is clipped to be within [0, 1]."
msgstr "一个张量，其中每个元素都被限制在 [0, 1] 范围内。"

#: ../../../src/evox/utils/jit_fix_operator.py:119
#: ../../../src/evox/utils/jit_fix_operator.py:133
#: ../../../src/evox/utils/jit_fix_operator.py:147
msgid ""
"Notice: This is a fix function for "
"[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""
"注意：这是一个用于[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html)的修复函数，因为它在JIT操作符融合中不支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:121
#: ../../../src/evox/utils/jit_fix_operator.py:128
#: ../../../src/evox/utils/jit_fix_operator.py:135
#: ../../../src/evox/utils/jit_fix_operator.py:143
#: ../../../src/evox/utils/jit_fix_operator.py:149
#: ../../../src/evox/utils/jit_fix_operator.py:157
msgid "The first input tensor."
msgstr "第一个输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:122
#: ../../../src/evox/utils/jit_fix_operator.py:129
msgid "The second input tensor."
msgstr "第二个输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:124
#: ../../../src/evox/utils/jit_fix_operator.py:138
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "The element-wise maximum of a and b."
msgstr "a 和 b 的逐元素最大值。"

#: ../../../src/evox/utils/jit_fix_operator.py:126
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""
"注意：这是一个用于[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)的修复函数，因为它在JIT操作符融合中不支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:131
#: ../../../src/evox/utils/jit_fix_operator.py:146
#: ../../../src/evox/utils/jit_fix_operator.py:160
msgid "The element-wise minimum of a and b."
msgstr "a 和 b 的元素级最小值。"

#: ../../../src/evox/utils/jit_fix_operator.py:136
#: ../../../src/evox/utils/jit_fix_operator.py:144
msgid "The second input float, which is a scalar value."
msgstr "第二个输入是一个浮点数，它是一个标量值。"

#: ../../../src/evox/utils/jit_fix_operator.py:140
#: ../../../src/evox/utils/jit_fix_operator.py:154
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)"
" since it is not supported in JIT operator fusion."
msgstr ""
"注意：这是一个用于[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)的修复函数，因为它在JIT操作符融合中不支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:150
#: ../../../src/evox/utils/jit_fix_operator.py:158
msgid "The second input int, which is a scalar value."
msgstr "第二个输入是一个整数，它是一个标量值。"

#: ../../../src/evox/utils/jit_fix_operator.py:161
msgid ""
"This function sorts the given tensors lexicographically, where sorting is "
"performed by the first key, then by the second key in case of ties in the "
"first key, and so on. It works similarly to NumPy's `lexsort`, but is "
"designed for PyTorch tensors."
msgstr ""
"此函数按字典顺序对给定的张量进行排序，首先按第一个键排序，如果第一个键相同，则按第二个键排序，依此类推。它的工作方式类似于NumPy的`lexsort`，但专为PyTorch张量设计。"

#: ../../../src/evox/utils/jit_fix_operator.py:165
msgid ""
"A list of tensors to be sorted, where each tensor represents a sorting key. "
"All tensors must have the same length along the specified dimension (dim)."
msgstr "要排序的张量列表，其中每个张量代表一个排序键。所有张量在指定维度（dim）上必须具有相同的长度。"

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"The dimension along which to perform the sorting. Defaults to -1 (the last "
"dimension)."
msgstr "执行排序的维度。默认为 -1（最后一个维度）。"

#: ../../../src/evox/utils/jit_fix_operator.py:170
msgid ""
"A tensor containing indices that will sort the input tensors "
"lexicographically. These indices indicate the order of elements in the "
"sorted tensors."
msgstr "一个张量，包含按字典顺序对输入张量进行排序的索引。这些索引指示排序后张量中元素的顺序。"

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid "You can use `torch.unbind` to split the tensor into list."
msgstr "您可以使用 `torch.unbind` 将张量拆分为列表。"

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"This function replaces `NaN` values in the input tensor with `infinity` , "
"and then computes the minimum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr "此函数将输入张量中的 `NaN` 值替换为 `infinity`，然后在指定维度上计算最小值，有效地忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:171
#: ../../../src/evox/utils/jit_fix_operator.py:178
msgid ""
"The input tensor, which may contain NaN values. It can be of any shape."
msgstr "输入张量，可能包含NaN值。它可以是任何形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"The dimension along which to compute the minimum. Default is -1, which "
"corresponds to the last dimension."
msgstr "计算最小值的维度。默认值为-1，对应于最后一个维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:175
#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"Whether to retain the reduced dimension in the result. Default is False. If "
"True, the output tensor will have the same number of dimensions as the "
"input, with the size of the reduced dimension set to 1."
msgstr "是否在结果中保留减少的维度。默认值为 False。如果为 True，输出张量将与输入具有相同数量的维度，减少的维度大小将设置为 1。"

#: ../../../src/evox/utils/jit_fix_operator.py:179
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" minimum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the minimum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""
"一个命名元组，包含两个字段：values (torch.Tensor)：一个张量，包含沿指定维度计算的最小值，忽略NaN值。indices "
"(torch.Tensor)：一个张量，包含沿指定维度的最小值的索引。返回的张量values和indices将与输入张量具有相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:179
#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid "A named tuple with two fields:"
msgstr "一个具有两个字段的命名元组："

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"`values` (`torch.Tensor`): A tensor containing the minimum values computed "
"along the specified dimension,   ignoring `NaN` values."
msgstr "`values` (`torch.Tensor`): 一个张量，包含沿指定维度计算的最小值，忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the minimum "
"values along the specified dimension."
msgstr "`indices` (`torch.Tensor`): 一个张量，包含沿指定维度的最小值的索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:184
#: ../../../src/evox/utils/jit_fix_operator.py:191
msgid ""
"The returned tensors `values` and `indices` will have the same shape as the "
"input tensor, except for the dimension(s) over which the operation was "
"performed."
msgstr "返回的张量 `values` 和 `indices` 将具有与输入张量相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:195
msgid ""
"`NaN` values are ignored by replacing them with `infinity` before computing "
"the minimum."
msgstr "在计算最小值之前，通过将 `NaN` 值替换为 `infinity` 来忽略它们。"

#: ../../../src/evox/utils/jit_fix_operator.py:196
msgid ""
"If all values along a dimension are `NaN`, the result will be `infinity` for"
" that dimension, and the index will be returned as the first valid index."
msgstr "如果一个维度上的所有值都是`NaN`，那么该维度的结果将是`infinity`，并且索引将返回为第一个有效索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:175
msgid ""
"This function replaces `NaN` values in the input tensor with `-infinity`, "
"and then computes the maximum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr "此函数将输入张量中的 `NaN` 值替换为 `-infinity`，然后在指定维度上计算最大值，从而有效地忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"The dimension along which to compute the maximum. Default is -1, which "
"corresponds to the last dimension."
msgstr "计算最大值的维度。默认值是 -1，对应于最后一个维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" maximum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the maximum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""
"一个命名元组，包含两个字段：values (torch.Tensor)：一个张量，包含沿指定维度计算的最大值，忽略 NaN 值。indices "
"(torch.Tensor)：一个张量，包含沿指定维度的最大值的索引。返回的张量 values 和 indices "
"将与输入张量具有相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:187
msgid ""
"`values` (`torch.Tensor`): A tensor containing the maximum values computed "
"along the specified dimension,     ignoring `NaN` values."
msgstr "`values` (`torch.Tensor`): 一个张量，包含沿指定维度计算的最大值，忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:189
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the maximum "
"values along the specified dimension."
msgstr "`indices` (`torch.Tensor`): 一个张量，包含沿指定维度的最大值的索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:202
msgid ""
"`NaN` values are ignored by replacing them with `-infinity` before computing"
" the maximum."
msgstr "在计算最大值之前，通过将 `NaN` 值替换为 `-infinity` 来忽略它们。"

#: ../../../src/evox/utils/jit_fix_operator.py:203
msgid ""
"If all values along a dimension are `NaN`, the result will be `-infinity` "
"for that dimension, and the index will be returned as the first valid index."
msgstr "如果一个维度上的所有值都是`NaN`，那么该维度的结果将是`-infinity`，并且索引将返回为第一个有效索引。"

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:1
msgid "{py:mod}`evox.utils.parameters_and_vector`"
msgstr "{py:mod}`evox.utils.parameters_and_vector`"

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:18
msgid ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"
msgstr ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"

#: ../../../src/evox/utils/parameters_and_vector.py:20
#: ../../../src/evox/utils/parameters_and_vector.py:33
msgid ""
"The class to convert (batched) parameters dictionary to vector(s) and vice "
"versa."
msgstr "将（批处理）参数字典转换为向量的类，反之亦然。"

#: ../../../src/evox/utils/parameters_and_vector.py:39
msgid "Initialize the ParamsAndVector instance."
msgstr "初始化 ParamsAndVector 实例。"

#: ../../../src/evox/utils/parameters_and_vector.py:41
msgid ""
"A PyTorch model whose parameters will be used to initialize the parameter "
"and vector conversion attributes. Must be an initialized PyTorch model."
msgstr "一个 PyTorch 模型，其参数将用于初始化参数和向量转换属性。必须是已初始化的 PyTorch 模型。"

#: ../../../src/evox/utils/parameters_and_vector.py:46
msgid "Convert the input parameters dictionary to a single vector."
msgstr "将输入参数字典转换为单个向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:48
msgid "The input parameters dictionary."
msgstr "输入参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:50
msgid "The output vector obtained by concatenating the flattened parameters."
msgstr "通过连接展平的参数获得的输出向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:54
msgid "Convert a batched parameters dictionary to a batch of vectors."
msgstr "将批量参数字典转换为向量的批量。"

#: ../../../src/evox/utils/parameters_and_vector.py:56
msgid ""
"The input dictionary values must be batched parameters, i.e., they must have"
" the same shape at the first dimension."
msgstr "输入字典的值必须是批处理参数，即它们在第一维度上必须具有相同的形状。"

#: ../../../src/evox/utils/parameters_and_vector.py:58
msgid "The input batched parameters dictionary."
msgstr "输入批处理参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:60
msgid ""
"The output vectors obtained by concatenating the flattened batched "
"parameters. The first dimension of the output vector corresponds to the "
"batch size."
msgstr "通过连接展平的批处理参数获得的输出向量。输出向量的第一个维度对应于批处理大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:62
msgid "Convert a vector back to a parameters dictionary."
msgstr "将向量转换回参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:64
msgid "The input vector representing flattened model parameters."
msgstr "表示展平模型参数的输入向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:66
msgid "The reconstructed parameters dictionary."
msgstr "重建的参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:70
msgid "Convert a batch of vectors back to a batched parameters dictionary."
msgstr "将一批向量转换回批量参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:72
msgid ""
"The input batch of vectors representing flattened model parameters. The "
"first dimension of the tensor corresponds to the batch size."
msgstr "输入批量向量表示展平的模型参数。张量的第一个维度对应于批量大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:74
msgid ""
"The reconstructed batched parameters dictionary whose tensors' first "
"dimensions correspond to the batch size."
msgstr "重构后的批处理参数字典，其张量的第一个维度对应于批处理大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:78
msgid ""
"The forward function for the `ParamsAndVector` module is an alias of "
"`batched_to_params` to cope with `StdWorkflow`."
msgstr ""
"`ParamsAndVector` 模块的 forward 函数是 `batched_to_params` 的别名，用于应对 `StdWorkflow"

#: ../../source/apidocs/evox/evox.vis_tools.md:1
msgid "{py:mod}`evox.vis_tools`"
msgstr "{py:mod}`evox.vis_tools`"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:1
msgid "{py:mod}`evox.vis_tools.exv`"
msgstr "{py:mod}`evox.vis_tools.exv`"

#: ../../../src/evox/vis_tools/exv.py:7
msgid "This module helps serialize data to EvoXVision storage format (exv)."
msgstr "此模块帮助将数据序列化为EvoXVision存储格式（exv）。"

#: ../../../src/evox/vis_tools/exv.py:13
msgid ""
"The numbers are stored in little-endian format. The metadata is a JSON utf-8"
" encoded string, which contains the schema of the binary data. The format of"
" the metadata is as follows:"
msgstr "数字以小端格式存储。元数据是一个 JSON utf-8 编码的字符串，其中包含二进制数据的模式。元数据的格式如下："

#: ../../../src/evox/vis_tools/exv.py:49
msgid ""
"where <type> represents the data type of the field, available types are:"
msgstr "在这里，<type> 代表字段的数据类型，可用的类型有："

#: ../../../src/evox/vis_tools/exv.py:50
msgid "\"u8\", \"u16\", \"u32\", \"u64\","
msgstr "\"u8\", \"u16\", \"u32\", \"u64\","

#: ../../../src/evox/vis_tools/exv.py:51
msgid "\"i16\", \"i32\", \"i64\","
msgstr "\"i16\", \"i32\", \"i64\","

#: ../../../src/evox/vis_tools/exv.py:52
msgid "\"f16\", \"f32\", \"f64\" The size and offset are in bytes."
msgstr "\"f16\", \"f32\", \"f64\" 大小和偏移量以字节为单位。"

#: ../../../src/evox/vis_tools/exv.py:56
msgid ""
"The magic number is used to identify the file format. 0x65787631 is the byte"
" code for \"exv1\". The binary data blob is a sequence of binary data "
"chunks. In EvoX, the algorithm is allowed to have a different behavior in "
"the first iteration (initialization phase), which can have a different chunk"
" size than the rest of the iterations. Therefore it contains two different "
"schemas for the initial iteration and the rest of the iterations."
msgstr ""
"魔术数字用于识别文件格式。0x65787631 是 \"exv1\" 的字节码。二进制数据块是二进制数据块的序列。在 EvoX "
"中，算法允许在第一次迭代（初始化阶段）中具有不同的行为，这可能与其余迭代的块大小不同。因此，它包含了初始迭代和其余迭代的两种不同模式。"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:18
msgid "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"
msgstr "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"

#: ../../../src/evox/vis_tools/exv.py:20 ../../../src/evox/vis_tools/exv.py:61
msgid ""
"EvoXVisionAdapter is a class that streams evolutionary optimization data to "
"an exv file. The exv file format is a binary format that created "
"specifically for the evolutionary optimization data. The format is designed "
"to be efficient for both stream reading and writing data, while being able "
"to randomly access data at any iteration."
msgstr ""
"EvoXVisionAdapter 是一个类，用于将演化优化数据流式传输到 exv 文件。exv "
"文件格式是一种专门为演化优化数据创建的二进制格式。该格式设计为在流式读取和写入数据时都能高效运行，同时能够在任何迭代中随机访问数据。"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:30
msgid "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"
msgstr "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:34
msgid "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"
msgstr "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"

#: ../../../src/evox/vis_tools/exv.py:36 ../../../src/evox/vis_tools/exv.py:53
msgid ""
"Takes the input of the populaton and fitness from the first two iterations, "
"and returns the schema for exv file format."
msgstr "接收前两次迭代的种群和适应度输入，并返回 exv 文件格式的模式。"

#: ../../../src/evox/vis_tools/exv.py:67
msgid ""
"Create a new EvoXVisionAdapter instance, which writes data to an exv file. "
"To automatically inference the data schema, the EvoXVisionAdapter requires 2"
" iterations of data, therefore it will only start to write data after the 2 "
"iterations of the optimization loop are completed."
msgstr ""
"创建一个新的EvoXVisionAdapter实例，该实例将数据写入exv文件。为了自动推断数据模式，EvoXVisionAdapter需要2次数据迭代，因此它将在优化循环的2次迭代完成后才开始写入数据。"

#: ../../../src/evox/vis_tools/exv.py:71
msgid "The path to the exv file"
msgstr "通向exv文件的路径"

#: ../../../src/evox/vis_tools/exv.py:72
msgid ""
"The buffer size to use for file operations, passed directly to the open() "
"function. The default is 0, which disables buffering (unbuffered mode)."
msgstr "用于文件操作的缓冲区大小，直接传递给 `open()` 函数。默认值为 0，表示禁用缓冲（无缓冲模式）。"

#: ../../../src/evox/vis_tools/exv.py:98
msgid "Write the header of the exv file."
msgstr "请写出 exv 文件的标题。"

#: ../../../src/evox/vis_tools/exv.py:106
msgid ""
"Stream data to the exv file. Depending on the `buffering` parameter, the "
"data may not be written immediately."
msgstr "将数据流传输到 exv 文件。根据 `buffering` 参数，数据可能不会立即写入。"

#: ../../../src/evox/vis_tools/exv.py:114
msgid "Flush the internal buffer to the file."
msgstr "将内部缓冲区刷新到文件。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:1
msgid "{py:mod}`evox.vis_tools.plot`"
msgstr "{py:mod}`evox.vis_tools.plot`"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:18
msgid "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"
msgstr "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"

#: ../../../src/evox/vis_tools/plot.py:20
#: ../../../src/evox/vis_tools/plot.py:50
msgid ""
"A Built-in plot function for visualizing the population of single-objective "
"algorithm. Use plotly internally, so you need to install plotly to use this "
"function."
msgstr "内置绘图函数用于可视化单目标算法的种群。内部使用plotly，因此需要安装plotly才能使用此函数。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:22
msgid "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"
msgstr "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"

#: ../../../src/evox/vis_tools/plot.py:24
#: ../../../src/evox/vis_tools/plot.py:57
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem."
msgstr "可视化单目标优化问题中种群的适应度值。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:26
msgid ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"
msgstr ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"

#: ../../../src/evox/vis_tools/plot.py:28
#: ../../../src/evox/vis_tools/plot.py:64
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. No animation."
msgstr "在单目标优化问题中可视化种群的适应度值。无动画。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:30
msgid ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"
msgstr ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"

#: ../../../src/evox/vis_tools/plot.py:32
#: ../../../src/evox/vis_tools/plot.py:71
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. With animation."
msgstr "在单目标优化问题中可视化种群的适应度值。带有动画。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:34
msgid "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"
msgstr "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"

#: ../../../src/evox/vis_tools/plot.py:36
#: ../../../src/evox/vis_tools/plot.py:78
msgid ""
"Visualize the fitness values of the population in a multi-objective (2 "
"objectives) optimization problem."
msgstr "可视化种群在多目标（2个目标）优化问题中的适应度值。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:38
msgid "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"
msgstr "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"

#: ../../../src/evox/vis_tools/plot.py:40
#: ../../../src/evox/vis_tools/plot.py:85
msgid ""
"Visualize the fitness values of the population in a multi-objective (3 "
"objectives) optimization problem."
msgstr "可视化种群在多目标（3个目标）优化问题中的适应度值。"

#: ../../../src/evox/vis_tools/plot.py:53
msgid ""
"If the problem is provided, we will plot the fitness landscape of the "
"problem."
msgstr "如果提供了问题，我们将绘制该问题的适应度景观。"

#: ../../../src/evox/vis_tools/plot.py:55
msgid ""
"A list of arrays, each array represents the population of one generation."
msgstr "一个数组列表，每个数组代表一代的种群。"

#: ../../../src/evox/vis_tools/plot.py:56
#: ../../../src/evox/vis_tools/plot.py:61
#: ../../../src/evox/vis_tools/plot.py:83
#: ../../../src/evox/vis_tools/plot.py:90
msgid "Additional arguments to be passed to the plotly layout."
msgstr "传递给 plotly 布局的附加参数。"

#: ../../../src/evox/vis_tools/plot.py:58
#: ../../../src/evox/vis_tools/plot.py:63
#: ../../../src/evox/vis_tools/plot.py:85
#: ../../../src/evox/vis_tools/plot.py:92
msgid "A plotly figure."
msgstr "A plotly figure."

#: ../../../src/evox/vis_tools/plot.py:59
#: ../../../src/evox/vis_tools/plot.py:80
#: ../../../src/evox/vis_tools/plot.py:87
msgid ""
"A list of arrays, each array represents the fitness values of the population"
" of one generation."
msgstr "一组数组，每个数组代表一代种群的适应度值。"

#: ../../../src/evox/vis_tools/plot.py:60
msgid "Whether to show the animation of the fitness values over generations."
msgstr "是否显示适应度值随世代变化的动画。"

#: ../../../src/evox/vis_tools/plot.py:81
#: ../../../src/evox/vis_tools/plot.py:89
msgid "The Pareto front of the problem. Optional."
msgstr "问题的 Pareto 前沿。可选。"

#: ../../../src/evox/vis_tools/plot.py:82
#: ../../../src/evox/vis_tools/plot.py:88
msgid ""
"Whether to sort the points in the plot. This will only affect the animation "
"behavior."
msgstr "是否对图中的点进行排序。这只会影响动画行为。"

#: ../../source/apidocs/evox/evox.workflows.md:1
msgid "{py:mod}`evox.workflows`"
msgstr "{py:mod}`evox.workflows`"

#: ../../source/apidocs/evox/evox.workflows.md:28
msgid "{py:obj}`__all__ <evox.workflows.__all__>`"
msgstr "{py:obj}`__all__ <evox.workflows.__all__>`"

#: ../../source/apidocs/evox/evox.workflows.md:40
msgid "['EvalMonitor', 'StdWorkflow']"
msgstr "['EvalMonitor', 'StdWorkflow']"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:1
msgid "{py:mod}`evox.workflows.eval_monitor`"
msgstr "{py:mod}`evox.workflows.eval_monitor`"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:18
msgid "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"
msgstr "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"

#: ../../../src/evox/workflows/eval_monitor.py:20
#: ../../../src/evox/workflows/eval_monitor.py:33
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the offspring, "
"their corresponding fitness and keep track of the evaluation count. "
"Moreover, it can also record the best solution or the pareto front on-the-"
"fly."
msgstr ""
"评估监控器被用于单目标和多目标工作流。它与评估流程挂钩，可以监控子代及其相应的适应度并对评估计数进行跟踪。此外，它还能即时记录最优解或帕累托前沿。"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:30
msgid "Bases: {py:obj}`evox.core.Monitor`"
msgstr "Bases: {py:obj}`evox.core.Monitor`"

#: ../../../src/evox/workflows/eval_monitor.py:39
msgid "Initialize the monitor."
msgstr "初始化监视器。"

#: ../../../src/evox/workflows/eval_monitor.py:41
msgid "Whether the optimization is multi-objective. Defaults to False."
msgstr "是否为多目标优化。默认值为 False。"

#: ../../../src/evox/workflows/eval_monitor.py:42
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:43
msgid ""
"Whether to record the full history of solutions. Default to False. Setting "
"it to True may increase memory usage."
msgstr "是否记录完整的解的历史。默认为 False。将其设置为 True 可能会增加内存使用量。"

#: ../../../src/evox/workflows/eval_monitor.py:44
msgid ""
"Only affect Single-objective optimization. The number of elite solutions to "
"record. Default to 1, which will record the best individual."
msgstr "只影响单目标优化。要记录的精英解决方案的数量。默认为 1，将记录最佳个人。"

#: ../../../src/evox/workflows/eval_monitor.py:45
msgid "The device of the monitor. Defaults to None."
msgstr "监视器的设备。默认值为 None。"

#: ../../../src/evox/workflows/eval_monitor.py:61
msgid "Get the fitness values from the latest iteration."
msgstr "从最新迭代中获取适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:69
msgid "Get the solution from the latest iteration."
msgstr "从最新的迭代中获取解决方案。"

#: ../../../src/evox/workflows/eval_monitor.py:77
msgid "Get the topk fitness values so far."
msgstr "获取当前前k个适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:85
msgid "Get the topk solutions so far."
msgstr "获取当前最优的前k个解。"

#: ../../../src/evox/workflows/eval_monitor.py:93
msgid "Get the best solution so far."
msgstr "获取迄今为止的最佳解决方案。"

#: ../../../src/evox/workflows/eval_monitor.py:101
msgid "Get the best fitness value so far."
msgstr "获取当前最佳适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:109
msgid "Get the full history of fitness values."
msgstr "获取适应度值的完整历史记录。"

#: ../../../src/evox/workflows/eval_monitor.py:117
msgid "Get the full history of solutions."
msgstr "获取完整的解决方案历史。"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:1
msgid "{py:mod}`evox.workflows.std_workflow`"
msgstr "{py:mod}`evox.workflows.std_workflow`"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:18
msgid "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"
msgstr "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:20
msgid "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"
msgstr "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"

#: ../../../src/evox/workflows/std_workflow.py:22
#: ../../../src/evox/workflows/std_workflow.py:50
msgid "The standard workflow."
msgstr "标准工作流。"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:47
msgid "Bases: {py:obj}`evox.core.Workflow`"
msgstr "Bases: {py:obj}`evox.core.Workflow`"

#: ../../../src/evox/workflows/std_workflow.py:56
msgid "Initialize the standard workflow with static arguments."
msgstr "使用静态参数初始化标准工作流。"

#: ../../../src/evox/workflows/std_workflow.py:58
msgid ""
"The optimization direction, can only be \"min\" or \"max\". Defaults to "
"\"min\". If \"max\", the fitness will be negated prior to fitness_transform "
"and monitor."
msgstr ""
"优化方向只能是“min”或“max”。默认为“min”。如果是“max”，适应度将在 `fitness_transform` 和 `monitor` "
"之前取反。"

#: ../../../src/evox/workflows/std_workflow.py:63
msgid ""
"Setup the module with submodule initialization. Since all of these arguments"
" are mutable modules to be added as submodules, they are placed here instead"
" of `__init__` and thus `setup` MUST be invoked after `__init__`."
msgstr ""
"将模块设置为子模块初始化。由于所有这些参数都是可变模块，将作为子模块添加，因此它们被放置在这里而不是 `__init__` 中，因此 `setup` "
"必须在 `__init__` 之后调用。"

#: ../../../src/evox/workflows/std_workflow.py:65
msgid "The algorithm to be used in the workflow."
msgstr "在工作流中要使用的算法。"

#: ../../../src/evox/workflows/std_workflow.py:66
msgid "The problem to be used in the workflow."
msgstr "在工作流中要使用的问题。"

#: ../../../src/evox/workflows/std_workflow.py:67
msgid ""
"The monitors to be used in the workflow. Defaults to None. Notice: usually, "
"monitors can only be used when using JIT script mode."
msgstr "在工作流中使用的监视器。默认为 None。注意：通常情况下，监视器只能在使用 JIT script 模式时使用。"

#: ../../../src/evox/workflows/std_workflow.py:68
msgid ""
"The solution transformation function. MUST be JIT-compatible module/function"
" for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr "解决方案转换函数。必须是兼容JIT的模块/函数，用于JIT跟踪模式，或者是JIT脚本模式（默认模式）的普通模块。默认为None。"

#: ../../../src/evox/workflows/std_workflow.py:69
msgid ""
"The fitness transformation function. MUST be JIT-compatible module/function "
"for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr "适应度转换函数。必须是与JIT兼容的模块/函数，用于JIT追踪模式，或者是用于JIT脚本模式（默认模式）的普通模块。默认值为None。"

#: ../../../src/evox/workflows/std_workflow.py:70
msgid "The device of the workflow. Defaults to None."
msgstr "工作流的设备。默认为 None。"

#: ../../../src/evox/workflows/std_workflow.py:71
msgid ""
"The arguments to be passed to algorithm.setup(**kwargs). If not provided, "
"the algorithm.setup() will not be invoked."
msgstr "要传递给 `algorithm.setup(**kwargs)` 的参数。如果未提供，则不会调用 `algorithm.setup()"

#: ../../../src/evox/workflows/std_workflow.py:72
msgid ""
"The arguments to be passed to problem.setup(**kwargs). If not provided, the "
"problem.setup() will not be invoked."
msgstr "要传递给 `problem.setup(**kwargs)` 的参数。如果未提供，则不会调用 `problem.setup()"

#: ../../../src/evox/workflows/std_workflow.py:73
msgid ""
"The arguments to be passed to monitor.setup(**kwargs). If not provided, the "
"monitor.setup() will not be invoked."
msgstr "要传递给 `monitor.setup(**kwargs)` 的参数。如果未提供，则不会调用 `monitor.setup()"

#: ../../../src/evox/workflows/std_workflow.py:76
msgid ""
"The algorithm, problem and monitor will be IN-PLACE transformed to the "
"target device."
msgstr "算法、问题和监视器将被原地转换到目标设备。"

#: ../../../src/evox/workflows/std_workflow.py:113
msgid ""
"Perform a single optimization step using the algorithm and the problem."
msgstr "使用算法和问题执行单个优化步骤。"

#: ../../source/apidocs/index.rst:2 ../../source/index.md:15
msgid "API Reference"
msgstr "API文档"

#: ../../source/apidocs/index.rst:4
msgid "This page contains auto-generated API reference documentation [#f1]_."
msgstr "此页面包含自动生成的API参考文档[#f1]_。"

#: ../../source/apidocs/index.rst:11
msgid ""
"Created with `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-"
"autodoc2>`_"
msgstr ""
"使用 `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-autodoc2>`_ 创建"

#: ../../source/example/brax.ipynb:10002
#: ../../source/guide/user/2-problems.ipynb:10002
msgid "Solving Brax Problems in EvoX"
msgstr "用EvoX解决Brax问题"

#: ../../source/example/brax.ipynb:10004
#: ../../source/guide/user/2-problems.ipynb:10004
msgid ""
"EvoX deeply dives into neuroevolution with Brax. Here we will show an "
"example of solving Brax problem in EvoX."
msgstr "EvoX 深入研究使用 Brax 的神经演化。这里我们将展示一个在 EvoX 中解决 Brax 问题的例子。"

#: ../../source/example/brax.ipynb:40002
#: ../../source/guide/user/2-problems.ipynb:50003
msgid "What is Brax"
msgstr "什么是Brax"

#: ../../source/example/brax.ipynb:40004
#: ../../source/guide/user/2-problems.ipynb:50005
msgid ""
"Brax is a fast and fully differentiable physics engine used for research and"
" development of robotics, human perception, materials science, reinforcement"
" learning, and other simulation-heavy applications."
msgstr "Brax 是一个快速且完全可微分的物理引擎，用于机器人学、人类感知、材料科学、强化学习和其他需要大量模拟的应用的研究和开发。"

#: ../../source/example/brax.ipynb:40006
msgid "Here we will demonstrate a \"swimmer\" environment of Brax."
msgstr "在这我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/example/brax.ipynb:40008
msgid ""
"For more information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr "有关更多信息，您可以浏览 [Brax 的 Github](https://github.com/google/brax)。"

#: ../../source/example/brax.ipynb:50002
#: ../../source/guide/user/2-problems.ipynb:60002
msgid "Design a neural network class"
msgstr "设计一个神经网络类"

#: ../../source/example/brax.ipynb:50004
#: ../../source/guide/user/2-problems.ipynb:60004
msgid ""
"To start with, we need to decide which neural network we are about to "
"construct."
msgstr "要开始，我们需要决定要构建哪个神经网络。"

#: ../../source/example/brax.ipynb:50006
#: ../../source/guide/user/2-problems.ipynb:60006
msgid "Here we will give a simple Multilayer Perceptron (MLP) class."
msgstr "这里我们将给出一个简单的多层感知器（MLP）类。"

#: ../../source/example/brax.ipynb:70002
#: ../../source/guide/user/2-problems.ipynb:80002
msgid "Initiate a model"
msgstr "初始化模型"

#: ../../source/example/brax.ipynb:70004
#: ../../source/guide/user/2-problems.ipynb:80004
msgid "Through the ``SimpleMLP`` class, we can initiate a MLP model."
msgstr "通过``SimpleMLP``类，我们可以初始化一个MLP模型。"

#: ../../source/example/brax.ipynb:90002
#: ../../source/guide/user/2-problems.ipynb:100002
msgid "Initiate an adapter"
msgstr "启动适配器"

#: ../../source/example/brax.ipynb:90004
#: ../../source/guide/user/2-problems.ipynb:100004
msgid "An adapter can help us convert the data back-and-forth."
msgstr "一个转换器可以帮助我们将数据在不同形式间来回转换。"

#: ../../source/example/brax.ipynb:110002
#: ../../source/guide/user/2-problems.ipynb:120002
msgid "With an adapter, we can set out to do this Neuroevolution Task."
msgstr "使用适配器，我们可以开始进行这个神经演化任务。"

#: ../../source/example/brax.ipynb:110004
#: ../../source/guide/user/2-problems.ipynb:120004
msgid "Set up the running process"
msgstr "设置运行过程"

#: ../../source/example/brax.ipynb:110006
#: ../../source/guide/user/1-start.ipynb:40011
#: ../../source/guide/user/2-problems.ipynb:120006
msgid "Initiate an algorithm and a problem"
msgstr "初始化一个算法和一个问题"

#: ../../source/example/brax.ipynb:110008
#: ../../source/guide/user/2-problems.ipynb:120008
msgid ""
"We initiate a [PSO algorithm](#evox.algorithms.pso_variants.pso.PSO), and "
"the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"swimmer\" "
"environment."
msgstr ""
"我们初始化一个[PSO 算法](#evox.algorithms.pso_variants.pso.PSO)，问题是[Brax "
"问题](#evox.problems.neuroevolution.brax.BraxProblem)中的“swimmer”环境。"

#: ../../source/example/brax.ipynb:130002
#: ../../source/guide/user/2-problems.ipynb:140002
msgid ""
"In this case, we will be using 1000 steps for each episode, and the average "
"reward of 3 episodes will be returned as the fitness value."
msgstr "在这种情况下，我们将为每个 episode 使用 1000 步，并返回 3 个 episode 的平均奖励作为适应度值。"

#: ../../source/example/brax.ipynb:130004
#: ../../source/guide/user/1-start.ipynb:60004
#: ../../source/guide/user/2-problems.ipynb:140004
msgid "Set an monitor"
msgstr "设置一个monitor"

#: ../../source/example/brax.ipynb:150002
#: ../../source/guide/user/1-start.ipynb:80002
#: ../../source/guide/user/2-problems.ipynb:160002
msgid "Initiate an workflow"
msgstr "启动一个工作流"

#: ../../source/example/brax.ipynb:170002
#: ../../source/guide/user/1-start.ipynb:100002
#: ../../source/guide/user/2-problems.ipynb:180002
msgid "Run the workflow"
msgstr "运行工作流"

#: ../../source/example/brax.ipynb:170004
#: ../../source/guide/user/2-problems.ipynb:180004
msgid "Run the workflow and see the magic!"
msgstr "运行工作流并见证魔法！"

#: ../../source/example/brax.ipynb:170007
#: ../../source/guide/user/2-problems.ipynb:180007
msgid ""
"The following block will take around 20 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下代码块大约需要运行20分钟。运行时间可能会因您的硬件而有所不同。"

#: ../../source/example/brax.ipynb:220003
#: ../../source/guide/user/2-problems.ipynb:230003
msgid ""
"Normally, you only need `HTML(problem.visualize(best_params))` to render. "
"The code above is a workaround to ensure the result is displayed correctly "
"on our website."
msgstr ""
"通常，您只需要使用 `HTML(problem.visualize(best_params))` "
"来渲染。上面的代码是一种解决方法，以确保结果在我们的网站上正确显示。"

#: ../../source/example/brax.ipynb:220004
#: ../../source/guide/user/2-problems.ipynb:230004
msgid ""
"The PSO algorithm is not specifically optimized for this type of task, so "
"performance limitations are expected. This example is for demonstration "
"purposes."
msgstr "PSO算法并未针对这种类型的任务进行特别优化，因此预期会有性能限制。此示例仅用于演示目的。"

#: ../../source/example/brax.ipynb:220007
#: ../../source/guide/user/2-problems.ipynb:230007
msgid "We hope you enjoy solving Brax problems with EvoX and have fun!"
msgstr "我们希望您在使用EvoX解决Brax问题时能够享受乐趣！"

#: ../../source/example/custom_algo_prob.ipynb:10002
msgid "Custom Algorithm and Problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algo_prob.ipynb:10003
msgid ""
"In this notebook, we will show how to use the "
"[`Algorithm`](#evox.core.components.Algorithm) and "
"[`Problem`](#evox.core.components.Problem) to create a custom algorithm and "
"problem. Here we will give an example of **implementing a PSO algorithm that"
" solves the Sphere problem**."
msgstr ""
"在这个笔记本中，我们将展示如何使用[`Algorithm`](#evox.core.components.Algorithm)和[`Problem`](#evox.core.components.Problem)来创建一个自定义算法和问题。这里我们将给出一个**实现解决Sphere问题的PSO算法**的例子。"

#: ../../source/example/custom_algo_prob.ipynb:30002
#: ../../source/guide/developer/3-custom-alg-pro.md:99
msgid "Algorithm example: PSO algorithm"
msgstr "算法示例：PSO 算法"

#: ../../source/example/custom_algo_prob.ipynb:30004
msgid ""
"Particle Swarm Optimization (PSO) is a population-based metaheuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr "粒子群优化（PSO）是一种基于种群的元启发式算法，灵感来自鸟类和鱼类的社会行为。它广泛用于解决连续和离散优化问题。"

#: ../../source/example/custom_algo_prob.ipynb:30006
#: ../../source/guide/developer/3-custom-alg-pro.md:103
msgid "**Here is an implementation example of PSO algorithm in EvoX:**"
msgstr "**以下是EvoX中PSO算法的实现示例：**"

#: ../../source/example/custom_algo_prob.ipynb:50002
#: ../../source/guide/developer/3-custom-alg-pro.md:188
msgid "Problem example: Sphere problem"
msgstr "问题示例：Sphere 问题"

#: ../../source/example/custom_algo_prob.ipynb:50004
#: ../../source/guide/developer/3-custom-alg-pro.md:190
msgid ""
"The Sphere problem is a simple, yet fundamental benchmark optimization "
"problem used to test optimization algorithms."
msgstr "Sphere问题是一个简单但基本的基准优化问题，用于测试优化算法。"

#: ../../source/example/custom_algo_prob.ipynb:50006
#: ../../source/guide/developer/3-custom-alg-pro.md:192
msgid "The Sphere function is defined as:"
msgstr ""
"The Sphere function is defined as:\n"
"\n"
"球体函数定义为："

#: ../../source/example/custom_algo_prob.ipynb:50008
#: ../../source/guide/developer/3-custom-alg-pro.md:194
msgid ""
"\n"
"\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}\n"
msgstr "\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}"

#: ../../source/example/custom_algo_prob.ipynb:50011
#: ../../source/guide/developer/3-custom-alg-pro.md:197
msgid "**Here is an implementation example of Sphere problem in EvoX:**"
msgstr "**以下是EvoX中Sphere问题的实现示例：**"

#: ../../source/example/custom_algo_prob.ipynb:70002
msgid "Use the algorithm to solve the problem"
msgstr "使用该算法解决该问题"

#: ../../source/example/custom_algo_prob.ipynb:70004
msgid "Initiate the algorithm, problem and monitor"
msgstr "初始化algorithm，problem，monitor对象。"

#: ../../source/example/custom_algo_prob.ipynb:90002
msgid "Initiate the workflow and run it"
msgstr "启动工作流并运行它"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/moalg.ipynb:10002
msgid "Multi-Objective Algorithm"
msgstr "多目标算法"

#: ../../source/example/moalg.ipynb:20002
msgid ""
"In this notebook, we will use the Reference Vector Guided Evolutionary "
"Algorithm (**RVEA**) to find the optimal solutions of the **DTLZ2** problem."
msgstr "在这个笔记本中，我们将使用参考向量引导演化算法（**RVEA**）来寻找 **DTLZ2** 问题的最优解。"

#: ../../source/example/moalg.ipynb:40002
msgid "(Optional) Use GPU to run the code"
msgstr "（可选）使用GPU运行代码"

#: ../../source/example/moalg.ipynb:40003
msgid ""
"We often prefer to run our code on a GPU for faster execution. However, if a"
" GPU is unavailable, running on a CPU is also acceptable."
msgstr "我们通常更喜欢在GPU上运行代码以加快执行速度。然而，如果没有GPU，使用CPU运行也是可以接受的。"

#: ../../source/example/moalg.ipynb:60002
msgid "Running example: RVEA on DTLZ2 problem"
msgstr "运行示例：RVEA 在 DTLZ2 问题上"

#: ../../source/example/moalg.ipynb:60003
msgid ""
"The following code is used to set up the "
"[`DTLZ2`](#evox.problems.numerical.dtlz) problem and the "
"[`RVEA`](#evox.algorithms.mo.rvea) algorithm. More information about the "
"problem and algorithm can be found in the corresponding section of the "
"documentation."
msgstr ""
"以下代码用于设置 [`DTLZ2`](#evox.problems.numerical.dtlz) 问题和 "
"[`RVEA`](#evox.algorithms.mo.rvea) 算法。关于该问题和算法的更多信息可以在文档的相应部分找到。"

#: ../../source/example/moalg.ipynb:80002
msgid ""
"With this setup in place, we can now start to optimize. We set to let the "
"multi-objective algorithm optimize for 100 steps on this problem"
msgstr "在这个设置完成后，我们现在可以开始优化。我们设置让多目标算法在这个问题上优化100步。"

#: ../../source/example/so-algorithm.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/so-algorithm.ipynb:20002
msgid ""
"This notebook offers a step-by-step tutorial on utilizing EvoX to optimize "
"the Ackley function through the Particle Swarm Optimization (PSO) algorithm."
" Both the PSO algorithm and the Ackley optimization problem are integrated "
"as built-in components within the EvoX framework."
msgstr ""
"本笔记本提供了一个逐步教程，指导如何使用EvoX通过粒子群优化（PSO）算法来优化Ackley函数。PSO算法和Ackley优化问题都作为内置组件集成在EvoX框架中。"

#: ../../source/example/so-algorithm.ipynb:20004
msgid ""
"First, we should import all necessary modules including `PSO` (algorithm), "
"`Ackley` (problem) and `StdWorkflow` & `EvalMonitor` (workflow)."
msgstr ""
"首先，我们应该导入所有必要的模块，包括 `PSO`（算法）、`Ackley`（问题）以及 `StdWorkflow` 和 "
"`EvalMonitor`（工作流）。"

#: ../../source/example/so-algorithm.ipynb:40002
msgid ""
"Here, we instantiate the [`PSO`](#evox.algorithms.pso_variants.pso) "
"algorithm. We specify the following settings:"
msgstr "在这里，我们实例化了[`PSO`](#evox.algorithms.pso_variants.pso)算法。我们指定了以下设置："

#: ../../source/example/so-algorithm.ipynb:40004
msgid "`pop_size`: The size of the particle swarm (population)."
msgstr "`pop_size`: 粒子群（种群）的大小。"

#: ../../source/example/so-algorithm.ipynb:40005
msgid ""
"`lb` and `ub`: The lower and upper bounds for each dimension in the search "
"space."
msgstr "`lb` 和 `ub`: 搜索空间中每个维度的下限和上限。"

#: ../../source/example/so-algorithm.ipynb:40006
msgid "Other parameters are all default. Please refer to the detailed API."
msgstr "其他参数都是默认的。请参考详细的API。"

#: ../../source/example/so-algorithm.ipynb:60002
msgid ""
"Next, we choose the [`Ackley`](#evox.problems.numerical.basic.Ackley) "
"function in EvoX' s numerical problem."
msgstr ""
"接下来，我们选择 EvoX 的数值问题中的 [`Ackley`](#evox.problems.numerical.basic.Ackley) 函数。"

#: ../../source/example/so-algorithm.ipynb:80002
msgid ""
"We creat an [`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor) "
"instance to track necessary information during the optimization procedure."
msgstr ""
"我们创建一个[`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor)实例，以跟踪优化过程中的必要信息。"

#: ../../source/example/so-algorithm.ipynb:100002
msgid ""
"The [`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) class provides"
" a standardized process to integrate the algorithm, problem, and monitor."
msgstr ""
"[`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) "
"类提供了一个标准化的过程来整合算法、问题和监控器。"

#: ../../source/example/so-algorithm.ipynb:120002
msgid ""
"Calling `setup()` initializes the components so that the workflow is ready "
"to perform optimization steps."
msgstr "调用 `setup()` 初始化组件，使工作流准备好执行优化步骤。"

#: ../../source/example/so-algorithm.ipynb:140002
msgid ""
"We run the optimization for a certain number of iterations (100 in this "
"example). In each iteration, the `step()` method updates the PSO algorithm, "
"evaluates new candidate solutions on the Ackley function, and tracks their "
"fitness via the monitor."
msgstr ""
"我们运行优化过程一定次数的迭代（在这个例子中是100次）。在每次迭代中，`step()` "
"方法更新PSO算法，在Ackley函数上评估新的候选解，并通过监视器跟踪它们的适应度。"

#: ../../source/example/so-algorithm.ipynb:160002
msgid ""
"Finally, we retrieve the [`monitor`](#StdWorkflow.get_submodule) submodule "
"from the workflow to access the top solutions found so far "
"(`topk_solutions`) and their corresponding objective values "
"(`topk_fitness`). We then print the best result and the associated solution."
msgstr ""
"最后，我们从工作流中检索 [`monitor`](#StdWorkflow.get_submodule) 子模块，以访问迄今为止找到的最佳解决方案 "
"(`topk_solutions`) 及其对应的目标值 (`topk_fitness`)。然后，我们打印出最佳结果及其相关的解决方案。"

#: ../../source/example/supervised-learning.ipynb:10002
msgid "Neuroevolution for machine learning"
msgstr "机器学习的神经演化"

#: ../../source/example/supervised-learning.ipynb:20002
msgid ""
"EvoX provides solutions for supervised learning tasks based on "
"neuroevolution, with key modules including "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" and [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)."
" Taking the MNIST classification task as an example, this section "
"illustrates the neuroevolution process for supervised learning by adopting "
"the modules of EvoX."
msgstr ""
"EvoX 提供基于神经演化的监督学习任务解决方案，主要模块包括 "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" 和 [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)。以 "
"MNIST 分类任务为例，本节通过采用 EvoX 的模块来说明监督学习的神经演化过程。"

#: ../../source/example/supervised-learning.ipynb:30002
msgid "Basic Setup"
msgstr "基本设置"

#: ../../source/example/supervised-learning.ipynb:40002
msgid ""
"Basic component imports and device configuration serve as the essential "
"starting steps for the neuroevolution process."
msgstr "神经演化过程的基本组件导入和设备配置是至关重要的起始步骤。"

#: ../../source/example/supervised-learning.ipynb:40004
msgid ""
"Here, to ensure the reproducibility of results, a random seed can be "
"optionally set."
msgstr "在这里，为了确保结果的可重复性，可以选择性地设置一个随机种子。"

#: ../../source/example/supervised-learning.ipynb:60002
msgid ""
"In this step, a sample convolutional neural network (CNN) model is directly "
"defined upon the PyTorch framework and then loaded onto the device."
msgstr "在此步骤中，样本卷积神经网络（CNN）模型直接基于PyTorch框架定义，然后加载到设备上。"

#: ../../source/example/supervised-learning.ipynb:80002
msgid ""
"Setting dataset implies the selection of the task. The data loader now needs"
" to be initialized based on PyTorch's built-in support. Here, the package "
"`torchvision` must be installed in advance depending on your PyTorch "
"version, if it is not already available."
msgstr ""
"设置数据集意味着选择任务。现在需要基于PyTorch的内置支持初始化数据加载器。在这里，根据您的PyTorch版本，必须预先安装`torchvision`包，如果尚未安装的话。"

#: ../../source/example/supervised-learning.ipynb:80005
msgid ""
"In case the MNIST dataset is not already present in the `data_root` "
"directory, the `download=True` flag is set to ensure that the dataset will "
"be automatically downloaded. Therefore, the setup may take some time during "
"the first run."
msgstr ""
"如果 `data_root` 目录中尚未存在 MNIST 数据集，则设置 `download=True` "
"标志以确保数据集将被自动下载。因此，第一次运行时设置可能需要一些时间。"

#: ../../source/example/supervised-learning.ipynb:100002
msgid ""
"To accelerate subsequent processes, all MNIST data are pre-loaded for faster"
" execution. Below, three datasets are pre-loaded for different stages "
"&ndash; gradient descent training, neuroevolution fine-tuning, and model "
"testing."
msgstr ""
"为了加速后续过程，所有MNIST数据都被预加载以实现更快的执行。下面，三个数据集被预加载用于不同阶段——梯度下降训练、神经演化微调和模型测试。"

#: ../../source/example/supervised-learning.ipynb:100004
msgid ""
"It should be noted that this is an optional operation that trades space for "
"time. Its adoption depends on your GPU capacity, and it will always take "
"some time to prepare."
msgstr "需要注意的是，这是一个可选操作，用空间换取时间。其采用取决于您的GPU容量，并且总是需要一些时间来准备。"

#: ../../source/example/supervised-learning.ipynb:120002
msgid ""
"Here, a `model_test` function is pre-defined to simplify the evaluation of "
"the model's prediction accuracy on the test dataset during subsequent "
"stages."
msgstr "在这里，预先定义了一个 `model_test` 函数，以简化在后续阶段对模型在测试数据集上预测准确性的评估。"

#: ../../source/example/supervised-learning.ipynb:140002
msgid "Gradient Descent Training (Optional)"
msgstr "梯度下降训练（可选）"

#: ../../source/example/supervised-learning.ipynb:150002
msgid ""
"The gradient descent based model training is performed first. In this "
"example, this training is adopted to initialize the model, preparing it for "
"subsequent neuroevolution processes."
msgstr "基于梯度下降的模型训练首先进行。在这个例子中，这种训练用于初始化模型，为后续的神经演化过程做准备。"

#: ../../source/example/supervised-learning.ipynb:150004
msgid ""
"The model training process in PyTorch is compatible with neuroevolution in "
"EvoX, making it convenient to reuse the same model implementation for "
"further steps."
msgstr "在EvoX中，PyTorch的模型训练过程与神经演化兼容，使得在后续步骤中重用相同的模型实现变得方便。"

#: ../../source/example/supervised-learning.ipynb:180002
msgid "Neuroevolution Fine-Tuning"
msgstr "神经演化微调"

#: ../../source/example/supervised-learning.ipynb:190002
msgid ""
"Based on the pre-trained model from the previous gradient descent process, "
"neuroevolution is progressively applied to fine-tune the model."
msgstr "基于之前梯度下降过程中的预训练模型，神经演化逐步应用于微调模型。"

#: ../../source/example/supervised-learning.ipynb:190004
msgid ""
"First, the "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"component is used to flatten the weights of the pre-trained model into a "
"vector, which serves as the initial center individual for the subsequent "
"neuroevolution process."
msgstr ""
"首先，[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"组件用于将预训练模型的权重展平为一个向量，该向量作为后续神经演化过程的初始中心个体。"

#: ../../source/example/supervised-learning.ipynb:210002
msgid ""
"In case of algorithms specifically designed for neuroevolution, which can "
"directly accept a dictionary of batched parameters as input, the usage of "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) can "
"be unnecessary."
msgstr ""
"对于专门为神经演化设计的算法，它们可以直接接受批处理参数的字典作为输入，使用[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)可能是不必要的。"

#: ../../source/example/supervised-learning.ipynb:220002
msgid ""
"Additionally, a sample criterion is defined. Here, both the loss and "
"accuracy of the individual model are selected and weighted to serve as the "
"fitness function in the neuroevolution process. This step is customizable to"
" suit the optimization direction."
msgstr "此外，定义了一个示例标准。在这里，个体模型的损失和准确性都被选择并加权，以作为神经演化过程中的适应度函数。此步骤可以自定义以适应优化方向。"

#: ../../source/example/supervised-learning.ipynb:240002
msgid ""
"At the same time, similar to the gradient descent training and model testing"
" processes, the neuroevolution fine-tuning process is also encapsulated into"
" a function for convenient use in subsequent stages."
msgstr "同时，类似于梯度下降训练和模型测试过程，神经演化微调过程也被封装成一个函数，以便在后续阶段方便使用。"

#: ../../source/example/supervised-learning.ipynb:260002
msgid "Population-Based Neuroevolution Test"
msgstr "种群基础的神经演化测试"

#: ../../source/example/supervised-learning.ipynb:270002
msgid ""
"In this example, the population-based algorithm for neuroevolution is tested"
" first, using Particle Swarm Optimization "
"([PSO](#evox.algorithms.pso_variants.PSO)) as a representation. The "
"configuration for neuroevolution is similar to that of other optimization "
"tasks &ndash; we need to define the problem, algorithm, monitor, and "
"workflow, along with their respective `setup()` functions to complete the "
"initialization."
msgstr ""
"在这个例子中，基于种群的神经演化算法首先被测试，使用粒子群优化（[PSO](#evox.algorithms.pso_variants.PSO)）作为表示。神经演化的配置与其他优化任务类似——我们需要定义问题、算法、监控器和工作流，以及它们各自的`setup()`函数来完成初始化。"

#: ../../source/example/supervised-learning.ipynb:270004
msgid ""
"A key point to note here is that the population size (`POP_SIZE` in this "
"case) needs to be initialized in **both the problem and the algorithm** to "
"avoid potential errors."
msgstr "需要注意的一个关键点是，种群大小（在这种情况下为`POP_SIZE`）需要在**问题和算法**中都进行初始化，以避免潜在的错误。"

#: ../../source/example/supervised-learning.ipynb:310002
msgid "Single-Individual Neuroveolution Test"
msgstr "单个个体神经演化测试"

#: ../../source/example/supervised-learning.ipynb:320002
msgid ""
"Next, the single-individual algorithm based neuroevolution is tested. "
"Similar to the population-based case, we need to define the problem, "
"algorithm, monitor, and workflow, and call their respective `setup()` "
"functions during initialization. In this case, a random search strategy is "
"selected as the algorithm."
msgstr ""
"接下来，测试基于单个个体算法的神经演化。与基于种群的情况类似，我们需要定义问题、算法、监控器和工作流，并在初始化时调用它们各自的 `setup()` "
"函数。在这种情况下，选择随机搜索策略作为算法。"

#: ../../source/example/supervised-learning.ipynb:320004
msgid ""
"A key point to note here is that "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" should be set with `pop_size=None`, and "
"[`EvalMonitor`](#evox.workflows.EvalMonitor) should have `topk=1`, as only a"
" single individual is being searched. A careful hyper-parameter setup helps "
"avoid unnecessary issues."
msgstr ""
"需要注意的一个关键点是，[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" 应该设置为 `pop_size=None`，并且 [`EvalMonitor`](#evox.workflows.EvalMonitor) 应该设置为"
" `topk=1`，因为只搜索单个个体。仔细的超参数设置有助于避免不必要的问题。"

#: ../../source/guide/developer/1-modulebase.md:1
msgid "Working with Module in EvoX"
msgstr "在 EvoX 中使用模块"

#: ../../source/guide/developer/1-modulebase.md:3
msgid ""
"A **module** is a fundamental concept in programming that refers to a self-"
"contained unit of code designed to perform a specific task or a set of "
"related tasks."
msgstr "一个**模块**是编程中的一个基本概念，指的是一个自包含的代码单元，旨在执行特定任务或一组相关任务。"

#: ../../source/guide/developer/1-modulebase.md:5
msgid ""
"This notebook will introduce the basic module in EvoX: "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr "此笔记本将介绍 EvoX 中的基本模块：[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/1-modulebase.md:7
msgid "Introduction to Module"
msgstr "模块介绍"

#: ../../source/guide/developer/1-modulebase.md:9
msgid ""
"In the [Quick Start Documentation](#/guide/user/1-start) of the [User "
"Guide](#/guide/user/index), we have mentioned the basic running process in "
"EvoX:"
msgstr ""
"在[用户指南](#/guide/user/index)的[快速入门文档](#/guide/user/1-start)中，我们提到了EvoX的基本运行过程："

#: ../../source/guide/developer/1-modulebase.md:13
msgid "This process requires four basic class in EvoX:"
msgstr "在EvoX中，此过程需要四个基本类："

#: ../../source/guide/developer/1-modulebase.md:15
msgid "[`Algorithm`](#evox.core.components.Algorithm)"
msgstr "[`Algorithm`](#evox.core.components.Algorithm)"

#: ../../source/guide/developer/1-modulebase.md:16
msgid "[`Problem`](#evox.core.components.Problem)"
msgstr "[`Problem`](#evox.core.components.Problem)"

#: ../../source/guide/developer/1-modulebase.md:17
msgid "[`Monitor`](evox.core.components.Monitor)"
msgstr "[`Monitor`](evox.core.components.Monitor)"

#: ../../source/guide/developer/1-modulebase.md:18
msgid "[`Workflow`](#evox.core.components.Workflow)"
msgstr "抱歉，我需要更多的上下文或具体的文本内容来进行翻译。请提供需要翻译的具体文本。"

#: ../../source/guide/developer/1-modulebase.md:21
msgid ""
"It is necessary to provide a unified module for them. In EvoX, the four "
"classes are all inherited from the base module — "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"有必要为它们提供一个统一的模块。在EvoX中，这四个类都继承自基础模块——[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/1-modulebase.md:23
msgid "Module base"
msgstr "模块 base"

#: ../../source/guide/developer/1-modulebase.md:28
msgid "ModuleBase class"
msgstr "ModuleBase 类"

#: ../../source/guide/developer/1-modulebase.md:30
msgid ""
"The [`ModuleBase`](#evox.core.module.ModuleBase) class is inherited from "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)."
msgstr ""
"[`ModuleBase`](#evox.core.module.ModuleBase) 类继承自 "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)。"

#: ../../source/guide/developer/1-modulebase.md:32
msgid ""
"There are many methods in this class, and some important methods are here:"
msgstr "在这个类中有许多方法，这里是一些重要的方法："

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Method"
msgstr "方法"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Signature"
msgstr "签名"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`__init__`"
msgstr "`__init__`"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`(self, ...)`"
msgstr "`(self, ...)`"

#: ../../source/guide/developer/1-modulebase.md:23
msgid "Initialize the module."
msgstr "初始化模块。"

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`setup`"
msgstr "`设置`"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`(self, ...) -> self`"
msgstr "`(self, ...) -> self`"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Module initialization lines should be written in the overwritten method of "
"`setup` rather than `__init__`."
msgstr "模块初始化行应写在 `setup` 的重写方法中，而不是 `__init__` 中。"

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`load_state_dict`"
msgstr "`load_state_dict"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)`"
msgstr ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Copy parameters and buffers from `state_dict` into this module and its "
"descendants. It overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""
"将`state_dict`中的参数和缓冲区复制到此模块及其子模块中。它会覆盖[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)。"

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`add_mutable`"
msgstr "`add_mutable"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None`"
msgstr ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None"

#: ../../source/guide/developer/1-modulebase.md:41
msgid "Role of Module"
msgstr "模块的作用"

#: ../../source/guide/developer/1-modulebase.md:43
msgid ""
"In EvoX, the [`ModuleBase`](#evox.core.module.ModuleBase) could help to:"
msgstr "在 EvoX 中，[`ModuleBase`](#evox.core.module.ModuleBase) 可以帮助："

#: ../../source/guide/developer/1-modulebase.md:45
msgid "**Contain mutable values**"
msgstr "**包含可变值**"

#: ../../source/guide/developer/1-modulebase.md:47
msgid ""
"​\tThis module is an object-oriented one that can contain mutable values."
msgstr "该模块是一个面向对象的模块，可以包含可变值。"

#: ../../source/guide/developer/1-modulebase.md:49
msgid "**Support functional programming**"
msgstr "**支持函数式编程**"

#: ../../source/guide/developer/1-modulebase.md:51
msgid ""
"​\tFunctional programming model is supported via `self.state_dict()` and "
"`self.load_state_dict(...)`."
msgstr "支持函数式编程模型通过 `self.state_dict()` 和 `self.load_state_dict(...)"

#: ../../source/guide/developer/1-modulebase.md:53
msgid "**Standardize the initialization**:"
msgstr "**标准化初始化**:"

#: ../../source/guide/developer/1-modulebase.md:55
msgid ""
"​\tBasically, predefined submodule(s) which will be ADDED to this module and"
" accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr "基本上，预定义的子模块将被添加到此模块中，并在成员方法中访问，应该被视为“非静态成员”，而其他任何成员都应该被视为“静态成员”。"

#: ../../source/guide/developer/1-modulebase.md:57
msgid ""
"​\tThe module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr "建议将非静态成员的模块初始化写在重写的 `setup` 方法（或任何其他成员方法）中，而不是 `__init__` 中。"

#: ../../source/guide/developer/1-modulebase.md:59
msgid "Usage of Module"
msgstr "模块使用"

#: ../../source/guide/developer/1-modulebase.md:61
msgid ""
"Specifically, there are some rules for using "
"[`ModuleBase`](#evox.core.module.ModuleBase) in EvoX:"
msgstr "具体来说，在EvoX中使用[`ModuleBase`](#evox.core.module.ModuleBase)有一些规则："

#: ../../source/guide/developer/1-modulebase.md:63
msgid "Static methods"
msgstr "静态方法"

#: ../../source/guide/developer/1-modulebase.md:65
msgid "Static methods to be JIT shall be defined like:"
msgstr "要将静态方法定义为JIT，请这样定义："

#: ../../source/guide/developer/1-modulebase.md:74
msgid "Non-static Methods"
msgstr "非静态方法"

#: ../../source/guide/developer/1-modulebase.md:76
msgid ""
"If a method with python dynamic control flows like `if` were to be JIT, a "
"separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""
"如果一个方法使用了像 `if` 这样的 Python 动态控制流并希望进行 JIT，则应使用一个单独的静态方法，并使用 `jit(..., "
"trace=False)` 或 `torch.jit.script_if_tracing"

#: ../../source/guide/developer/1-modulebase.md:102
msgid "Supporting for JIT and non-JIT functions"
msgstr "支持 JIT 和非 JIT 函数"

#: ../../source/guide/developer/1-modulebase.md:104
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase) is usually used with "
"`jit_class` to automatically JIT all non-magic member methods:"
msgstr ""
"[`ModuleBase`](#evox.core.module.ModuleBase) 通常与 `jit_class` 一起使用，以自动 JIT "
"所有非魔法成员方法："

#: ../../source/guide/developer/1-modulebase.md:128
msgid ""
"An example of one module inherited from the "
"[`ModuleBase`](#evox.core.module.ModuleBase) is like:"
msgstr "从[`ModuleBase`](#evox.core.module.ModuleBase)继承的一个模块示例如下："

#: ../../source/guide/developer/1-modulebase.md:150
msgid ""
"For more details, please look through [the Module in "
"EvoX](#evox.core.module)."
msgstr "有关更多详细信息，请查看[the Module in EvoX](#evox.core.module)。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:10002
msgid "Optimizing Development for EvoX via PyTorch Advanced Techniques"
msgstr "通过 PyTorch 高级技术优化 EvoX 的开发"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20002
msgid "Basic Optimization Support for Functions in PyTorch"
msgstr "PyTorch中函数的基本优化支持"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20004
msgid ""
"PyTorch provides fundamental optimization support for functions, primarily "
"through vectorizing map (vmap) operations and Just-In-Time (JIT) "
"compilation. These techniques enable efficient batch processing and enhance "
"execution performance, respectively. Introductions of these optimizations "
"are provided in the following sections."
msgstr ""
"PyTorch "
"提供了对函数的基本优化支持，主要通过矢量化映射（vmap）操作和即时编译（JIT）实现。这些技术分别使得批处理更加高效并提升执行性能。关于这些优化的介绍将在以下部分提供。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30002
msgid "Batch Processing Support through Vectorizing Map in PyTorch"
msgstr "在 PyTorch 中通过矢量化映射支持批处理"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30004
msgid ""
"Vectorizing map, implemented in PyTorch as "
"[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html), "
"is a powerful tool that takes a callable function and returns a batched "
"version of it. According to specified strategy, this new function vectorizes"
" the operations of the original one, which facilitates efficient batch "
"processing. In EvoX, for example, this feature plays a crucial role in "
"hyperparameter optimization (HPO)."
msgstr ""
"在PyTorch中实现的向量化映射[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html)是一个强大的工具，它接受一个可调用函数并返回其批处理版本。根据指定的策略，这个新函数对原始函数的操作进行向量化，从而促进高效的批处理。在EvoX中，例如，这一特性在超参数优化（HPO）中起着至关重要的作用。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50002
msgid "Just-In-Time (JIT) Support in PyTorch"
msgstr "在PyTorch中支持即时编译（Just-In-Time, JIT）"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50004
msgid ""
"In PyTorch, "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" and "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" provide two distinct types of JIT tools, supporting function performance "
"optimization through tracing and scripting, respectively."
msgstr ""
"在 PyTorch "
"中，[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" 和 "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" 提供了两种不同类型的 JIT 工具，分别通过追踪和脚本化支持函数性能优化。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50006
msgid ""
"Based on the tracing strategy, the `torch.jit.trace` method offers higher "
"parsing speed and broader compatibility, such as with `torch.vmap` "
"operations. Although it provides excellent support for simple functions, it "
"is not suitable for complex tasks involving dynamic if-else branches and "
"loop control flows."
msgstr ""
"根据追踪策略，`torch.jit.trace` 方法提供了更高的解析速度和更广泛的兼容性，例如与 `torch.vmap` "
"操作的兼容性。尽管它对简单函数提供了出色的支持，但不适用于涉及动态 if-else 分支和循环控制流的复杂任务。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:70002
msgid ""
"In the example below, the traced `vmap` function successfully returns the "
"correct code representation:"
msgstr "在下面的例子中，跟踪的 `vmap` 函数成功返回了正确的代码表示："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:90002
msgid ""
"However, dynamic python control-flow cannot be traced correctly and a "
"warning will be raised:"
msgstr "然而，动态的 Python 控制流无法被正确追踪，并且会发出警告："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:110002
msgid ""
"Alternatively, the `torch.jit.script` method, which adopts a scripting "
"strategy, is better suited for complex tasks that involve dynamic control "
"flows but has limited compatibility."
msgstr "或者，采用脚本策略的 `torch.jit.script` 方法更适合涉及动态控制流的复杂任务，但兼容性有限。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:120002
msgid ""
"In this example, the same `vmap_sample_func` function, after being scripted,"
" returns an **incorrect** code representation:"
msgstr "在这个例子中，相同的 `vmap_sample_func` 函数，在被脚本化后，返回了一个**不正确**的代码表示："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:140002
msgid "Yet, it can correctly deal with complex dynamic python control flow:"
msgstr "然而，它可以正确处理复杂的动态 Python 控制流："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:160003
msgid ""
"`torch.jit.script` relies on type hint to work properly. For example, any "
"unannotated input argument is treated as a `torch.Tensor` while you can "
"annotate some input arguments to be python types to make `torch.jit.script` "
"work as intended."
msgstr ""
"`torch.jit.script` 依赖类型提示才能正常工作。例如，任何未注释的输入参数都会被视为 "
"`torch.Tensor`，而你可以将一些输入参数注释为 python 类型，以使 `torch.jit.script` 按预期工作。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170002
msgid "Combined Usage of JIT and Vectorizing Map in PyTorch"
msgstr "在PyTorch中结合使用JIT和Vectorizing Map"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170004
msgid ""
"Based on the introductions above, when `torch.jit.trace` and "
"`torch.jit.script` are used in combination with `torch.vmap`, coordination "
"is required due to compatibility considerations."
msgstr ""
"根据上述介绍，当 `torch.jit.trace` 和 `torch.jit.script` 与 `torch.vmap` "
"结合使用时，由于兼容性考虑，需要进行协调。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170006
msgid ""
"The figure below illustrates the relationship between `torch.jit.script`, "
"`torch.jit.trace`, and `torch.vmap`, highlighting their mutual invocation "
"paths. If module A invokes module B, it implies that B can be called by A."
msgstr ""
"下图说明了 `torch.jit.script`、`torch.jit.trace` 和 `torch.vmap` "
"之间的关系，突出显示了它们的相互调用路径。如果模块 A 调用模块 B，这意味着 B 可以被 A 调用。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170008
msgid "JIT introduction"
msgstr "JIT 介绍"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170013
msgid ""
"For detailed usage of JIT and vectorizing map on PyTorch, please refer to "
"the official PyTorch documentation for "
"[TorchScript](#https://pytorch.org/docs/stable/jit.html) and "
"[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)."
msgstr ""
"有关在 PyTorch 上使用 JIT 和矢量化映射的详细信息，请参阅 PyTorch 官方文档中的 "
"[TorchScript](#https://pytorch.org/docs/stable/jit.html) 和 "
"[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180002
msgid "Specific Optimization Support in EvoX"
msgstr "EvoX中的特定优化支持"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180004
msgid ""
"Within EvoX, most functions are defined inside classes, particularly "
"subclasses of [`ModuleBase`](#evox.core.module.ModuleBase). To provide more "
"comprehensive optimization supports, EvoX offers specific enhancements."
msgstr ""
"在 EvoX 中，大多数函数是在类中定义的，特别是 [`ModuleBase`](#evox.core.module.ModuleBase) "
"的子类中。为了提供更全面的优化支持，EvoX 提供了特定的增强功能。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:190002
msgid ""
"Using JIT to Subclasses of [`ModuleBase`](#evox.core.module.ModuleBase)"
msgstr "使用 JIT 到 [`ModuleBase`](#evox.core.module.ModuleBase) 的子类"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:200002
msgid ""
"For better understanding of this part, we need to explain three important "
"functions in EvoX: [`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](l#evox.core.jit_util.jit)."
msgstr ""
"为了更好地理解这一部分，我们需要解释EvoX中的三个重要函数：[`jit_class`](#evox.core.module.jit_class)、[`vmap`](#evox.core.jit_util.vmap)和[`jit`](#evox.core.jit_util.jit)。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:210002
msgid "[`jit_class`](#evox.core.module.jit_class) Function"
msgstr "[`jit_class`](#evox.core.module.jit_class) 函数"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220002
msgid ""
"[`jit_class`](#evox.core.module.jit_class) is a helper function used to "
"Just-In-Time (JIT) script of "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" or trace "
"([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
"jit-trace-module)) all member methods of the input class."
msgstr ""
"[`jit_class`](#evox.core.module.jit_class) 是一个辅助函数，用于对输入类的所有成员方法进行 Just-In-"
"Time (JIT) 脚本化的 "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" 或跟踪 "
"([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
"jit-trace-module))。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220004
msgid "[`jit_class`](#evox.core.module.jit_class) has two parameters:"
msgstr "[`jit_class`](#evox.core.module.jit_class) 有两个参数："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220006
msgid "`cls`: the original class whose member methods are to be lazy JIT."
msgstr "`cls`: 原始类，其成员方法将被懒惰 JIT。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220007
msgid ""
"`trace`: whether to trace the module or to script the module. Default to "
"`False`."
msgstr "`trace`: 是否追踪模块或将模块脚本化。默认值为 `False`。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220010
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with [`jit_class`](#evox.core.module.jit_class), the workflow(s) "
"will do the trick for you."
msgstr ""
"在许多情况下，不需要用[`jit_class`](#evox.core.module.jit_class)包装您的自定义算法或问题，工作流将为您解决问题。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220011
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional "
"(the `use_state` function will be explained in the next part)."
msgstr ""
"在 `trace=True` 的情况下，所有成员函数都会被有效地修改为额外返回 `self`，因为副作用无法被追踪。如果你想保留副作用，请设置 "
"`trace=False` 并使用 `use_state` 函数来包装成员方法以生成纯函数（`use_state` 函数将在下一部分中解释）。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:230003
msgid "[`vmap`](#evox.core.jit_util.vmap) Function"
msgstr "[`vmap`](#evox.core.jit_util.vmap) 函数"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:240002
msgid ""
"[`vmap`](#evox.core.jit_util.vmap) function vectorized map the given "
"function to its mapped version. Based on "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html), we "
"made many improvements, and you can see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""
"[`vmap`](#evox.core.jit_util.vmap) 函数将给定函数矢量化映射到其映射版本。基于 "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html)，我们进行了许多改进，您可以查看"
" [`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) "
"以获取更多信息。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:250002
msgid "[`jit`](#evox.core.jit_util.jit) Function"
msgstr "[`jit`](#evox.core.jit_util.jit) 函数"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260002
msgid ""
"[`jit`](#evox.core.jit_util.jit) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""
"[`jit`](#evox.core.jit_util.jit) 使用 "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) 或 "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`) 编译给定的 `func"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260007
msgid ""
"With `trace=True`, `torch.jit.trace` cannot use SAME example input arguments"
" for function of DIFFERENT parameters,e.g., you cannot pass `tensor_a, "
"tensor_a` to `torch.jit.trace`d version of `f(x: torch.Tensor, y: "
"torch.Tensor)`."
msgstr ""
"在 `trace=True` 的情况下，`torch.jit.trace` 不能对具有不同参数的函数使用相同的示例输入参数，例如，你不能将 "
"`tensor_a, tensor_a` 传递给 `torch.jit.trace` 版本的 `f(x: torch.Tensor, y: "
"torch.Tensor)"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260008
msgid ""
"With `trace=False`, `torch.jit.script` cannot contain `vmap` expressions "
"directly, please wrap them with `jit(..., trace=True)` or `torch.jit.trace`."
msgstr ""
"在 `trace=False` 的情况下，`torch.jit.script` 不能直接包含 `vmap` 表达式，请使用 `jit(..., "
"trace=True)` 或 `torch.jit.trace` 包装它们。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260011
msgid ""
"In the [Working with Module in EvoX](#/guide/developer/1-modulebase), we "
"have briefly introduced some rules about the methods inside a subclass of "
"the [`ModuleBase`](#evox.core.module.ModuleBase) . Now that "
"[`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](#evox.core.jit_util.jit) have"
" been explained, we will explain more rules and provide some specific hints."
msgstr ""
"在 [EvoX 中的模块工作](#/guide/developer/1-modulebase) 中，我们简要介绍了关于 "
"[`ModuleBase`](#evox.core.module.ModuleBase) 子类中方法的一些规则。现在 "
"[`jit_class`](#evox.core.module.jit_class)、[`vmap`](#evox.core.jit_util.vmap)"
" 和 [`jit`](#evox.core.jit_util.jit) 已经被解释，我们将解释更多规则并提供一些具体提示。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:270002
msgid "Definition of Static Methods Inside the Subclass"
msgstr "子类中静态方法的定义"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:280002
msgid "Inside the subclass, static methods to be JIT shall be defined like:"
msgstr "在子类中，静态方法要被 JIT 定义为："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:290002
msgid "Definition of Non-static Methods Inside the Subclass"
msgstr "在子类中定义非静态方法"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300002
msgid ""
"If a method with **Python dynamic control flows** like `if` were to be JIT, "
"a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""
"如果一个方法使用了**Python动态控制流**，例如`if`，并且需要进行JIT，那么应使用一个独立的静态方法，并使用`jit(..., "
"trace=False)`或`torch.jit.script_if_tracing"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300035
msgid ""
"Dynamic control flow in Python refers to control structures that change "
"dynamically based on conditions at runtime. `if...elif...else` Conditional "
"Statements, `for`loop and `while` loop are all dynamic control flows. If you"
" have to use them when defining non-static Methods inside the subclass of "
"[`ModuleBase`](#evox.core.module.ModuleBase), please follow the above rule."
msgstr ""
"在Python中，动态控制流是指根据运行时的条件动态变化的控制结构。`if...elif...else` 条件语句、`for` 循环和 `while` "
"循环都是动态控制流。如果在定义 [`ModuleBase`](#evox.core.module.ModuleBase) "
"子类中的非静态方法时必须使用它们，请遵循上述规则。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:310002
msgid "Invocation of External Methods Inside the Subclass"
msgstr "调用子类中的外部方法"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:320002
msgid ""
"Inside the subclass, external JIT methods can be invocated by the class "
"methods to be JIT:"
msgstr "在子类中，外部 JIT 方法可以通过类方法调用以实现 JIT："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:330002
msgid "Automatically JIT for the Subclass Used with `jit_class`"
msgstr "自动为使用 `jit_class` 的子类进行 JIT 处理"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:340002
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase)  and its subclasses are usually"
" used with [`jit_class`](#evox.core.module.jit_class) to automatically JIT "
"all non-magic member methods:"
msgstr ""
"[`ModuleBase`](#evox.core.module.ModuleBase) 及其子类通常与 "
"[`jit_class`](#evox.core.module.jit_class) 一起使用，以自动JIT所有非魔术成员方法："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:350002
msgid "Invocation of External Vmap-wrapped Methods Inside the Subclass"
msgstr "在子类中调用外部 Vmap 包装的方法"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360002
msgid ""
"Inside the subclass, external vmap-wrapped methods can be invocated by the "
"class methods to be JIT:"
msgstr "在子类内部，外部 vmap 包装的方法可以通过类方法调用以实现 JIT："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360034
msgid ""
"If method A invokes vmap-wrapped method B, then A and all methods invoke "
"method A can not be vmap-wrapped again."
msgstr "如果方法 A 调用 vmap 包装的方法 B，那么 A 和所有调用方法 A 的方法不能再次被 vmap 包装。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:370002
msgid "Internal Vmap-wrapped Methods Inside the Subclass"
msgstr "子类内部的 Vmap 包装方法"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380002
msgid ""
"Inside the subclass, internal vmap-wrapped methods can be  JIT by using the "
"[`trace_impl`](#evox.core.module.trace_impl):"
msgstr ""
"在子类内部，可以使用 [`trace_impl`](#evox.core.module.trace_impl) 对内部 vmap 包装的方法进行 "
"JIT。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380040
msgid ""
"If a class method use [`trace_impl`](#evox.core.module.trace_impl), it will "
"be only available in the trace mode. More details about `trace_impl` will be"
" shown in the next part."
msgstr ""
"如果一个类方法使用了[`trace_impl`](#evox.core.module.trace_impl)，它将仅在追踪模式下可用。关于`trace_impl`的更多细节将在下一部分展示。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390002
msgid "Using `@trace_impl` and `@vmap_impl`"
msgstr "使用 `@trace_impl` 和 `@vmap_impl"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390004
msgid ""
"When designing a function or method, you may not always consider whether it "
"is `JIT`-compatible. However, this property becomes crucial in specific "
"scenarios, such as solving Hyperparameter Optimization (HPO) problems. For "
"more details on deploying HPO with EvoX, refer to [Efficient HPO with "
"EvoX](#/guide/user/3-hpo)."
msgstr ""
"在设计函数或方法时，您可能并不总是考虑它是否与`JIT`兼容。然而，这一特性在特定场景中变得至关重要，例如解决超参数优化（HPO）问题。有关使用EvoX部署HPO的更多详细信息，请参阅[Efficient"
" HPO with EvoX](#/guide/user/3-hpo)。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390006
msgid ""
"A typical characteristic of such problems is that only certain parts of the "
"algorithm need modification—for instance, the `step` method of an algorithm."
" This allows you to avoid rewriting the entire algorithm. In such cases, you"
" can use the `@trace_impl` or `@vmap_impl` decorator to rewrite the function"
" as a trace-JIT-time or vmap-JIT-time proxy for the specified `target` "
"method."
msgstr ""
"这类问题的一个典型特征是，只需要修改算法的某些部分——例如，算法的 `step` 方法。这使您可以避免重写整个算法。在这种情况下，您可以使用 "
"`@trace_impl` 或 `@vmap_impl` 装饰器，将函数重写为指定 `target` 方法的 trace-JIT-time 或 "
"vmap-JIT-time 代理。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390008
msgid ""
"The decorators [`@trace_impl`](#trace_impl) and [`@vmap_impl`](#vmap_impl) "
"accept a single input parameter: the target method invoked when not "
"tracing/vmapping JIT. These decorators are applicable **only** to member "
"methods within a `jit_class`."
msgstr ""
"装饰器 [`@trace_impl`](#trace_impl) 和 [`@vmap_impl`](#vmap_impl) "
"接受一个输入参数：在不进行追踪/vmap JIT 时调用的目标方法。这些装饰器**仅**适用于 `jit_class` 中的成员方法。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390010
msgid ""
"Since the annotated function serves as a rewritten version of the target "
"function, it must maintain identical input/output signatures (e.g., number "
"and types of arguments). Otherwise, the resulting behavior is undefined."
msgstr "由于注释函数作为目标函数的重写版本，它必须保持相同的输入/输出签名（例如，参数的数量和类型）。否则，结果行为是未定义的。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390012
msgid ""
"If the annotated function is intended for use with `vmap`, it must satisfy "
"three additional constraints:"
msgstr "如果注释的函数打算与`vmap`一起使用，它必须满足三个额外的约束："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390014
msgid ""
"**No In-Place Operations on Attributes:** The algorithm must not include "
"methods that perform in-place operations on its attributes."
msgstr "**禁止对属性进行原地操作：** 算法不得包含对其属性执行原地操作的方法。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390029
msgid ""
"**Avoid Python Control Flow:** The code logic must not rely on Python "
"control flow structures. To handle Python control flow, use "
"[`TracingCond`](#TracingCond), [`TracingWhile`](#TracingWhile), and "
"[`TracingSwitch`](#TracingSwitch)."
msgstr ""
"**避免使用 Python 控制流：** 代码逻辑不能依赖于 Python 控制流结构。要处理 Python 控制流，请使用 "
"[`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
"[`TracingSwitch`](#TracingSwitch)。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390079
msgid ""
"**Avoid In-Place Operations on `self`:** Vectorized map in-place operations "
"on `self` are not well-defined and cannot be compiled. Even if it is "
"compiled successfully, you can still silently get incorrect results."
msgstr ""
"**避免对 `self` 进行就地操作：** 向量化映射对 `self` "
"的就地操作定义不明确，无法编译。即使成功编译，您仍可能会悄无声息地得到错误的结果。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390082
msgid "Using `use_state`"
msgstr "使用 `use_state`"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390084
msgid ""
"[`use_state`](#use_state) transforms a given stateful function (which "
"performs in-place alterations on `nn.Module`s) into a pure-functional "
"version that receives an additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and returns the altered state."
msgstr ""
"[`use_state`](#use_state) 将给定的有状态函数（对 `nn.Module` 进行就地更改）转换为纯函数版本，该版本接收一个额外的"
" `state` 参数（类型为 `Dict[str, torch.Tensor]`），并返回更改后的状态。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390086
msgid ""
"The input `func` is the stateful function to be transformed or its generator"
" function, and `is_generator` specifies whether `func` is a function or a "
"function generator (e.g., a lambda that returns the stateful function). It "
"defaults to `True`."
msgstr ""
"输入 `func` 是要转换的有状态函数或其生成器函数，而 `is_generator` 指定 `func` "
"是一个函数还是一个函数生成器（例如，返回有状态函数的 lambda）。默认值为 `True"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390088
msgid "Here is a simple example:"
msgstr "以下是一个简单的例子："

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390129
msgid "Using `core._vmap_fix`"
msgstr "使用 `core._vmap_fix"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390131
msgid ""
"The module [`_vmap_fix`](#_vmap_fix) provides useful functions. After the "
"automatic import, `_vmap_fix` enables `torch.vmap` to be correctly traced by"
" `torch.jit.trace`, while resolving issues such as random number handling "
"that couldn't be properly traced during the `vmap` process. It also provides"
" the `debug_print` function, which allows dynamic printing of Tensor values "
"during both `vmap` and tracing."
msgstr ""
"模块 [`_vmap_fix`](#_vmap_fix) 提供了有用的函数。在自动导入后，`_vmap_fix` 使 `torch.vmap` 能够被 "
"`torch.jit.trace` 正确追踪，同时解决了在 `vmap` 过程中无法正确追踪的随机数处理等问题。它还提供了 `debug_print` "
"函数，允许在 `vmap` 和追踪过程中动态打印 Tensor 值。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390133
msgid ""
"Detailed information can be found in the [`_vmap_fix`](#_vmap_fix) "
"documentation."
msgstr "详细信息可以在[`_vmap_fix`](#_vmap_fix)文档中找到。"

#: ../../source/guide/developer/3-custom-alg-pro.md:1
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:3
msgid ""
"In this chapter, we will introduce how to implement your own algorithms and "
"problems in EvoX."
msgstr "在本章节中，我们将介绍如何在EvoX中实现您自己的算法和问题。"

#: ../../source/guide/developer/3-custom-alg-pro.md:5
msgid "Layout of the algorithms and problems"
msgstr "算法和问题的布局"

#: ../../source/guide/developer/3-custom-alg-pro.md:7
msgid ""
"In most traditional EC libraries, algorithms usually call the objective "
"function internally, which gives the following layout:"
msgstr "在大多数传统的进化计算（EC）库中，算法通常在内部调用目标函数，其布局如下："

#: ../../source/guide/developer/3-custom-alg-pro.md:15
msgid "**But in EvoX, we have a flat layout:**"
msgstr "但在 EvoX 中，我们使用了扁平化布局："

#: ../../source/guide/developer/3-custom-alg-pro.md:21
msgid ""
"This layout makes both algorithms and problems more universal: an algorithm "
"can optimize different problems, while a problem can also be suitable for "
"many algorithms."
msgstr "这种布局使得算法和问题更加通用：一个算法可以优化不同的问题，而一个问题也可以适用于许多算法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:25
msgid "Algorithm class"
msgstr "Algorithm 类"

#: ../../source/guide/developer/3-custom-alg-pro.md:27
msgid ""
"The [`Algorithm`](#evox.core.components.Algorithm) class is inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"[`Algorithm`](#evox.core.components.Algorithm) 类继承自 "
"[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/3-custom-alg-pro.md:29
msgid ""
"**In total,** **there are 5 methods (2 methods are optional) that we need to"
" implement:**"
msgstr "总共有5个方法（其中2个方法是可选的）需要我们实现："

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the algorithm instance, for example, the population size (keeps "
"constant during iteration), hyper-parameters (can only be set by HPO problem"
" wrapper or initialized here), and / or mutable tensors (can be modified on "
"the fly)."
msgstr ""
"初始化算法实例，例如，种群大小（在迭代过程中保持不变）、超参数（只能通过HPO问题包装器设置或在此初始化）、和/或可变张量（可以动态修改）。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`setup` (optional)"
msgstr "`setup`（可选）"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the mutable submodule(s) of the algorithm. See "
"[`ModuleBase`](#evox.core.module.ModuleBase). Usually, it is not necessary "
"to overwrite this method."
msgstr ""
"初始化算法的可变子模块。请参阅[`ModuleBase`](#evox.core.module.ModuleBase)。通常，不需要重写此方法。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`step`"
msgstr "步骤"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`(self)`"
msgstr "`(self)"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "Perform a normal optimization iteration step of the algorithm."
msgstr "执行算法的正常优化迭代步骤。"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`init_step` (optional)"
msgstr "`init_step`（可选）"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Perform the first step of the optimization of the algorithm. If this method "
"were not overwritten, the `step` method would be invoked instead."
msgstr "执行算法优化的第一步。如果此方法未被覆盖，将调用 `step` 方法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:39
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable submodule(s) initialization cannot. Therefore, multiple calls of "
"`setup` for repeated initializations are possible if the overwritten `setup`"
" method invokes the `setup()` of "
"[`ModuleBase`](#evox.core.module.ModuleBase) first."
msgstr ""
"静态初始化仍然可以在`__init__`中编写，而可变子模块的初始化则不能。因此，如果重写的`setup`方法首先调用[`ModuleBase`](#evox.core.module.ModuleBase)的`setup()`，则可以多次调用`setup`进行重复初始化。"

#: ../../source/guide/developer/3-custom-alg-pro.md:41
msgid ""
"If such `setup` method in [`ModuleBase`](#evox.core.module.ModuleBase) is "
"not suitable for your algorithm, you can override the `setup` method when "
"you create your own algorithm class."
msgstr ""
"如果在[`ModuleBase`](#evox.core.module.ModuleBase)中的这种`setup`方法不适合你的算法，你可以在创建自己的算法类时重写`setup`方法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:45
msgid "Problem class"
msgstr "问题类"

#: ../../source/guide/developer/3-custom-alg-pro.md:47
msgid ""
"The [`Problem`](#evox.core.components.Problem) class is also inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"[`Problem`](#evox.core.components.Problem) 类也继承自 "
"[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/3-custom-alg-pro.md:49
msgid ""
"However, the Problem class is quite simple. **Beside the `__init__` method, "
"the only necessary method is the `evaluate` method.**"
msgstr "但是，Problem 类非常简单。**除了 `__init__` 方法，唯一必须的方法是 `evaluate` 方法。**"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`evaluate`"
msgstr "评估"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`(self, pop: torch.Tensor) -> torch.Tensor`"
msgstr "`(self, pop: torch.Tensor) -> torch.Tensor"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Evaluate the fitness of the given population."
msgstr "评估给定种群的适应度。"

#: ../../source/guide/developer/3-custom-alg-pro.md:56
msgid ""
"However, the type of `pop` argument in `evaluate` can be changed to other "
"JIT-compatible types in the overwritten method."
msgstr "然而，在重写的方法中，`evaluate` 中 `pop` 参数的类型可以更改为其他与 JIT 兼容的类型。"

#: ../../source/guide/developer/3-custom-alg-pro.md:59
msgid "Example"
msgstr "样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:61
msgid ""
"Here we give an example of **implementing a PSO algorithm that solves the "
"Sphere problem**."
msgstr "这里我们给出一个**实现一个解决Sphere问题的PSO算法的例子**。"

#: ../../source/guide/developer/3-custom-alg-pro.md:63
msgid "Pseudo-code of the example"
msgstr "示例的伪代码"

#: ../../source/guide/developer/3-custom-alg-pro.md:65
msgid "Here is a pseudo-code:"
msgstr "以下是一段伪代码："

#: ../../source/guide/developer/3-custom-alg-pro.md:81
msgid ""
"And here is what each part of the algorithm and the problem corresponds to "
"in EvoX."
msgstr "以下是算法和问题中每个部分在EvoX中的对应关系。"

#: ../../source/guide/developer/3-custom-alg-pro.md:101
msgid ""
"Particle Swarm Optimization (PSO) is a population-based meta-heuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr "粒子群优化（PSO）是一种基于种群的元启发式算法，灵感来自鸟类和鱼类的社会行为。它被广泛用于解决连续和离散优化问题。"

#: ../../source/guide/developer/3-custom-alg-pro.md:212
msgid "Now, you can initiate a workflow and run it."
msgstr "现在，您可以启动一个工作流并运行它。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:1
msgid "Transformation from MATLAB to PyTorch and EvoX"
msgstr "从MATLAB到PyTorch和EvoX的转换"

#: ../../source/guide/developer/4-transfer-from-matlab.md:3
msgid ""
"This document aims to guide MATLAB users in transitioning to PyTorch and "
"EvoX for evolutionary computation. We will highlight the core differences "
"between MATLAB and PyTorch in terms of syntax, data structures, and "
"workflow. We will then illustrate these differences using a Particle Swarm "
"Optimization (PSO) example in both MATLAB and PyTorch."
msgstr ""
"本文档旨在指导MATLAB用户过渡到PyTorch和EvoX进行演化计算。我们将重点介绍MATLAB和PyTorch在语法、数据结构和工作流方面的核心差异。然后，我们将通过在MATLAB和PyTorch中使用粒子群优化（PSO）示例来说明这些差异。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:5
msgid "Syntax Differences"
msgstr "语法差异"

#: ../../source/guide/developer/4-transfer-from-matlab.md:7
msgid "Array Creation and Indexing"
msgstr "数组创建和索引"

#: ../../source/guide/developer/4-transfer-from-matlab.md:9
#: ../../source/guide/developer/4-transfer-from-matlab.md:23
#: ../../source/guide/developer/4-transfer-from-matlab.md:43
#: ../../source/guide/developer/4-transfer-from-matlab.md:57
#: ../../source/guide/developer/4-transfer-from-matlab.md:69
#: ../../source/guide/developer/4-transfer-from-matlab.md:81
#: ../../source/guide/developer/4-transfer-from-matlab.md:91
msgid "MATLAB"
msgstr "MATLAB"

#: ../../source/guide/developer/4-transfer-from-matlab.md:11
msgid "Uses 1-based indexing."
msgstr "使用从1开始的索引。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:12
msgid ""
"Vectors and matrices are declared using square brackets and semicolons "
"(e.g., `[1 2 3; 4 5 6]`). Random initialization with `rand()` returns values"
" in the interval $[0, 1)$."
msgstr ""
"向量和矩阵使用方括号和分号声明（例如，`[1 2 3; 4 5 6]`）。使用 `rand()` 进行随机初始化时，返回的值在区间 $[0, 1)$ "
"内。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:13
msgid ""
"Slicing is performed using the `(start:end)` syntax and utilizes 1-based "
"indexing."
msgstr "切片使用 `(start:end)` 语法进行，并使用从1开始的索引。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:15
#: ../../source/guide/developer/4-transfer-from-matlab.md:32
#: ../../source/guide/developer/4-transfer-from-matlab.md:49
#: ../../source/guide/developer/4-transfer-from-matlab.md:62
#: ../../source/guide/developer/4-transfer-from-matlab.md:74
msgid "PyTorch"
msgstr "PyTorch"

#: ../../source/guide/developer/4-transfer-from-matlab.md:17
msgid "Uses 0-based indexing."
msgstr "使用从0开始的索引。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:18
msgid ""
"Arrays (tensors) are typically created using constructors like "
"`torch.rand()`, `torch.zeros()`, or Python lists converted to tensors with "
"`torch.tensor()`."
msgstr ""
"数组（张量）通常使用构造函数创建，例如 `torch.rand()`、`torch.zeros()`，或将 Python 列表转换为张量的 "
"`torch.tensor()"

#: ../../source/guide/developer/4-transfer-from-matlab.md:19
msgid "Slicing is done using `[start:end]` with 0-based indices."
msgstr "切片使用 `[start:end]`，索引从0开始。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:21
msgid "Matrix Computation"
msgstr "矩阵计算"

#: ../../source/guide/developer/4-transfer-from-matlab.md:25
msgid "Performs linear algebraic matrix multiplication by `*`."
msgstr "通过 `*` 执行线性代数矩阵乘法。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:26
msgid ""
"Uses `.*` to multiply corresponding elements of matrices of the same size."
msgstr "使用 `.*` 来逐元素相乘相同大小的矩阵。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:27
msgid "`/` represents the matrix right division."
msgstr "`/` 表示矩阵右除法。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:28
msgid "`.^` represents the element-wise power."
msgstr "`.^` 表示元素级幂。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:29
msgid ""
"Trailing and leading dimension(s) of tensors with length 1 is/are "
"**ignored**."
msgstr "张量中长度为1的尾部和头部维度将被**忽略**。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:30
msgid ""
"Automatically find broadcastable dimensions for element-wise operations and "
"perform **implicit** dimension extension."
msgstr "自动查找元素级操作的可广播维度，并执行**隐式**维度扩展。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:34
msgid ""
"Performs linear algebraic matrix multiplication by `@` or `torch.matmul()`."
msgstr "执行线性代数矩阵乘法通过 `@` 或 `torch.matmul()"

#: ../../source/guide/developer/4-transfer-from-matlab.md:35
msgid ""
"Directly uses `*` to multiply corresponding elements of tensors of the same "
"shape or broadcastable shapes."
msgstr "直接使用 `*` 来乘以相同形状或可广播形状的张量的对应元素。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:36
msgid "`/` represents the element-wise division."
msgstr "`/` 表示逐元素除法。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:37
msgid "`**` represents the element-wise power."
msgstr "`**` 表示元素级幂。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:38
msgid ""
"Dimension(s) of tensors with length 1 is/are **preserved** and treated as "
"**broadcast dimension**."
msgstr "张量长度为1的维度被**保留**并视为**广播维度**。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:39
msgid ""
"**Prevent** most implicit dimension extension, broadcast dimension(s) are "
"usually required."
msgstr "**防止**大多数隐式维度扩展，通常需要广播维度。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:41
msgid "Functions and Definitions"
msgstr "函数和定义"

#: ../../source/guide/developer/4-transfer-from-matlab.md:45
msgid "A function is defined by the `function` keyword."
msgstr "一个函数由 `function` 关键字定义。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:46
msgid ""
"A file can contain multiple functions, but typically the primary function "
"shares the file name."
msgstr "一个文件可以包含多个函数，但通常主要函数与文件名相同。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:47
msgid ""
"Anonymous functions (e.g., `@(x) sum(x.^2)`) are used for short inline "
"calculations."
msgstr "匿名函数（例如，`@(x) sum(x.^2)`）用于简短的内联计算。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:51
msgid ""
"Functions are defined using the def keyword, typically within a single `.py`"
" file or module."
msgstr "函数使用 `def` 关键字定义，通常在一个 `.py` 文件或模块中。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:52
msgid ""
"Classes are used to encapsulate data and methods in an object-oriented "
"manner."
msgstr "类用于以面向对象的方式封装数据和方法。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:53
msgid ""
"Lambdas serve as short anonymous functions (`lambda x: x.sum()`), but multi-"
"line lambdas are not allowed."
msgstr "Lambdas 作为简短的匿名函数使用（`lambda x: x.sum()`），但不允许使用多行 lambdas。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:55
msgid "Control Flow"
msgstr "控制流"

#: ../../source/guide/developer/4-transfer-from-matlab.md:59
msgid "Uses for `i = 1:N` ... `end` loops with 1-based indexing."
msgstr "`i = 1:N` 循环使用1为基准的索引。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:60
msgid "Conditional statements like `if`, `elseif`, and `else`."
msgstr "条件语句如 `if`、`elseif` 和 `else"

#: ../../source/guide/developer/4-transfer-from-matlab.md:64
msgid "Uses `for i in range(N):` with 0-based indexing."
msgstr "使用 `for i in range(N):`，采用从0开始的索引。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:65
msgid ""
"Indentation is significant for scoping in loops and conditionals (no `end` "
"keyword)."
msgstr "缩进在循环和条件语句中对于确定作用域是重要的（没有 `end` 关键字）。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:67
msgid "Printing and Comments"
msgstr "抱歉，我需要更多的上下文或具体的文本内容来进行翻译。请提供需要翻译的具体文本。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:71
msgid "Uses `fprintf()` functions for formatted output."
msgstr "使用 `fprintf()` 函数进行格式化输出。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:72
msgid "Uses `%` for single-line comments."
msgstr "使用 `%` 进行单行注释。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:76
msgid "Uses `print` with f-strings for formatted output."
msgstr "使用 `print` 和 f-strings 进行格式化输出。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:77
msgid "Uses `#` for single-line comments."
msgstr "使用 `#` 进行单行注释。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:79
msgid "Multi-line Coding"
msgstr "抱歉，我需要更多详细内容才能进行翻译。请提供具体的多行代码或完整的文本内容。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:83
msgid ""
"Uses `...` at the trailing of a line to indicate that the next line shall be"
" treated as the same line as."
msgstr "使用 `...` 在行尾表示下一行应视为与当前行相同的一行。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:84
msgid "Python"
msgstr "Python"

#: ../../source/guide/developer/4-transfer-from-matlab.md:86
msgid ""
"Uses `\\` at the trailing of a line to indicate that the next line shall be "
"treated as the same line as."
msgstr "使用 `\\` 在行尾表示下一行应被视为与当前行相同的一行。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:87
msgid ""
"If multiple lines are inside parentheses, no specific trailing symbol is "
"required."
msgstr "如果多行内容在括号内，则不需要特定的结尾符号。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:89
msgid "How to Write Evolutionary Computation Algorithm via EvoX?"
msgstr "如何通过EvoX编写演化计算算法？"

#: ../../source/guide/developer/4-transfer-from-matlab.md:93
msgid "A MATLAB code example for PSO algorithm is as follows:"
msgstr "以下是PSO算法的MATLAB代码示例："

#: ../../source/guide/developer/4-transfer-from-matlab.md:154
msgid ""
"In MATLAB, function `init_pso()` initializes the algorithm, and a separate "
"function `step_pso()` performs an iteration step and the main function "
"`example_pso()` orchestrates the loop."
msgstr ""
"在 MATLAB 中，函数 `init_pso()` 初始化算法，单独的函数 `step_pso()` 执行一个迭代步骤，主要函数 "
"`example_pso()` 组织循环。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:156
msgid "EvoX"
msgstr "EvoX"

#: ../../source/guide/developer/4-transfer-from-matlab.md:157
msgid "In EvoX, you can construct the PSO algorithm in following way:"
msgstr "在EvoX中，你可以通过以下方式构建PSO算法："

#: ../../source/guide/developer/4-transfer-from-matlab.md:159
msgid ""
"First, it is recommended to import necessary modules and functions from EvoX"
" and PyTorch."
msgstr "首先，建议从 EvoX 和 PyTorch 导入必要的模块和函数。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:169
msgid ""
"Then, you can transform the MATLAB code to the python code correspondingly "
"according to the \"Syntax Differences\" section."
msgstr "然后，您可以根据“语法差异”部分将MATLAB代码相应地转换为Python代码。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:238
msgid ""
"It is worth noting that we use `[]` with `;` and `,` in MATLAB to "
"concatenate matrices and vectors along specific dimension; however, in EvoX,"
" the `torch.cat` must be invoked with argument `dim` to indicate the "
"concatenation dimension. Moreover, in PyTorch, tensors to be concatenated "
"must have the same number of dimensions; therefore, additional "
"`XXX.unsqueeze(0)` is applied to add a new dimension of length 1 before the "
"first dimension."
msgstr ""
"值得注意的是，我们在MATLAB中使用`[]`与`;`和`,`来沿特定维度连接矩阵和向量；然而，在EvoX中，必须调用`torch.cat`并使用参数`dim`来指示连接的维度。此外，在PyTorch中，要连接的张量必须具有相同的维数；因此，额外的`XXX.unsqueeze(0)`被应用于在第一个维度之前添加一个长度为1的新维度。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:242
msgid ""
"In EvoX, the PSO logic is encapsulated within a class that inherits from "
"`Algorithm`. This object-oriented design simplifies state management and "
"iteration, and introduces following advantages:"
msgstr ""
"在 EvoX 中，PSO 逻辑被封装在一个继承自 `Algorithm` 的类中。这种面向对象的设计简化了状态管理和迭代，并引入了以下优点："

#: ../../source/guide/developer/4-transfer-from-matlab.md:243
msgid ""
"Inherited `evaluate()` method   You can simply call "
"`self.evaluate(self.population)` to compute fitness values, rather than "
"manually passing your objective function each iteration."
msgstr ""
"继承的 `evaluate()` 方法 你可以简单地调用 `self.evaluate(self.population)` "
"来计算适应度值，而不是在每次迭代中手动传递你的目标函数。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:245
msgid ""
"Built-In Workflow Integration   When you register your PSO class with a "
"workflow `StdWorkflow`, it handles iterative calls to "
"[`step()`](#StdWorkflow.step) on your behalf."
msgstr ""
"内置工作流集成\n"
"\n"
"当您将您的 PSO 类注册到工作流 `StdWorkflow` 时，它会代表您处理对 [`step()`](#StdWorkflow.step) 的迭代调用。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:248
msgid ""
"By extending `Algorithm`, `__init__()` sets up all major PSO components "
"(population, velocity, local/global best, etc.) in a standard Python class "
"constructor."
msgstr ""
"通过扩展 `Algorithm`，`__init__()` 在标准的 Python 类构造函数中设置所有主要的 PSO "
"组件（种群、速度、局部/全局最优等）。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10002
msgid "Deploy HPO with Custom Algorithms"
msgstr "部署具有自定义算法的HPO"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10004
msgid ""
"In this chapter, we will focus on deploying HPO with custom algorithms, "
"emphasizing the details rather than the overall workflow. A brief "
"introduction to HPO deployment is provided in the previous chapter, "
"[Efficient HPO with EvoX](#/guide/user/3-hpo), and prior reading is highly "
"recommended."
msgstr ""
"在本章中，我们将专注于使用自定义算法部署HPO，强调细节而不是整体工作流。上一章[Efficient HPO with "
"EvoX](#/guide/user/3-hpo)中提供了HPO部署的简要介绍，强烈建议事先阅读。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20002
msgid "Making Algorithms Parallelizable"
msgstr "使算法可并行化"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20004
msgid ""
"Since we need to transform the inner algorithm into the problem, it's "
"crucial that the inner algorithm is parallelizable. Therefore, some "
"modifications to the algorithm may be necessary."
msgstr "由于我们需要将内部算法转化为问题，确保内部算法是可并行化的至关重要。因此，可能需要对算法进行一些修改。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20006
msgid ""
"To ensure the function is JIT-compilable, it must meet the conditions "
"outlined in [JIT components](#/guide/developer/2-jit-able). In addition to "
"these requirements, the algorithm must also satisfy the following two "
"constraints:"
msgstr ""
"为了确保函数是 JIT 可编译的，它必须满足 [JIT components](#/guide/developer/2-jit-able) "
"中列出的条件。除了这些要求外，算法还必须满足以下两个约束："

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20008
msgid ""
"The algorithm should have no methods with in-place operations on the "
"attributes of the algorithm itself."
msgstr "算法不应有对其自身属性进行就地操作的方法。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20025
msgid "The code logic does not rely on python control flow."
msgstr "代码逻辑不依赖于 python 控制流。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20058
msgid ""
"In EvoX, we can easily make the algorithm parallelizable by the "
"[`@trace_impl`](#trace_impl) decorator."
msgstr "在 EvoX 中，我们可以通过 [`@trace_impl`](#trace_impl) 装饰器轻松地使算法并行化。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20060
msgid ""
"The parameter of this decorator is a non-parallelizable function, and the "
"decorated function is a rewrite of the original function. Detailed "
"introduction of [`@trace_impl`](#trace_impl) can be found in [JIT "
"Components](#/guide/developer/2-jit-able)."
msgstr ""
"此装饰器的参数是一个不可并行化的函数，装饰后的函数是对原始函数的重写。关于[`@trace_impl`](#trace_impl)的详细介绍可以在[JIT"
" Components](#/guide/developer/2-jit-able)中找到。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20062
msgid ""
"Under this mechanism, we can retain the original function for use outside "
"HPO tasks while enabling efficient computation within HPO tasks. Moreover, "
"this modification is highly convenient."
msgstr "在这种机制下，我们可以保留原始函数以便在 HPO 任务之外使用，同时在 HPO 任务中实现高效计算。此外，这种修改非常方便。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30002
msgid "Utilizing the HPOMonitor"
msgstr "利用 HPOMonitor"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30004
msgid ""
"In the HPO task, we should use the [`HPOMonitor`](#HPOMonitor) to track the "
"metrics of each inner algorithm. The [`HPOMonitor`](#HPOMonitor) adds only "
"one method, `tell_fitness`, compared to the standard [`monitor`](#Monitor). "
"This addition is designed to offer greater flexibility in evaluating "
"metrics, as HPO tasks often involve multi-dimensional and complex metrics."
msgstr ""
"在HPO任务中，我们应该使用[`HPOMonitor`](#HPOMonitor)来跟踪每个内部算法的指标。与标准的[`monitor`](#Monitor)相比，[`HPOMonitor`](#HPOMonitor)仅增加了一个方法，`tell_fitness`。此添加旨在提供更大的灵活性来评估指标，因为HPO任务通常涉及多维和复杂的指标。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30006
msgid ""
"Users only need to create a subclass of [`HPOMonitor`](#HPOMonitor) and "
"override the `tell_fitness` method to define custom evaluation metrics."
msgstr "用户只需创建一个[`HPOMonitor`](#HPOMonitor)的子类，并重写`tell_fitness`方法以定义自定义评估指标。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30008
msgid ""
"We also provide a simple [`HPOFitnessMonitor`](#HPOFitnessMonitor), which "
"supports calculating the 'IGD' and 'HV' metrics for multi-objective "
"problems, and the minimum value for single-objective problems."
msgstr ""
"我们还提供了一个简单的[`HPOFitnessMonitor`](#HPOFitnessMonitor)，支持计算多目标问题的“IGD”和“HV”指标，以及单目标问题的最小值。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40002
#: ../../source/guide/user/3-hpo.ipynb:50002
msgid "A simple example"
msgstr "一个简单的示例"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40004
msgid ""
"Here, we'll demonstrate a simple example of how to use HPO with EvoX. We "
"will use the [`PSO`](#PSO) algorithm to search for the optimal hyper-"
"parameters of a basic algorithm to solve the sphere problem."
msgstr ""
"在这里，我们将演示如何使用 EvoX 进行 HPO 的简单示例。我们将使用 [`PSO`](#PSO) 算法来搜索基本算法的最佳超参数，以解决球体问题。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40006
msgid "First, let's import the necessary modules."
msgstr "首先，让我们导入必要的模块。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:60002
msgid ""
"Next, we define an simple sphere problem. Note that this has no difference "
"from the common [`problems`](#evox.problems)."
msgstr "接下来，我们定义一个简单的球体问题。请注意，这与常见的[`problems`](#evox.problems)没有区别。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:80002
msgid ""
"Next, we define the algorithm. The original `step` function is non-"
"parallelizable, so we rewrite it using the [`@trace_impl`](#trace_impl) "
"decorator to make it parallelizable. Specifically, we modify in-place "
"operations and adjust the Python control flow."
msgstr ""
"接下来，我们定义算法。原始的`step`函数是不可并行化的，因此我们使用[`@trace_impl`](#trace_impl)装饰器重写它以实现并行化。具体来说，我们修改了就地操作并调整了Python控制流。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100002
msgid ""
"To handle the Python control flow, we use [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch). "
"Since, in tracing mode, variables outside the method may be incorrectly "
"interpreted as static variables, we need to use state to track them. A "
"detailed introduction to [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch) can be"
" found in [JIT Components](#/guide/developer/2-jit-able). Below, we provide "
"two equivalent implementations for the `trace_step` method."
msgstr ""
"要处理 Python 控制流，我们使用 "
"[`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
"[`TracingSwitch`](#TracingSwitch)。由于在追踪模式中，方法外的变量可能会被错误地解释为静态变量，我们需要使用状态来跟踪它们。关于"
" [`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
"[`TracingSwitch`](#TracingSwitch) 的详细介绍可以在 [JIT "
"Components](#/guide/developer/2-jit-able) 中找到。下面，我们提供了 `trace_step` "
"方法的两个等效实现。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100043
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to HPO problem."
msgstr ""
"接下来，我们可以使用 [`StdWorkflow`](#StdWorkflow) 来包装 "
"[`problem`](#evox.problems)、[`algorithm`](#evox.algorithms) 和 "
"[`monitor`](#Monitor)。然后我们使用 [`HPOProblemWrapper`](#HPOProblemWrapper) 将 "
"[`StdWorkflow`](#StdWorkflow) 转换为 HPO 问题。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:120002
msgid ""
"We can test whether the [`HPOProblemWrapper`](#HPOProblemWrapper) correctly "
"recognizes the hyper-parameters we defined. Since we have made no "
"modifications to the hyper-parameters for the 7 instances, they should be "
"identical across all instances."
msgstr ""
"我们可以测试 [`HPOProblemWrapper`](#HPOProblemWrapper) "
"是否正确识别了我们定义的超参数。由于我们没有对7个实例的超参数进行修改，它们在所有实例中应该是相同的。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:140002
msgid ""
"We can also specify our own set of hyperparameter values. Note that the "
"number of hyperparameter sets must match the number of instances in the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). The custom hyper-parameters "
"should be provided as a dictionary whose values are wrapped in the "
"[`Parameter`](#Parameter)."
msgstr ""
"我们也可以指定自己的一组超参数值。请注意，超参数集的数量必须与[`HPOProblemWrapper`](#HPOProblemWrapper)中的实例数量相匹配。自定义超参数应作为字典提供，其值被包装在[`Parameter`](#Parameter)中。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:160002
msgid ""
"Now, we use the [`PSO`](#PSO) algorithm to optimize the hyper-parameters of "
"`ExampleAlgorithm`. Note that the population size of the [`PSO`](#PSO) must "
"match the number of instances; otherwise, unexpected errors may occur. In "
"this case, we need to transform the solution in the outer workflow, as the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) requires a dictionary as input."
msgstr ""
"现在，我们使用[`PSO`](#PSO)算法来优化`ExampleAlgorithm`的超参数。请注意，[`PSO`](#PSO)的种群大小必须与实例数量匹配，否则可能会发生意外错误。在这种情况下，我们需要在外部工作流中转换解决方案，因为[`HPOProblemWrapper`](#HPOProblemWrapper)需要一个字典作为输入。"

#: ../../source/guide/developer/environment.md:1
msgid "Develop environment"
msgstr "开发环境"

#: ../../source/guide/developer/environment.md:3
msgid "Clone the repository and install it in editable mode (recommended)"
msgstr "克隆仓库并以可编辑模式安装（推荐）"

#: ../../source/guide/developer/environment.md:11
msgid "Nix"
msgstr ""
"抱歉，我不清楚您提供的文本“Nix”是需要翻译的目标内容，还是一个占位符。如果您能够更明确地提供要翻译的实际文本内容，我很乐意为您翻译成中文。"

#: ../../source/guide/developer/environment.md:13
msgid "Enable the Nix environment by running the following command:"
msgstr "启用 Nix 环境，请运行以下命令："

#: ../../source/guide/developer/environment.md:17
msgid ""
"This will create a shell with all the necessary dependencies and a `.venv` "
"directory with the Python environment."
msgstr "这将创建一个包含所有必要依赖项的 shell 和一个带有 Python 环境的 `.venv` 目录。"

#: ../../source/guide/developer/environment.md:19
msgid "Style guide"
msgstr "样式指南"

#: ../../source/guide/developer/environment.md:21
msgid "EvoX's has the following style guide:"
msgstr "EvoX 的风格指南如下:"

#: ../../source/guide/developer/environment.md:22
msgid ""
"Make sure to use [ruff](https://docs.astral.sh/ruff/) to lint your code."
msgstr "确保使用 [ruff](https://docs.astral.sh/ruff/) 来检查你的代码。"

#: ../../source/guide/developer/environment.md:23
msgid "Make sure there are no trailing whitespaces."
msgstr "请确保没有尾随空格。"

#: ../../source/guide/developer/environment.md:25
msgid "Pre-commit"
msgstr "预提交"

#: ../../source/guide/developer/environment.md:27
msgid ""
"We recommend using [pre-commit](https://pre-commit.com/) to enforce the "
"style guide. After installing pre-commit, run the following command to "
"install the hooks in your local repository:"
msgstr ""
"我们建议使用 [pre-commit](https://pre-commit.com/) 来强制执行样式指南。安装 pre-commit "
"后，运行以下命令在本地仓库中安装钩子："

#: ../../source/guide/developer/environment.md:33
msgid "Run Unit Test"
msgstr "运行单元测试"

#: ../../source/guide/developer/environment.md:35
msgid ""
"prepare the test environment by installing the required packages (e.g., "
"`torch`) in your Python environment"
msgstr "在您的 Python 环境中安装所需的包（例如，`torch`）以准备测试环境。"

#: ../../source/guide/developer/environment.md:36
msgid "run unittest:"
msgstr "请运行单元测试："

#: ../../source/guide/developer/index.md:1
msgid "Developer Guide"
msgstr "开发者指引"

#: ../../source/guide/experimental/index.md:1
msgid "Experimental Features"
msgstr "实验性功能"

#: ../../source/guide/install/index.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install/install.md:1
msgid "EvoX Installation Guide"
msgstr "EvoX安装教程"

#: ../../source/guide/install/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install/install.md:5
msgid "EvoX is available at PyPI and can be installed via:"
msgstr "EvoX 可通过 PyPI 获取，并可通过以下方式安装："

#: ../../source/guide/install/install.md:16
#, fuzzy
msgid ""
"You can also assign extra options during the installation, currently "
"available extras are `vis`, `neuroevolution`, `test`, `docs`. For example, "
"to install EvoX with all features, run the following command:"
msgstr ""
"您还可以在安装过程中指定额外选项，目前可用的额外选项包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed` 和 `full`。例如，要安装包含所有功能的 "
"EvoX，请运行以下命令:"

#: ../../source/guide/install/install.md:22
msgid "Install PyTorch with accelerator support"
msgstr "安装支持加速器的 PyTorch"

#: ../../source/guide/install/install.md:24
msgid ""
"`evox` relies on `torch` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`evox` 依赖于 `torch` 提供硬件加速。这些 Python 包的整体架构如下所示："

#: ../../source/guide/install/install.md:42
msgid ""
"To summarize, whether `evox` has CPU support or Nvidia GPU support (CUDA) or"
" AMD GPU support (ROCm) depends on the installed PyTorch version. Please "
"refer to the PyTorch official website for more installation help: "
"[`torch`](https://pytorch.org/)"
msgstr ""
"总之，`evox` 是否支持 CPU、Nvidia GPU (CUDA) 或 AMD GPU (ROCm) 取决于安装的 PyTorch 版本。请参考 "
"PyTorch 官方网站以获取更多安装帮助：[`torch`](https://pytorch.org/)"

#: ../../source/guide/install/install.md:45
msgid "Nvidia GPU support on Windows"
msgstr "Nvidia GPU 支持在 Windows 上"

#: ../../source/guide/install/install.md:47
msgid ""
"EvoX support GPU acceleration through PyTorch. There are two ways to use "
"PyTorch with GPU acceleration on Windows:"
msgstr "EvoX通过PyTorch支持GPU加速。在Windows上使用PyTorch进行GPU加速有两种方法："

#: ../../source/guide/install/install.md:50
msgid ""
"Using WSL 2 (Windows Subsystem for Linux) and install PyTorch on the Linux "
"side."
msgstr "使用 WSL 2（Windows Subsystem for Linux）并在 Linux 端安装 PyTorch。"

#: ../../source/guide/install/install.md:51
msgid "Directly install PyTorch on Windows."
msgstr "直接在 Windows 上安装 PyTorch。"

#: ../../source/guide/install/install.md:53
msgid ""
"We also provide a [one-click script](/_static/win-install.bat) for fast "
"deployment on fresh installed windows 10/11 64bit with Nvidia GPUs. The "
"script will not use WSL 2 and will install the native Pytorch version on "
"Windows. It will automatically install related applications like VSCode, Git"
" and MiniForge3."
msgstr ""
"我们还提供了一个[一键脚本](/_static/win-install.bat)，用于在全新安装的 Windows 10/11 64 位系统（配备 "
"Nvidia GPUs）上快速部署。该脚本不会使用 WSL 2，而是在 Windows 上安装本地版本的 Pytorch。它会自动安装相关应用程序，例如"
" VSCode、Git 和 MiniForge3。"

#: ../../source/guide/install/install.md:55
msgid ""
"Ensure the [Nvidia "
"driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) is properly "
"installed first. Otherwise the script will fall back to cpu mode."
msgstr ""
"确保先正确安装 [Nvidia driver](https://www.nvidia.com/Download/index.aspx?lang=en-"
"us)。否则脚本将回退到 cpu 模式。"

#: ../../source/guide/install/install.md:56
msgid ""
"When running the script, ensure a stable network (accessible to `github.com`"
" etc.)."
msgstr "运行脚本时，确保网络稳定（可访问 `github.com` 等）。"

#: ../../source/guide/install/install.md:57
msgid ""
"If the script is failed due to network failure, close and reopen it to "
"continue the installation."
msgstr "如果脚本因网络故障而失败，请关闭并重新打开以继续安装。"

#: ../../source/guide/install/install.md:59
msgid "Windows WSL 2 (optional)"
msgstr "Windows WSL 2（可选）"

#: ../../source/guide/install/install.md:61
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) and install "
"it. Then your WSL 2 will support Nvidia GPUs in its Linux environments."
msgstr ""
"下载并安装[最新的 NVIDIA Windows GPU "
"驱动程序](https://www.nvidia.com/Download/index.aspx?lang=en-us)。然后，您的 WSL 2 将在其"
" Linux 环境中支持 Nvidia GPU。"

#: ../../source/guide/install/install.md:64
msgid ""
"Do **NOT** install any NVIDIA GPU Linux driver within WSL 2. Install the "
"driver on the Windows side."
msgstr "请**不要**在WSL 2中安装任何NVIDIA GPU Linux驱动。在Windows端安装驱动。"

#: ../../source/guide/install/install.md:68
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda/wsl-"
"user-guide/index.html)"

#: ../../source/guide/install/install.md:71
msgid "AMD GPU (ROCm) support"
msgstr "AMD GPU (ROCm) 支持"

#: ../../source/guide/install/install.md:73
msgid ""
"We recommend using a Docker container from "
"[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)."
msgstr ""
"我们建议使用来自[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)的Docker容器。"

#: ../../source/guide/install/install.md:79
msgid "Verify the installation"
msgstr "验证安装"

#: ../../source/guide/install/install.md:81
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install/python.md:1
msgid "Python Installation Guide"
msgstr "Python安装教程"

#: ../../source/guide/install/python.md:3
msgid ""
"EvoX is written in Python, so you will need to have Python installed on your"
" system. EvoX support Python 3.9 and above, and we recommend using the "
"latest version of Python."
msgstr ""
"EvoX是用Python写的，所以你需要先在你的系统上安装Python。EvoX支持Python 3.9及以上，同时我们推荐使用最新版的Python。"

#: ../../source/guide/install/python.md:6
msgid "Windows Version"
msgstr "Windows 版本"

#: ../../source/guide/install/python.md:8
msgid ""
"Go to [Download Python](https://www.python.org/downloads/) and download the "
"latest version of Python."
msgstr "访问[Download Python](https://www.python.org/downloads/) 来下载最新版的Python。"

#: ../../source/guide/install/python.md:11
msgid ""
"Make sure to check the box that says \"Add Python to PATH\" during the "
"installation process."
msgstr "请确保在安装的过程中勾选\"Add Python to PATH\"这个选项。"

#: ../../source/guide/install/python.md:14
msgid "Linux Version"
msgstr "Linux 版本"

#: ../../source/guide/install/python.md:16
msgid ""
"Different Linux distributions have different ways to install Python. It "
"depends on the package manager of your distribution. Here are some examples:"
msgstr "不同的Linux发行版有不同的安装Python的方式。这取决于发行版所用的包管理器。这里有些例子："

#: ../../source/guide/install/python.md:19
msgid "Debian/Ubuntu: `apt`"
msgstr "Debian/Ubuntu: `apt"

#: ../../source/guide/install/python.md:20
msgid "Archlinux: `pacman`"
msgstr "Archlinux: `pacman"

#: ../../source/guide/install/python.md:21
msgid "Fedora: `dnf`"
msgstr "Fedora: `dnf"

#: ../../source/guide/user/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/user/1-start.ipynb:10004
msgid ""
"In this notebook, we will help you be familiar with EvoX through an simple "
"example."
msgstr "在这个笔记本中，我们将通过一个简单的例子帮助您熟悉EvoX。"

#: ../../source/guide/user/1-start.ipynb:10006
msgid "To start with, make sure you have already installed the EvoX."
msgstr "要开始，请确保您已经安装了EvoX。"

#: ../../source/guide/user/1-start.ipynb:40002
msgid "The basic running process in EvoX"
msgstr "EvoX中的基本运行过程"

#: ../../source/guide/user/1-start.ipynb:40004
msgid ""
"As a distributed GPU-accelerated framework for scalable evolutionary "
"computation, EvoX can be used to do many kinds computations, so we say "
"\"EvoX is all you need\". Though many kinds of computations are different "
"more or less, in EvoX we standardize the basic running process:"
msgstr ""
"作为一个分布式GPU加速框架，用于可扩展的演化计算，EvoX可以用于进行多种计算，因此我们说“EvoX是你所需要的一切”。尽管许多类型的计算或多或少有所不同，但在EvoX中，我们标准化了基本的运行过程："

#: ../../source/guide/user/1-start.ipynb:40013
msgid ""
"EvoX offers a comprehensive suite of 50+ Evolutionary Algorithms (EAs) and a"
" wide range of 100+ Benchmark Problems/Environments, all benefiting from "
"distributed GPU-acceleration."
msgstr "EvoX 提供了一个全面的套件，包括50多个演化算法（EAs）和100多个基准问题/环境，所有这些都受益于分布式GPU加速。"

#: ../../source/guide/user/1-start.ipynb:40015
msgid ""
"For more details, please refer to our API documentation: [List of "
"Algorithms](#evox.algorithms) and [List of Problems](#evox.problems)."
msgstr ""
"有关更多详细信息，请参阅我们的API文档：[List of Algorithms](#evox.algorithms) 和 [List of "
"Problems](#evox.problems)。"

#: ../../source/guide/user/1-start.ipynb:40017
msgid ""
"Here we will create a [PSO](#evox.algorithms.pso_variants.pso) algorithm and"
" an [Ackley](#evox.problems.numerical.basic.Ackley) function problem."
msgstr ""
"在这里，我们将创建一个 [PSO](#evox.algorithms.pso_variants.pso) 算法和一个 "
"[Ackley](#evox.problems.numerical.basic.Ackley) 函数问题。"

#: ../../source/guide/user/1-start.ipynb:60002
msgid ""
"Notice the algorithm and problem themselves do not contain the monitoring of"
" the steps, so we will not get any feed back only depending on them. It "
"turns out that we need a **monitor**."
msgstr "请注意，算法和问题本身并不包含步骤的监控，因此仅依靠它们我们不会得到任何反馈。事实证明，我们需要一个**monitor**。"

#: ../../source/guide/user/1-start.ipynb:60006
msgid ""
"[`Monitor`](#evox.workflows.eval_monitor.EvalMonitor) is a standard class in"
" EvoX to monitor the intermediate values inside a optimization process. "
"Information like fitness or population can be easily obtained by the "
"monitor."
msgstr ""
"[`Monitor`](#evox.workflows.eval_monitor.EvalMonitor) 是 EvoX "
"中的一个标准类，用于监视优化过程中的中间值。像适应度或种群这样的信息可以通过 Monitor 轻松获取。"

#: ../../source/guide/user/1-start.ipynb:60008
msgid "Doing is better than saying, so let us create a “Evaluation monitor”:"
msgstr "做比说更好，所以让我们创建一个“Evaluation monitor”："

#: ../../source/guide/user/1-start.ipynb:80004
msgid ""
"A **workflow** outlines the series of steps required to accomplish a task or"
" project. In EvoX, a workflow represents the overall process of evolutionary"
" computation, putting the algorithm, problem and monitor together."
msgstr "一个**工作流**概述了完成任务或项目所需的一系列步骤。在 EvoX 中，工作流代表了演化计算的整体过程，将算法、问题和监控器结合在一起。"

#: ../../source/guide/user/1-start.ipynb:80006
msgid ""
"If we want to run the algorithm to solve the problem with a monitor, we need"
" to create a workflow of the [`Workflow`](#evox.core.components.Workflow) "
"class."
msgstr ""
"如果我们想运行算法来解决带有监视器的问题，我们需要创建一个[`Workflow`](#evox.core.components.Workflow)类的工作流。"

#: ../../source/guide/user/1-start.ipynb:100004
msgid "Now, we can run the workflow:"
msgstr "现在，我们可以运行工作流："

#: ../../source/guide/user/1-start.ipynb:130002
msgid ""
"Congretulations if you can reproduce the Quick Start demo! Hope you enjoy "
"the EvoX!"
msgstr "恭喜你能够重现快速入门演示！希望你喜欢EvoX！"

#: ../../source/guide/user/2-problems.ipynb:40002
msgid "Use EvoX to solve Neuroevolution Tasks"
msgstr "使用 EvoX 解决 Neuroevolution 任务"

#: ../../source/guide/user/2-problems.ipynb:40003
msgid ""
"Neuroevolution is an optimization method that combines neural networks with "
"evolutionary algorithms to evolve the structure and parameters of neural "
"networks. By simulating natural selection and genetic mechanisms, "
"Neuroevolution aims to optimize neural network architectures and weights, "
"addressing complex problems such as game AI, robotic control, and more."
msgstr ""
"神经演化是一种优化方法，它将神经网络与演化算法结合起来，以演化神经网络的结构和参数。通过模拟自然选择和遗传机制，神经演化旨在优化神经网络的架构和权重，解决复杂问题，如游戏AI、机器人控制等。"

#: ../../source/guide/user/2-problems.ipynb:40005
msgid ""
"In our example of neuroevolution tasks, Brax is needed. So it is recommended"
" to install Brax if you want to replicate this example."
msgstr "在我们的神经演化任务示例中，需要使用 Brax。因此，如果您想复制此示例，建议安装 Brax。"

#: ../../source/guide/user/2-problems.ipynb:50007
msgid ""
"Here we will demonstrate a \"swimmer\" environment of Brax. For more "
"information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr ""
"在这里，我们将演示Brax的“swimmer”环境。有关更多信息，您可以浏览[Github of "
"Brax](https://github.com/google/brax)。"

#: ../../source/guide/user/2-problems.ipynb:100006
msgid ""
"[`to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.to_vector) "
"can convert a parameters dictionary to a vector."
msgstr ""
"[`to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.to_vector) "
"可以将参数字典转换为向量。"

#: ../../source/guide/user/2-problems.ipynb:100007
msgid ""
"[`to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.to_params) "
"can convert a vector back to a parameters dictionary."
msgstr ""
"[`to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.to_params) "
"可以将一个向量转换回参数字典。"

#: ../../source/guide/user/2-problems.ipynb:100009
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/user/2-problems.ipynb:100011
msgid ""
"[`batched_to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_vector)"
" can convert a batched parameters dictionary to a batch of vectors."
msgstr ""
"[`batched_to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_vector)"
" 可以将一个批量参数字典转换为一批向量。"

#: ../../source/guide/user/2-problems.ipynb:100012
msgid ""
"[`batched_to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_params)"
" can convert a batch of vectors back to a batched parameters dictionary."
msgstr ""
"[`batched_to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_params)"
" 可以将一批向量转换回批量参数字典。"

#: ../../source/guide/user/3-hpo.ipynb:10002
msgid "Efficient HPO with EvoX"
msgstr "高效超参数优化（HPO）使用 EvoX"

#: ../../source/guide/user/3-hpo.ipynb:10004
msgid ""
"In this chapter, we will explore how to use EvoX for hyperparameter "
"optimization (HPO)."
msgstr "在本章中，我们将探讨如何使用 EvoX 进行超参数优化 (HPO)。"

#: ../../source/guide/user/3-hpo.ipynb:10006
msgid ""
"HPO plays a crucial role in many machine learning tasks but is often "
"overlooked due to its high computational cost, which can sometimes take days"
" to process, as well as the challenges involved in deployment."
msgstr "HPO 在许多机器学习任务中起着至关重要的作用，但由于其高计算成本（有时需要几天的处理时间）以及部署过程中涉及的挑战，常常被忽视。"

#: ../../source/guide/user/3-hpo.ipynb:10008
msgid ""
"With EvoX, we can simplify HPO deployment using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) and achieve efficient computation "
"by leveraging the `vmap` method and GPU acceleration."
msgstr ""
"使用 EvoX，我们可以通过 [`HPOProblemWrapper`](#HPOProblemWrapper) 简化 HPO 部署，并通过利用 "
"`vmap` 方法和 GPU 加速实现高效计算。"

#: ../../source/guide/user/3-hpo.ipynb:20002
msgid "Transforming Workflow into Problem"
msgstr "将工作流转化为问题"

#: ../../source/guide/user/3-hpo.ipynb:20004
msgid "HPO structure"
msgstr "HPO 结构"

#: ../../source/guide/user/3-hpo.ipynb:20010
msgid ""
"The key to deploying HPO with EvoX is to transform the "
"[`workflows`](#evox.workflows) into [`problems`](#evox.problems) using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). Once transformed, we can treat "
"the [`workflows`](#evox.workflows) as standard [`problems`](#evox.problems)."
" The input to the 'HPO problem' consists of the hyper-parameters, and the "
"output is the evaluation metrics."
msgstr ""
"将HPO与EvoX一起部署的关键是使用[`HPOProblemWrapper`](#HPOProblemWrapper)将[`workflows`](#evox.workflows)转换为[`problems`](#evox.problems)。一旦转换完成，我们可以将[`workflows`](#evox.workflows)视为标准的[`problems`](#evox.problems)。'HPO问题'的输入由超参数组成，输出是评估指标。"

#: ../../source/guide/user/3-hpo.ipynb:30002
msgid "The Key Component -- `HPOProblemWrapper`"
msgstr "关键组件 -- `HPOProblemWrapper"

#: ../../source/guide/user/3-hpo.ipynb:30004
msgid ""
"To ensure the [`HPOProblemWrapper`](#HPOProblemWrapper) recognizes the "
"hyper-parameters, we need to wrap them using [`Parameter`](#Parameter). With"
" this straightforward step, the hyper-parameters will be automatically "
"identified."
msgstr ""
"为了确保 [`HPOProblemWrapper`](#HPOProblemWrapper) 识别超参数，我们需要使用 "
"[`Parameter`](#Parameter) 来包装它们。通过这个简单的步骤，超参数将被自动识别。"

#: ../../source/guide/user/3-hpo.ipynb:40002
msgid "Utilizing the `HPOFitnessMonitor`"
msgstr "利用 `HPOFitnessMonitor"

#: ../../source/guide/user/3-hpo.ipynb:40004
msgid ""
"We provide an [`HPOFitnessMonitor`](#HPOFitnessMonitor) that supports "
"calculating 'IGD' and 'HV' metrics for multi-objective problems, as well as "
"the minimum value for single-objective problems."
msgstr ""
"我们提供了一个[`HPOFitnessMonitor`](#HPOFitnessMonitor)，支持计算多目标问题的“IGD”和“HV”指标，以及单目标问题的最小值。"

#: ../../source/guide/user/3-hpo.ipynb:40006
msgid ""
"It is important to note that the [`HPOFitnessMonitor`](#HPOFitnessMonitor) "
"is a basic monitor designed for HPO problems. You can also create your own "
"customized monitor flexibly using the approach outlined in [Deploy HPO with "
"Custom Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""
"请注意，[`HPOFitnessMonitor`](#HPOFitnessMonitor) 是一个为 HPO "
"问题设计的基本监视器。您还可以使用[使用自定义算法部署 "
"HPO](#/guide/developer/custom_hpo_prob)中概述的方法灵活地创建自己的自定义监视器。"

#: ../../source/guide/user/3-hpo.ipynb:50004
msgid ""
"Here, we'll demonstrate a simple example of using EvoX for HPO. "
"Specifically, we will use the [PSO](#PSO) algorithm to optimize the hyper-"
"parameters of the [PSO](#PSO) algorithm for solving the sphere problem."
msgstr ""
"在这里，我们将演示一个使用 EvoX 进行 HPO 的简单示例。具体来说，我们将使用 [PSO](#PSO) 算法来优化 [PSO](#PSO) "
"算法的超参数，以解决球体问题。"

#: ../../source/guide/user/3-hpo.ipynb:50006
msgid ""
"Please note that this chapter provides only a brief overview of HPO "
"deployment. For a more detailed guide, refer to [Deploy HPO with Custom "
"Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""
"请注意，本章仅提供 HPO 部署的简要概述。有关更详细的指南，请参阅[使用自定义 Algorithms 部署 "
"HPO](#/guide/developer/custom_hpo_prob)。"

#: ../../source/guide/user/3-hpo.ipynb:50008
msgid "To start, let's import the necessary modules."
msgstr "要开始，让我们导入必要的模块。"

#: ../../source/guide/user/3-hpo.ipynb:70002
msgid "Next, we define a simple Sphere problem."
msgstr "接下来，我们定义一个简单的 Sphere 问题。"

#: ../../source/guide/user/3-hpo.ipynb:90002
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to an HPO problem."
msgstr ""
"接下来，我们可以使用 [`StdWorkflow`](#StdWorkflow) 来包装 "
"[`problem`](#evox.problems)、[`algorithm`](#evox.algorithms) 和 "
"[`monitor`](#Monitor)。然后我们使用 [`HPOProblemWrapper`](#HPOProblemWrapper) 将 "
"[`StdWorkflow`](#StdWorkflow) 转换为一个 HPO 问题。"

#: ../../source/guide/user/3-hpo.ipynb:110002
msgid "The [`HPOProblemWrapper`](#HPOProblemWrapper) takes 4 arguments:"
msgstr "`HPOProblemWrapper` 接受 4 个参数："

#: ../../source/guide/user/3-hpo.ipynb:110003
msgid ""
"`iterations`: The number of iterations to be executed in the optimization "
"process."
msgstr "`iterations`：在优化过程中要执行的迭代次数。"

#: ../../source/guide/user/3-hpo.ipynb:110004
msgid ""
"`num_instances`: The number of instances to be executed in parallel in the "
"optimization process."
msgstr "`num_instances`: 在优化过程中的并行执行实例数量。"

#: ../../source/guide/user/3-hpo.ipynb:110005
msgid ""
"`workflow`: The workflow to be used in the optimization process. Must be "
"wrapped by [`jit_class`](#jit_class)."
msgstr "`workflow`: 在优化过程中使用的工作流。必须由[`jit_class`](#jit_class)包装。"

#: ../../source/guide/user/3-hpo.ipynb:110006
msgid ""
"`copy_init_state`: Whether to copy the initial state of the workflow for "
"each evaluation. Defaults to `True`. If your workflow contains operations "
"that IN-PLACE modify the tensor(s) in initial state, this should be set to "
"`True`. Otherwise, you can set it to `False` to save memory."
msgstr ""
"`copy_init_state`: 是否为每次评估复制工作流的初始状态。默认为 "
"`True`。如果你的工作流包含对初始状态中的张量进行原地修改的操作，则应将其设置为 `True`。否则，可以将其设置为 `False` 以节省内存。"

#: ../../source/guide/user/3-hpo.ipynb:110008
msgid ""
"We can verify whether the [`HPOProblemWrapper`](#HPOProblemWrapper) "
"correctly recognizes the hyper-parameters we define. Since no modifications "
"are made to the hyper-parameters across the 5 instances, they should remain "
"identical for all instances."
msgstr ""
"我们可以验证 [`HPOProblemWrapper`](#HPOProblemWrapper) "
"是否正确识别我们定义的超参数。由于在这5个实例中没有对超参数进行修改，它们在所有实例中应该保持一致。"

#: ../../source/guide/user/3-hpo.ipynb:130002
msgid ""
"We can also define a custom set of hyperparameter values. It is important to"
" ensure that the number of hyperparameter sets matches the number of "
"instances in the [`HPOProblemWrapper`](#HPOProblemWrapper). Additionally, "
"custom hyper-parameters must be provided as a dictionary whose values are "
"wrapped using the [`Parameter`](#Parameter)."
msgstr ""
"我们也可以定义一组自定义的超参数值。确保超参数集的数量与[`HPOProblemWrapper`](#HPOProblemWrapper)中的实例数量匹配是很重要的。此外，自定义超参数必须以字典形式提供，其值需要使用[`Parameter`](#Parameter)进行包装。"

#: ../../source/guide/user/3-hpo.ipynb:150002
msgid ""
"Now, we use the [PSO](#PSO) algorithm to optimize the hyperparameters of the"
" [PSO](#PSO) algorithm."
msgstr "现在，我们使用[PSO](#PSO)算法来优化[PSO](#PSO)算法的超参数。"

#: ../../source/guide/user/3-hpo.ipynb:150004
msgid ""
"It is important to ensure that the population size of the [PSO](#PSO) "
"matches the number of instances; otherwise, unexpected errors may occur."
msgstr "确保[PSO](#PSO)的种群大小与实例数量匹配非常重要，否则可能会发生意外错误。"

#: ../../source/guide/user/3-hpo.ipynb:150006
msgid ""
"Additionally, the solution needs to be transformed in the outer workflow, as"
" the [`HPOProblemWrapper`](#HPOProblemWrapper) requires the input to be in "
"the form of a dictionary."
msgstr ""
"此外，解决方案需要在外部工作流中进行转换，因为[`HPOProblemWrapper`](#HPOProblemWrapper)要求输入为字典形式。"

#: ../../source/guide/user/index.md:1 ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:22 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr "杂项"

#: ../../source/index.md:22
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:31
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"

#: ../../source/index.md:33
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary "
"computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/index.md:37
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:39
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:40
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:41
msgid ""
"Leverage the power of Distributed Workflows for even more rapid "
"optimization."
msgstr "利用分布式工作流的强大功能，实现更快速的优化。"

#: ../../source/index.md:43
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:44
msgid ""
"Cater to all your needs with both [Single-objective and Multi-"
"objective](#algorithms) optimization capabilities."
msgstr "满足您所有需求，包括[单目标和多目标](#algorithms)优化。"

#: ../../source/index.md:45
msgid ""
"Dive into a comprehensive library of [Benchmark Problems](#problems), "
"ensuring robust testing and evaluation."
msgstr "深入了解全面的[基准测试问题库](#problems)，确保进行稳健的测试和评估。"

#: ../../source/index.md:46
msgid ""
"Explore the frontier of AI with extensive tools for "
"[Neuroevolution](#neuroevolution) tasks."
msgstr "探索人工智能前沿领域，利用丰富的工具进行[神经演化](#neuroevolution)任务。"

#: ../../source/index.md:48
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:49
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:50
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and clean "
"programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:53
msgid "<br></br>"
msgstr "<br></br>"

#: ../../source/index.md:60
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> Installation "
"Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> 安装教程"

#: ../../source/index.md:66
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> User Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> 用户教程"

#: ../../source/index.md:72
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> Developer Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> 开发者教程"

#: ../../source/index.md:82
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 算法"

#: ../../source/index.md:88
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 问题"

#: ../../source/index.md:95
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 指标"

#: ../../source/miscellaneous/selecting_gpu.md:1
msgid "Selecting GPU / CPU"
msgstr "选择 GPU / CPU"

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""
"要在特定的 GPU 上运行程序，您可以使用 `CUDA_VISIBLE_DEVICES` 环境变量。例如，要在第二个 GPU 上运行程序，您可以使用："

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr "要在多个GPU上跑你的程序，你可以用："

#: ../../source/miscellaneous/selecting_gpu.md:15
msgid "To disable GPU usage (use CPU), you can use:"
msgstr "如果要禁用GPU（即使用CPU），你可以用："

#~ msgid ""
#~ "(Optional) You can uncomment and execute the following code to print a table"
#~ " to view the hotspot functions."
#~ msgstr "（可选）您可以取消注释并执行以下代码以打印表格查看热点函数。"

#~ msgid "Solving Supervised Learning Tasks with Neuroevolution in EvoX"
#~ msgstr "在EvoX中使用神经演化解决监督学习任务"

#~ msgid "Extended Applications"
#~ msgstr "处理扩展应用"

#~ msgid ""
#~ "EvoX facilitates efficient exploration of complex optimization landscapes, "
#~ "effective tackling of black-box optimization challenges, and deep dives into"
#~ " neuroevolution with Brax. Thus, it is talented in extended applications.  "
#~ "Here we will show an example of Neuroevolution Tasks using EvoX and Brax."
#~ msgstr ""
#~ "EvoX 促进了复杂优化景观的高效探索，有效解决黑箱优化挑战，并深入研究使用 Brax 的神经演化。因此，它在扩展应用中表现出色。这里我们将展示一个使用"
#~ " EvoX 和 Brax 的神经演化任务示例。"

#~ msgid "Through the `SimpleMLP` class, we can initiate a MLP model."
#~ msgstr "通过 `SimpleMLP` 类，我们可以初始化一个 MLP 模型。"

#~ msgid ""
#~ "We can compute the total number of the model parameters, and check if the "
#~ "model id initialized correctly. If everything goes well, we will see the "
#~ "total number is 63."
#~ msgstr "我们可以计算模型参数的总数，并检查模型是否正确初始化。如果一切顺利，我们将看到总数是63。"

#~ msgid ""
#~ "We can also test the dimoension of the inputs and outputs. If everything "
#~ "goes well, 11 inputs will obtain 3 outputs."
#~ msgstr "我们也可以测试输入和输出的维度。如果一切顺利，11个输入将获得3个输出。"

#~ msgid ""
#~ "If we check the weights data of this network, we will see the data is in the"
#~ " dictionary form, and many EC algorithms cannot directly work with such a "
#~ "format:"
#~ msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）算法无法直接处理这种格式的数据。"

#~ msgid ""
#~ "Fortunately, EvoX provides some useful utilities to help us bridge the gap, "
#~ "and in this case, we have "
#~ "[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) class"
#~ " to help us convert a tree-like struct into a vector and back."
#~ msgstr ""
#~ "幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#~ msgid ""
#~ "For some algorithms designed for neuroevolution, that is, algorithms that "
#~ "directly accept the batched parameters dictionary, adapter is not necessary "
#~ "and should be removed to improve performance."
#~ msgstr "对于一些为神经演化设计的算法，即直接接受批处理参数字典的算法，适配器不是必需的，应将其移除以提高性能。"

#~ msgid ""
#~ "We still initiate a [PSO](#evox.algorithms.pso_variants.pso.PSO) algorithm, "
#~ "and the problem is a [Brax "
#~ "problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"hopper\" "
#~ "environment."
#~ msgstr ""
#~ "我们仍然启动一个 [PSO](#evox.algorithms.pso_variants.pso.PSO) 算法，问题是在“hopper”环境中的 "
#~ "[Brax problem](#evox.problems.neuroevolution.brax.BraxProblem)。"

#~ msgid "`max_episode_length` is the maximum number of steps for each episode."
#~ msgstr "运行的最大的时间步的数量。"

#~ msgid "`num_episodes` is the number of episodes to run for each evaluation."
#~ msgstr "用于评估每个个体的幕数量。"

#~ msgid ""
#~ "The following block will take around 1 minute to run. The time may vary "
#~ "depending on your hardware."
#~ msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#~ msgid ""
#~ "The PSO wasn’t specialized for this type of tasks, so its performance "
#~ "limitations here are expected. Here we just show an example."
#~ msgstr "PSO 并不是专门为这类任务设计的，因此在这里的性能限制是可以预期的。这里我们只是展示一个例子。"

#~ msgid ""
#~ "Hope you can use a quantity of more effective algorithms in EvoX and enjoy "
#~ "your time!"
#~ msgstr "希望您能在 EvoX 中使用更多有效的算法，并享受您的时光！"
